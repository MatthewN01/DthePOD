{"ast":null,"code":"import _objectSpread from \"C:/Users/Matt/Documents/DTP/0.1/dtp-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _assertThisInitialized from \"C:/Users/Matt/Documents/DTP/0.1/dtp-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/Matt/Documents/DTP/0.1/dtp-app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Matt/Documents/DTP/0.1/dtp-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Matt/Documents/DTP/0.1/dtp-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Matt/Documents/DTP/0.1/dtp-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _slicedToArray from \"C:/Users/Matt/Documents/DTP/0.1/dtp-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _defineProperty from \"C:/Users/Matt/Documents/DTP/0.1/dtp-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"C:/Users/Matt/Documents/DTP/0.1/dtp-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Matt/Documents/DTP/0.1/dtp-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _toConsumableArray from \"C:/Users/Matt/Documents/DTP/0.1/dtp-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Matt/Documents/DTP/0.1/dtp-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */\nfunction ct() {}\nvar _o = function () {\n  var i = 0;\n  return function () {\n    return i++;\n  };\n}();\nfunction T(i) {\n  return i === null || typeof i > \"u\";\n}\nfunction z(i) {\n  if (Array.isArray && Array.isArray(i)) return !0;\n  var t = Object.prototype.toString.call(i);\n  return t.slice(0, 7) === \"[object\" && t.slice(-6) === \"Array]\";\n}\nfunction D(i) {\n  return i !== null && Object.prototype.toString.call(i) === \"[object Object]\";\n}\nvar N = function N(i) {\n  return (typeof i == \"number\" || i instanceof Number) && isFinite(+i);\n};\nfunction Q(i, t) {\n  return N(i) ? i : t;\n}\nfunction C(i, t) {\n  return typeof i > \"u\" ? t : i;\n}\nvar yo = function yo(i, t) {\n    return typeof i == \"string\" && i.endsWith(\"%\") ? parseFloat(i) / 100 : i / t;\n  },\n  an = function an(i, t) {\n    return typeof i == \"string\" && i.endsWith(\"%\") ? parseFloat(i) / 100 * t : +i;\n  };\nfunction I(i, t, e) {\n  if (i && typeof i.call == \"function\") return i.apply(e, t);\n}\nfunction E(i, t, e, s) {\n  var n, o, r;\n  if (z(i)) {\n    if (o = i.length, s) for (n = o - 1; n >= 0; n--) t.call(e, i[n], n);else for (n = 0; n < o; n++) t.call(e, i[n], n);\n  } else if (D(i)) for (r = Object.keys(i), o = r.length, n = 0; n < o; n++) t.call(e, i[r[n]], r[n]);\n}\nfunction ze(i, t) {\n  var e, s, n, o;\n  if (!i || !t || i.length !== t.length) return !1;\n  for (e = 0, s = i.length; e < s; ++e) if (n = i[e], o = t[e], n.datasetIndex !== o.datasetIndex || n.index !== o.index) return !1;\n  return !0;\n}\nfunction Be(i) {\n  if (z(i)) return i.map(Be);\n  if (D(i)) {\n    var t = /* @__PURE__ */Object.create(null),\n      e = Object.keys(i),\n      s = e.length;\n    var n = 0;\n    for (; n < s; ++n) t[e[n]] = Be(i[e[n]]);\n    return t;\n  }\n  return i;\n}\nfunction ln(i) {\n  return [\"__proto__\", \"prototype\", \"constructor\"].indexOf(i) === -1;\n}\nfunction vo(i, t, e, s) {\n  if (!ln(i)) return;\n  var n = t[i],\n    o = e[i];\n  D(n) && D(o) ? ne(n, o, s) : t[i] = Be(o);\n}\nfunction ne(i, t, e) {\n  var s = z(t) ? t : [t],\n    n = s.length;\n  if (!D(i)) return i;\n  e = e || {};\n  var o = e.merger || vo;\n  for (var r = 0; r < n; ++r) {\n    if (t = s[r], !D(t)) continue;\n    var a = Object.keys(t);\n    for (var l = 0, c = a.length; l < c; ++l) o(a[l], i, t, e);\n  }\n  return i;\n}\nfunction Qt(i, t) {\n  return ne(i, t, {\n    merger: Mo\n  });\n}\nfunction Mo(i, t, e) {\n  if (!ln(i)) return;\n  var s = t[i],\n    n = e[i];\n  D(s) && D(n) ? Qt(s, n) : Object.prototype.hasOwnProperty.call(t, i) || (t[i] = Be(n));\n}\nvar Xi = {\n  \"\": function _(i) {\n    return i;\n  },\n  x: function x(i) {\n    return i.x;\n  },\n  y: function y(i) {\n    return i.y;\n  }\n};\nfunction _t(i, t) {\n  return (Xi[t] || (Xi[t] = ko(t)))(i);\n}\nfunction ko(i) {\n  var t = wo(i);\n  return function (e) {\n    var _iterator = _createForOfIteratorHelper(t),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var s = _step.value;\n        if (s === \"\") break;\n        e = e && e[s];\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return e;\n  };\n}\nfunction wo(i) {\n  var t = i.split(\".\"),\n    e = [];\n  var s = \"\";\n  var _iterator2 = _createForOfIteratorHelper(t),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var n = _step2.value;\n      s += n, s.endsWith(\"\\\\\") ? s = s.slice(0, -1) + \".\" : (e.push(s), s = \"\");\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return e;\n}\nfunction Oi(i) {\n  return i.charAt(0).toUpperCase() + i.slice(1);\n}\nvar et = function et(i) {\n    return typeof i < \"u\";\n  },\n  yt = function yt(i) {\n    return typeof i == \"function\";\n  },\n  Ui = function Ui(i, t) {\n    if (i.size !== t.size) return !1;\n    var _iterator3 = _createForOfIteratorHelper(i),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var e = _step3.value;\n        if (!t.has(e)) return !1;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    return !0;\n  };\nfunction So(i) {\n  return i.type === \"mouseup\" || i.type === \"click\" || i.type === \"contextmenu\";\n}\nvar B = Math.PI,\n  F = 2 * B,\n  Po = F + B,\n  Ve = Number.POSITIVE_INFINITY,\n  Co = B / 180,\n  V = B / 2,\n  $t = B / 4,\n  Ki = B * 2 / 3,\n  tt = Math.log10,\n  lt = Math.sign;\nfunction qi(i) {\n  var t = Math.round(i);\n  i = te(i, t, i / 1e3) ? t : i;\n  var e = Math.pow(10, Math.floor(tt(i))),\n    s = i / e;\n  return (s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10) * e;\n}\nfunction Do(i) {\n  var t = [],\n    e = Math.sqrt(i);\n  var s;\n  for (s = 1; s < e; s++) i % s === 0 && (t.push(s), t.push(i / s));\n  return e === (e | 0) && t.push(e), t.sort(function (n, o) {\n    return n - o;\n  }).pop(), t;\n}\nfunction Bt(i) {\n  return !isNaN(parseFloat(i)) && isFinite(i);\n}\nfunction te(i, t, e) {\n  return Math.abs(i - t) < e;\n}\nfunction Oo(i, t) {\n  var e = Math.round(i);\n  return e - t <= i && e + t >= i;\n}\nfunction cn(i, t, e) {\n  var s, n, o;\n  for (s = 0, n = i.length; s < n; s++) o = i[s][e], isNaN(o) || (t.min = Math.min(t.min, o), t.max = Math.max(t.max, o));\n}\nfunction nt(i) {\n  return i * (B / 180);\n}\nfunction Ai(i) {\n  return i * (180 / B);\n}\nfunction Gi(i) {\n  if (!N(i)) return;\n  var t = 1,\n    e = 0;\n  for (; Math.round(i * t) / t !== i;) t *= 10, e++;\n  return e;\n}\nfunction hn(i, t) {\n  var e = t.x - i.x,\n    s = t.y - i.y,\n    n = Math.sqrt(e * e + s * s);\n  var o = Math.atan2(s, e);\n  return o < -0.5 * B && (o += F), {\n    angle: o,\n    distance: n\n  };\n}\nfunction bi(i, t) {\n  return Math.sqrt(Math.pow(t.x - i.x, 2) + Math.pow(t.y - i.y, 2));\n}\nfunction Ao(i, t) {\n  return (i - t + Po) % F - B;\n}\nfunction Z(i) {\n  return (i % F + F) % F;\n}\nfunction oe(i, t, e, s) {\n  var n = Z(i),\n    o = Z(t),\n    r = Z(e),\n    a = Z(o - n),\n    l = Z(r - n),\n    c = Z(n - o),\n    h = Z(n - r);\n  return n === o || n === r || s && o === r || a > l && c < h;\n}\nfunction Y(i, t, e) {\n  return Math.max(t, Math.min(e, i));\n}\nfunction To(i) {\n  return Y(i, -32768, 32767);\n}\nfunction ut(i, t, e) {\n  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e-6;\n  return i >= Math.min(t, e) - s && i <= Math.max(t, e) + s;\n}\nfunction Ti(i, t, e) {\n  e = e || function (r) {\n    return i[r] < t;\n  };\n  var s = i.length - 1,\n    n = 0,\n    o;\n  for (; s - n > 1;) o = n + s >> 1, e(o) ? n = o : s = o;\n  return {\n    lo: n,\n    hi: s\n  };\n}\nvar ft = function ft(i, t, e, s) {\n    return Ti(i, e, s ? function (n) {\n      return i[n][t] <= e;\n    } : function (n) {\n      return i[n][t] < e;\n    });\n  },\n  Lo = function Lo(i, t, e) {\n    return Ti(i, e, function (s) {\n      return i[s][t] >= e;\n    });\n  };\nfunction Ro(i, t, e) {\n  var s = 0,\n    n = i.length;\n  for (; s < n && i[s] < t;) s++;\n  for (; n > s && i[n - 1] > e;) n--;\n  return s > 0 || n < i.length ? i.slice(s, n) : i;\n}\nvar dn = [\"push\", \"pop\", \"shift\", \"splice\", \"unshift\"];\nfunction Eo(i, t) {\n  if (i._chartjs) {\n    i._chartjs.listeners.push(t);\n    return;\n  }\n  Object.defineProperty(i, \"_chartjs\", {\n    configurable: !0,\n    enumerable: !1,\n    value: {\n      listeners: [t]\n    }\n  }), dn.forEach(function (e) {\n    var s = \"_onData\" + Oi(e),\n      n = i[e];\n    Object.defineProperty(i, e, {\n      configurable: !0,\n      enumerable: !1,\n      value: function value() {\n        for (var _len = arguments.length, o = new Array(_len), _key = 0; _key < _len; _key++) {\n          o[_key] = arguments[_key];\n        }\n        var r = n.apply(this, o);\n        return i._chartjs.listeners.forEach(function (a) {\n          typeof a[s] == \"function\" && a[s].apply(a, o);\n        }), r;\n      }\n    });\n  });\n}\nfunction Zi(i, t) {\n  var e = i._chartjs;\n  if (!e) return;\n  var s = e.listeners,\n    n = s.indexOf(t);\n  n !== -1 && s.splice(n, 1), !(s.length > 0) && (dn.forEach(function (o) {\n    delete i[o];\n  }), delete i._chartjs);\n}\nfunction un(i) {\n  var t = /* @__PURE__ */new Set();\n  var e, s;\n  for (e = 0, s = i.length; e < s; ++e) t.add(i[e]);\n  return t.size === s ? i : Array.from(t);\n}\nvar fn = function () {\n  return typeof window > \"u\" ? function (i) {\n    return i();\n  } : window.requestAnimationFrame;\n}();\nfunction gn(i, t, e) {\n  var s = e || function (r) {\n    return Array.prototype.slice.call(r);\n  };\n  var n = !1,\n    o = [];\n  return function () {\n    for (var _len2 = arguments.length, r = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      r[_key2] = arguments[_key2];\n    }\n    o = s(r), n || (n = !0, fn.call(window, function () {\n      n = !1, i.apply(t, o);\n    }));\n  };\n}\nfunction Fo(i, t) {\n  var e;\n  return function () {\n    for (var _len3 = arguments.length, s = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      s[_key3] = arguments[_key3];\n    }\n    return t ? (clearTimeout(e), e = setTimeout(i, t, s)) : i.apply(this, s), t;\n  };\n}\nvar Li = function Li(i) {\n    return i === \"start\" ? \"left\" : i === \"end\" ? \"right\" : \"center\";\n  },\n  U = function U(i, t, e) {\n    return i === \"start\" ? t : i === \"end\" ? e : (t + e) / 2;\n  },\n  Io = function Io(i, t, e, s) {\n    return i === (s ? \"left\" : \"right\") ? e : i === \"center\" ? (t + e) / 2 : t;\n  };\nfunction pn(i, t, e) {\n  var s = t.length;\n  var n = 0,\n    o = s;\n  if (i._sorted) {\n    var r = i.iScale,\n      a = i._parsed,\n      l = r.axis,\n      _r$getUserBounds = r.getUserBounds(),\n      c = _r$getUserBounds.min,\n      h = _r$getUserBounds.max,\n      d = _r$getUserBounds.minDefined,\n      u = _r$getUserBounds.maxDefined;\n    d && (n = Y(Math.min(ft(a, r.axis, c).lo, e ? s : ft(t, l, r.getPixelForValue(c)).lo), 0, s - 1)), u ? o = Y(Math.max(ft(a, r.axis, h, !0).hi + 1, e ? 0 : ft(t, l, r.getPixelForValue(h), !0).hi + 1), n, s) - n : o = s - n;\n  }\n  return {\n    start: n,\n    count: o\n  };\n}\nfunction mn(i) {\n  var t = i.xScale,\n    e = i.yScale,\n    s = i._scaleRanges,\n    n = {\n      xmin: t.min,\n      xmax: t.max,\n      ymin: e.min,\n      ymax: e.max\n    };\n  if (!s) return i._scaleRanges = n, !0;\n  var o = s.xmin !== t.min || s.xmax !== t.max || s.ymin !== e.min || s.ymax !== e.max;\n  return Object.assign(s, n), o;\n}\nvar we = function we(i) {\n    return i === 0 || i === 1;\n  },\n  Ji = function Ji(i, t, e) {\n    return -(Math.pow(2, 10 * (i -= 1)) * Math.sin((i - t) * F / e));\n  },\n  Qi = function Qi(i, t, e) {\n    return Math.pow(2, -10 * i) * Math.sin((i - t) * F / e) + 1;\n  },\n  ee = {\n    linear: function linear(i) {\n      return i;\n    },\n    easeInQuad: function easeInQuad(i) {\n      return i * i;\n    },\n    easeOutQuad: function easeOutQuad(i) {\n      return -i * (i - 2);\n    },\n    easeInOutQuad: function easeInOutQuad(i) {\n      return (i /= 0.5) < 1 ? 0.5 * i * i : -0.5 * (--i * (i - 2) - 1);\n    },\n    easeInCubic: function easeInCubic(i) {\n      return i * i * i;\n    },\n    easeOutCubic: function easeOutCubic(i) {\n      return (i -= 1) * i * i + 1;\n    },\n    easeInOutCubic: function easeInOutCubic(i) {\n      return (i /= 0.5) < 1 ? 0.5 * i * i * i : 0.5 * ((i -= 2) * i * i + 2);\n    },\n    easeInQuart: function easeInQuart(i) {\n      return i * i * i * i;\n    },\n    easeOutQuart: function easeOutQuart(i) {\n      return -((i -= 1) * i * i * i - 1);\n    },\n    easeInOutQuart: function easeInOutQuart(i) {\n      return (i /= 0.5) < 1 ? 0.5 * i * i * i * i : -0.5 * ((i -= 2) * i * i * i - 2);\n    },\n    easeInQuint: function easeInQuint(i) {\n      return i * i * i * i * i;\n    },\n    easeOutQuint: function easeOutQuint(i) {\n      return (i -= 1) * i * i * i * i + 1;\n    },\n    easeInOutQuint: function easeInOutQuint(i) {\n      return (i /= 0.5) < 1 ? 0.5 * i * i * i * i * i : 0.5 * ((i -= 2) * i * i * i * i + 2);\n    },\n    easeInSine: function easeInSine(i) {\n      return -Math.cos(i * V) + 1;\n    },\n    easeOutSine: function easeOutSine(i) {\n      return Math.sin(i * V);\n    },\n    easeInOutSine: function easeInOutSine(i) {\n      return -0.5 * (Math.cos(B * i) - 1);\n    },\n    easeInExpo: function easeInExpo(i) {\n      return i === 0 ? 0 : Math.pow(2, 10 * (i - 1));\n    },\n    easeOutExpo: function easeOutExpo(i) {\n      return i === 1 ? 1 : -Math.pow(2, -10 * i) + 1;\n    },\n    easeInOutExpo: function easeInOutExpo(i) {\n      return we(i) ? i : i < 0.5 ? 0.5 * Math.pow(2, 10 * (i * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (i * 2 - 1)) + 2);\n    },\n    easeInCirc: function easeInCirc(i) {\n      return i >= 1 ? i : -(Math.sqrt(1 - i * i) - 1);\n    },\n    easeOutCirc: function easeOutCirc(i) {\n      return Math.sqrt(1 - (i -= 1) * i);\n    },\n    easeInOutCirc: function easeInOutCirc(i) {\n      return (i /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - i * i) - 1) : 0.5 * (Math.sqrt(1 - (i -= 2) * i) + 1);\n    },\n    easeInElastic: function easeInElastic(i) {\n      return we(i) ? i : Ji(i, 0.075, 0.3);\n    },\n    easeOutElastic: function easeOutElastic(i) {\n      return we(i) ? i : Qi(i, 0.075, 0.3);\n    },\n    easeInOutElastic: function easeInOutElastic(i) {\n      return we(i) ? i : i < 0.5 ? 0.5 * Ji(i * 2, 0.1125, 0.45) : 0.5 + 0.5 * Qi(i * 2 - 1, 0.1125, 0.45);\n    },\n    easeInBack: function easeInBack(i) {\n      return i * i * ((1.70158 + 1) * i - 1.70158);\n    },\n    easeOutBack: function easeOutBack(i) {\n      return (i -= 1) * i * ((1.70158 + 1) * i + 1.70158) + 1;\n    },\n    easeInOutBack: function easeInOutBack(i) {\n      var t = 1.70158;\n      return (i /= 0.5) < 1 ? 0.5 * (i * i * (((t *= 1.525) + 1) * i - t)) : 0.5 * ((i -= 2) * i * (((t *= 1.525) + 1) * i + t) + 2);\n    },\n    easeInBounce: function easeInBounce(i) {\n      return 1 - ee.easeOutBounce(1 - i);\n    },\n    easeOutBounce: function easeOutBounce(i) {\n      return i < 1 / 2.75 ? 7.5625 * i * i : i < 2 / 2.75 ? 7.5625 * (i -= 1.5 / 2.75) * i + 0.75 : i < 2.5 / 2.75 ? 7.5625 * (i -= 2.25 / 2.75) * i + 0.9375 : 7.5625 * (i -= 2.625 / 2.75) * i + 0.984375;\n    },\n    easeInOutBounce: function easeInOutBounce(i) {\n      return i < 0.5 ? ee.easeInBounce(i * 2) * 0.5 : ee.easeOutBounce(i * 2 - 1) * 0.5 + 0.5;\n    }\n  };\n/*!\n * @kurkle/color v0.2.1\n * https://github.com/kurkle/color#readme\n * (c) 2022 Jukka Kurkela\n * Released under the MIT License\n */\nfunction he(i) {\n  return i + 0.5 | 0;\n}\nvar mt = function mt(i, t, e) {\n  return Math.max(Math.min(i, e), t);\n};\nfunction Gt(i) {\n  return mt(he(i * 2.55), 0, 255);\n}\nfunction xt(i) {\n  return mt(he(i * 255), 0, 255);\n}\nfunction dt(i) {\n  return mt(he(i / 2.55) / 100, 0, 1);\n}\nfunction ts(i) {\n  return mt(he(i * 100), 0, 100);\n}\nvar J = {\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 3,\n    4: 4,\n    5: 5,\n    6: 6,\n    7: 7,\n    8: 8,\n    9: 9,\n    A: 10,\n    B: 11,\n    C: 12,\n    D: 13,\n    E: 14,\n    F: 15,\n    a: 10,\n    b: 11,\n    c: 12,\n    d: 13,\n    e: 14,\n    f: 15\n  },\n  xi = _toConsumableArray(\"0123456789ABCDEF\"),\n  zo = function zo(i) {\n    return xi[i & 15];\n  },\n  Bo = function Bo(i) {\n    return xi[(i & 240) >> 4] + xi[i & 15];\n  },\n  Se = function Se(i) {\n    return (i & 240) >> 4 === (i & 15);\n  },\n  Vo = function Vo(i) {\n    return Se(i.r) && Se(i.g) && Se(i.b) && Se(i.a);\n  };\nfunction Wo(i) {\n  var t = i.length,\n    e;\n  return i[0] === \"#\" && (t === 4 || t === 5 ? e = {\n    r: 255 & J[i[1]] * 17,\n    g: 255 & J[i[2]] * 17,\n    b: 255 & J[i[3]] * 17,\n    a: t === 5 ? J[i[4]] * 17 : 255\n  } : (t === 7 || t === 9) && (e = {\n    r: J[i[1]] << 4 | J[i[2]],\n    g: J[i[3]] << 4 | J[i[4]],\n    b: J[i[5]] << 4 | J[i[6]],\n    a: t === 9 ? J[i[7]] << 4 | J[i[8]] : 255\n  })), e;\n}\nvar No = function No(i, t) {\n  return i < 255 ? t(i) : \"\";\n};\nfunction Ho(i) {\n  var t = Vo(i) ? zo : Bo;\n  return i ? \"#\" + t(i.r) + t(i.g) + t(i.b) + No(i.a, t) : void 0;\n}\nvar jo = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction bn(i, t, e) {\n  var s = t * Math.min(e, 1 - e),\n    n = function n(o) {\n      var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (o + i / 30) % 12;\n      return e - s * Math.max(Math.min(r - 3, 9 - r, 1), -1);\n    };\n  return [n(0), n(8), n(4)];\n}\nfunction $o(i, t, e) {\n  var s = function s(n) {\n    var o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (n + i / 60) % 6;\n    return e - e * t * Math.max(Math.min(o, 4 - o, 1), 0);\n  };\n  return [s(5), s(3), s(1)];\n}\nfunction Yo(i, t, e) {\n  var s = bn(i, 1, 0.5);\n  var n;\n  for (t + e > 1 && (n = 1 / (t + e), t *= n, e *= n), n = 0; n < 3; n++) s[n] *= 1 - t - e, s[n] += t;\n  return s;\n}\nfunction Xo(i, t, e, s, n) {\n  return i === n ? (t - e) / s + (t < e ? 6 : 0) : t === n ? (e - i) / s + 2 : (i - t) / s + 4;\n}\nfunction Ri(i) {\n  var e = i.r / 255,\n    s = i.g / 255,\n    n = i.b / 255,\n    o = Math.max(e, s, n),\n    r = Math.min(e, s, n),\n    a = (o + r) / 2;\n  var l, c, h;\n  return o !== r && (h = o - r, c = a > 0.5 ? h / (2 - o - r) : h / (o + r), l = Xo(e, s, n, h, o), l = l * 60 + 0.5), [l | 0, c || 0, a];\n}\nfunction Ei(i, t, e, s) {\n  return (Array.isArray(t) ? i(t[0], t[1], t[2]) : i(t, e, s)).map(xt);\n}\nfunction Fi(i, t, e) {\n  return Ei(bn, i, t, e);\n}\nfunction Uo(i, t, e) {\n  return Ei(Yo, i, t, e);\n}\nfunction Ko(i, t, e) {\n  return Ei($o, i, t, e);\n}\nfunction xn(i) {\n  return (i % 360 + 360) % 360;\n}\nfunction qo(i) {\n  var t = jo.exec(i);\n  var e = 255,\n    s;\n  if (!t) return;\n  t[5] !== s && (e = t[6] ? Gt(+t[5]) : xt(+t[5]));\n  var n = xn(+t[2]),\n    o = +t[3] / 100,\n    r = +t[4] / 100;\n  return t[1] === \"hwb\" ? s = Uo(n, o, r) : t[1] === \"hsv\" ? s = Ko(n, o, r) : s = Fi(n, o, r), {\n    r: s[0],\n    g: s[1],\n    b: s[2],\n    a: e\n  };\n}\nfunction Go(i, t) {\n  var e = Ri(i);\n  e[0] = xn(e[0] + t), e = Fi(e), i.r = e[0], i.g = e[1], i.b = e[2];\n}\nfunction Zo(i) {\n  if (!i) return;\n  var t = Ri(i),\n    e = t[0],\n    s = ts(t[1]),\n    n = ts(t[2]);\n  return i.a < 255 ? \"hsla(\".concat(e, \", \").concat(s, \"%, \").concat(n, \"%, \").concat(dt(i.a), \")\") : \"hsl(\".concat(e, \", \").concat(s, \"%, \").concat(n, \"%)\");\n}\nvar es = {\n    x: \"dark\",\n    Z: \"light\",\n    Y: \"re\",\n    X: \"blu\",\n    W: \"gr\",\n    V: \"medium\",\n    U: \"slate\",\n    A: \"ee\",\n    T: \"ol\",\n    S: \"or\",\n    B: \"ra\",\n    C: \"lateg\",\n    D: \"ights\",\n    R: \"in\",\n    Q: \"turquois\",\n    E: \"hi\",\n    P: \"ro\",\n    O: \"al\",\n    N: \"le\",\n    M: \"de\",\n    L: \"yello\",\n    F: \"en\",\n    K: \"ch\",\n    G: \"arks\",\n    H: \"ea\",\n    I: \"ightg\",\n    J: \"wh\"\n  },\n  is = {\n    OiceXe: \"f0f8ff\",\n    antiquewEte: \"faebd7\",\n    aqua: \"ffff\",\n    aquamarRe: \"7fffd4\",\n    azuY: \"f0ffff\",\n    beige: \"f5f5dc\",\n    bisque: \"ffe4c4\",\n    black: \"0\",\n    blanKedOmond: \"ffebcd\",\n    Xe: \"ff\",\n    XeviTet: \"8a2be2\",\n    bPwn: \"a52a2a\",\n    burlywood: \"deb887\",\n    caMtXe: \"5f9ea0\",\n    KartYuse: \"7fff00\",\n    KocTate: \"d2691e\",\n    cSO: \"ff7f50\",\n    cSnflowerXe: \"6495ed\",\n    cSnsilk: \"fff8dc\",\n    crimson: \"dc143c\",\n    cyan: \"ffff\",\n    xXe: \"8b\",\n    xcyan: \"8b8b\",\n    xgTMnPd: \"b8860b\",\n    xWay: \"a9a9a9\",\n    xgYF: \"6400\",\n    xgYy: \"a9a9a9\",\n    xkhaki: \"bdb76b\",\n    xmagFta: \"8b008b\",\n    xTivegYF: \"556b2f\",\n    xSange: \"ff8c00\",\n    xScEd: \"9932cc\",\n    xYd: \"8b0000\",\n    xsOmon: \"e9967a\",\n    xsHgYF: \"8fbc8f\",\n    xUXe: \"483d8b\",\n    xUWay: \"2f4f4f\",\n    xUgYy: \"2f4f4f\",\n    xQe: \"ced1\",\n    xviTet: \"9400d3\",\n    dAppRk: \"ff1493\",\n    dApskyXe: \"bfff\",\n    dimWay: \"696969\",\n    dimgYy: \"696969\",\n    dodgerXe: \"1e90ff\",\n    fiYbrick: \"b22222\",\n    flSOwEte: \"fffaf0\",\n    foYstWAn: \"228b22\",\n    fuKsia: \"ff00ff\",\n    gaRsbSo: \"dcdcdc\",\n    ghostwEte: \"f8f8ff\",\n    gTd: \"ffd700\",\n    gTMnPd: \"daa520\",\n    Way: \"808080\",\n    gYF: \"8000\",\n    gYFLw: \"adff2f\",\n    gYy: \"808080\",\n    honeyMw: \"f0fff0\",\n    hotpRk: \"ff69b4\",\n    RdianYd: \"cd5c5c\",\n    Rdigo: \"4b0082\",\n    ivSy: \"fffff0\",\n    khaki: \"f0e68c\",\n    lavFMr: \"e6e6fa\",\n    lavFMrXsh: \"fff0f5\",\n    lawngYF: \"7cfc00\",\n    NmoncEffon: \"fffacd\",\n    ZXe: \"add8e6\",\n    ZcSO: \"f08080\",\n    Zcyan: \"e0ffff\",\n    ZgTMnPdLw: \"fafad2\",\n    ZWay: \"d3d3d3\",\n    ZgYF: \"90ee90\",\n    ZgYy: \"d3d3d3\",\n    ZpRk: \"ffb6c1\",\n    ZsOmon: \"ffa07a\",\n    ZsHgYF: \"20b2aa\",\n    ZskyXe: \"87cefa\",\n    ZUWay: \"778899\",\n    ZUgYy: \"778899\",\n    ZstAlXe: \"b0c4de\",\n    ZLw: \"ffffe0\",\n    lime: \"ff00\",\n    limegYF: \"32cd32\",\n    lRF: \"faf0e6\",\n    magFta: \"ff00ff\",\n    maPon: \"800000\",\n    VaquamarRe: \"66cdaa\",\n    VXe: \"cd\",\n    VScEd: \"ba55d3\",\n    VpurpN: \"9370db\",\n    VsHgYF: \"3cb371\",\n    VUXe: \"7b68ee\",\n    VsprRggYF: \"fa9a\",\n    VQe: \"48d1cc\",\n    VviTetYd: \"c71585\",\n    midnightXe: \"191970\",\n    mRtcYam: \"f5fffa\",\n    mistyPse: \"ffe4e1\",\n    moccasR: \"ffe4b5\",\n    navajowEte: \"ffdead\",\n    navy: \"80\",\n    Tdlace: \"fdf5e6\",\n    Tive: \"808000\",\n    TivedBb: \"6b8e23\",\n    Sange: \"ffa500\",\n    SangeYd: \"ff4500\",\n    ScEd: \"da70d6\",\n    pOegTMnPd: \"eee8aa\",\n    pOegYF: \"98fb98\",\n    pOeQe: \"afeeee\",\n    pOeviTetYd: \"db7093\",\n    papayawEp: \"ffefd5\",\n    pHKpuff: \"ffdab9\",\n    peru: \"cd853f\",\n    pRk: \"ffc0cb\",\n    plum: \"dda0dd\",\n    powMrXe: \"b0e0e6\",\n    purpN: \"800080\",\n    YbeccapurpN: \"663399\",\n    Yd: \"ff0000\",\n    Psybrown: \"bc8f8f\",\n    PyOXe: \"4169e1\",\n    saddNbPwn: \"8b4513\",\n    sOmon: \"fa8072\",\n    sandybPwn: \"f4a460\",\n    sHgYF: \"2e8b57\",\n    sHshell: \"fff5ee\",\n    siFna: \"a0522d\",\n    silver: \"c0c0c0\",\n    skyXe: \"87ceeb\",\n    UXe: \"6a5acd\",\n    UWay: \"708090\",\n    UgYy: \"708090\",\n    snow: \"fffafa\",\n    sprRggYF: \"ff7f\",\n    stAlXe: \"4682b4\",\n    tan: \"d2b48c\",\n    teO: \"8080\",\n    tEstN: \"d8bfd8\",\n    tomato: \"ff6347\",\n    Qe: \"40e0d0\",\n    viTet: \"ee82ee\",\n    JHt: \"f5deb3\",\n    wEte: \"ffffff\",\n    wEtesmoke: \"f5f5f5\",\n    Lw: \"ffff00\",\n    LwgYF: \"9acd32\"\n  };\nfunction Jo() {\n  var i = {},\n    t = Object.keys(is),\n    e = Object.keys(es);\n  var s, n, o, r, a;\n  for (s = 0; s < t.length; s++) {\n    for (r = a = t[s], n = 0; n < e.length; n++) o = e[n], a = a.replace(o, es[o]);\n    o = parseInt(is[r], 16), i[a] = [o >> 16 & 255, o >> 8 & 255, o & 255];\n  }\n  return i;\n}\nvar Pe;\nfunction Qo(i) {\n  Pe || (Pe = Jo(), Pe.transparent = [0, 0, 0, 0]);\n  var t = Pe[i.toLowerCase()];\n  return t && {\n    r: t[0],\n    g: t[1],\n    b: t[2],\n    a: t.length === 4 ? t[3] : 255\n  };\n}\nvar tr = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction er(i) {\n  var t = tr.exec(i);\n  var e = 255,\n    s,\n    n,\n    o;\n  if (t) {\n    if (t[7] !== s) {\n      var r = +t[7];\n      e = t[8] ? Gt(r) : mt(r * 255, 0, 255);\n    }\n    return s = +t[1], n = +t[3], o = +t[5], s = 255 & (t[2] ? Gt(s) : mt(s, 0, 255)), n = 255 & (t[4] ? Gt(n) : mt(n, 0, 255)), o = 255 & (t[6] ? Gt(o) : mt(o, 0, 255)), {\n      r: s,\n      g: n,\n      b: o,\n      a: e\n    };\n  }\n}\nfunction ir(i) {\n  return i && (i.a < 255 ? \"rgba(\".concat(i.r, \", \").concat(i.g, \", \").concat(i.b, \", \").concat(dt(i.a), \")\") : \"rgb(\".concat(i.r, \", \").concat(i.g, \", \").concat(i.b, \")\"));\n}\nvar ni = function ni(i) {\n    return i <= 31308e-7 ? i * 12.92 : Math.pow(i, 1 / 2.4) * 1.055 - 0.055;\n  },\n  Ft = function Ft(i) {\n    return i <= 0.04045 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4);\n  };\nfunction sr(i, t, e) {\n  var s = Ft(dt(i.r)),\n    n = Ft(dt(i.g)),\n    o = Ft(dt(i.b));\n  return {\n    r: xt(ni(s + e * (Ft(dt(t.r)) - s))),\n    g: xt(ni(n + e * (Ft(dt(t.g)) - n))),\n    b: xt(ni(o + e * (Ft(dt(t.b)) - o))),\n    a: i.a + e * (t.a - i.a)\n  };\n}\nfunction Ce(i, t, e) {\n  if (i) {\n    var s = Ri(i);\n    s[t] = Math.max(0, Math.min(s[t] + s[t] * e, t === 0 ? 360 : 1)), s = Fi(s), i.r = s[0], i.g = s[1], i.b = s[2];\n  }\n}\nfunction _n(i, t) {\n  return i && Object.assign(t || {}, i);\n}\nfunction ss(i) {\n  var t = {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 255\n  };\n  return Array.isArray(i) ? i.length >= 3 && (t = {\n    r: i[0],\n    g: i[1],\n    b: i[2],\n    a: 255\n  }, i.length > 3 && (t.a = xt(i[3]))) : (t = _n(i, {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 1\n  }), t.a = xt(t.a)), t;\n}\nfunction nr(i) {\n  return i.charAt(0) === \"r\" ? er(i) : qo(i);\n}\nvar We = /*#__PURE__*/function () {\n  function We(t) {\n    _classCallCheck(this, We);\n    if (t instanceof We) return t;\n    var e = typeof t;\n    var s;\n    e === \"object\" ? s = ss(t) : e === \"string\" && (s = Wo(t) || Qo(t) || nr(t)), this._rgb = s, this._valid = !!s;\n  }\n  _createClass(We, [{\n    key: \"valid\",\n    get: function get() {\n      return this._valid;\n    }\n  }, {\n    key: \"rgb\",\n    get: function get() {\n      var t = _n(this._rgb);\n      return t && (t.a = dt(t.a)), t;\n    },\n    set: function set(t) {\n      this._rgb = ss(t);\n    }\n  }, {\n    key: \"rgbString\",\n    value: function rgbString() {\n      return this._valid ? ir(this._rgb) : void 0;\n    }\n  }, {\n    key: \"hexString\",\n    value: function hexString() {\n      return this._valid ? Ho(this._rgb) : void 0;\n    }\n  }, {\n    key: \"hslString\",\n    value: function hslString() {\n      return this._valid ? Zo(this._rgb) : void 0;\n    }\n  }, {\n    key: \"mix\",\n    value: function mix(t, e) {\n      if (t) {\n        var s = this.rgb,\n          n = t.rgb;\n        var o;\n        var r = e === o ? 0.5 : e,\n          a = 2 * r - 1,\n          l = s.a - n.a,\n          c = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2;\n        o = 1 - c, s.r = 255 & c * s.r + o * n.r + 0.5, s.g = 255 & c * s.g + o * n.g + 0.5, s.b = 255 & c * s.b + o * n.b + 0.5, s.a = r * s.a + (1 - r) * n.a, this.rgb = s;\n      }\n      return this;\n    }\n  }, {\n    key: \"interpolate\",\n    value: function interpolate(t, e) {\n      return t && (this._rgb = sr(this._rgb, t._rgb, e)), this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new We(this.rgb);\n    }\n  }, {\n    key: \"alpha\",\n    value: function alpha(t) {\n      return this._rgb.a = xt(t), this;\n    }\n  }, {\n    key: \"clearer\",\n    value: function clearer(t) {\n      var e = this._rgb;\n      return e.a *= 1 - t, this;\n    }\n  }, {\n    key: \"greyscale\",\n    value: function greyscale() {\n      var t = this._rgb,\n        e = he(t.r * 0.3 + t.g * 0.59 + t.b * 0.11);\n      return t.r = t.g = t.b = e, this;\n    }\n  }, {\n    key: \"opaquer\",\n    value: function opaquer(t) {\n      var e = this._rgb;\n      return e.a *= 1 + t, this;\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      var t = this._rgb;\n      return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;\n    }\n  }, {\n    key: \"lighten\",\n    value: function lighten(t) {\n      return Ce(this._rgb, 2, t), this;\n    }\n  }, {\n    key: \"darken\",\n    value: function darken(t) {\n      return Ce(this._rgb, 2, -t), this;\n    }\n  }, {\n    key: \"saturate\",\n    value: function saturate(t) {\n      return Ce(this._rgb, 1, t), this;\n    }\n  }, {\n    key: \"desaturate\",\n    value: function desaturate(t) {\n      return Ce(this._rgb, 1, -t), this;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(t) {\n      return Go(this._rgb, t), this;\n    }\n  }]);\n  return We;\n}();\nfunction yn(i) {\n  return new We(i);\n}\nfunction vn(i) {\n  if (i && typeof i == \"object\") {\n    var t = i.toString();\n    return t === \"[object CanvasPattern]\" || t === \"[object CanvasGradient]\";\n  }\n  return !1;\n}\nfunction ns(i) {\n  return vn(i) ? i : yn(i);\n}\nfunction oi(i) {\n  return vn(i) ? i : yn(i).saturate(0.5).darken(0.1).hexString();\n}\nvar At = /* @__PURE__ */Object.create(null),\n  _i = /* @__PURE__ */Object.create(null);\nfunction ie(i, t) {\n  if (!t) return i;\n  var e = t.split(\".\");\n  for (var s = 0, n = e.length; s < n; ++s) {\n    var o = e[s];\n    i = i[o] || (i[o] = /* @__PURE__ */Object.create(null));\n  }\n  return i;\n}\nfunction ri(i, t, e) {\n  return typeof t == \"string\" ? ne(ie(i, t), e) : ne(ie(i, \"\"), t);\n}\nvar or = /*#__PURE__*/function () {\n  function or(t) {\n    _classCallCheck(this, or);\n    this.animation = void 0, this.backgroundColor = \"rgba(0,0,0,0.1)\", this.borderColor = \"rgba(0,0,0,0.1)\", this.color = \"#666\", this.datasets = {}, this.devicePixelRatio = function (e) {\n      return e.chart.platform.getDevicePixelRatio();\n    }, this.elements = {}, this.events = [\"mousemove\", \"mouseout\", \"click\", \"touchstart\", \"touchmove\"], this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: \"normal\",\n      lineHeight: 1.2,\n      weight: null\n    }, this.hover = {}, this.hoverBackgroundColor = function (e, s) {\n      return oi(s.backgroundColor);\n    }, this.hoverBorderColor = function (e, s) {\n      return oi(s.borderColor);\n    }, this.hoverColor = function (e, s) {\n      return oi(s.color);\n    }, this.indexAxis = \"x\", this.interaction = {\n      mode: \"nearest\",\n      intersect: !0,\n      includeInvisible: !1\n    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t);\n  }\n  _createClass(or, [{\n    key: \"set\",\n    value: function set(t, e) {\n      return ri(this, t, e);\n    }\n  }, {\n    key: \"get\",\n    value: function get(t) {\n      return ie(this, t);\n    }\n  }, {\n    key: \"describe\",\n    value: function describe(t, e) {\n      return ri(_i, t, e);\n    }\n  }, {\n    key: \"override\",\n    value: function override(t, e) {\n      return ri(At, t, e);\n    }\n  }, {\n    key: \"route\",\n    value: function route(t, e, s, n) {\n      var _Object$definePropert;\n      var o = ie(this, t),\n        r = ie(this, s),\n        a = \"_\" + e;\n      Object.defineProperties(o, (_Object$definePropert = {}, _defineProperty(_Object$definePropert, a, {\n        value: o[e],\n        writable: !0\n      }), _defineProperty(_Object$definePropert, e, {\n        enumerable: !0,\n        get: function get() {\n          var l = this[a],\n            c = r[n];\n          return D(l) ? Object.assign({}, c, l) : C(l, c);\n        },\n        set: function set(l) {\n          this[a] = l;\n        }\n      }), _Object$definePropert));\n    }\n  }]);\n  return or;\n}();\nvar O = new or({\n  _scriptable: function _scriptable(i) {\n    return !i.startsWith(\"on\");\n  },\n  _indexable: function _indexable(i) {\n    return i !== \"events\";\n  },\n  hover: {\n    _fallback: \"interaction\"\n  },\n  interaction: {\n    _scriptable: !1,\n    _indexable: !1\n  }\n});\nfunction rr(i) {\n  return !i || T(i.size) || T(i.family) ? null : (i.style ? i.style + \" \" : \"\") + (i.weight ? i.weight + \" \" : \"\") + i.size + \"px \" + i.family;\n}\nfunction Ne(i, t, e, s, n) {\n  var o = t[n];\n  return o || (o = t[n] = i.measureText(n).width, e.push(n)), o > s && (s = o), s;\n}\nfunction ar(i, t, e, s) {\n  s = s || {};\n  var n = s.data = s.data || {},\n    o = s.garbageCollect = s.garbageCollect || [];\n  s.font !== t && (n = s.data = {}, o = s.garbageCollect = [], s.font = t), i.save(), i.font = t;\n  var r = 0;\n  var a = e.length;\n  var l, c, h, d, u;\n  for (l = 0; l < a; l++) if (d = e[l], d != null && z(d) !== !0) r = Ne(i, n, o, r, d);else if (z(d)) for (c = 0, h = d.length; c < h; c++) u = d[c], u != null && !z(u) && (r = Ne(i, n, o, r, u));\n  i.restore();\n  var f = o.length / 2;\n  if (f > e.length) {\n    for (l = 0; l < f; l++) delete n[o[l]];\n    o.splice(0, f);\n  }\n  return r;\n}\nfunction wt(i, t, e) {\n  var s = i.currentDevicePixelRatio,\n    n = e !== 0 ? Math.max(e / 2, 0.5) : 0;\n  return Math.round((t - n) * s) / s + n;\n}\nfunction os(i, t) {\n  t = t || i.getContext(\"2d\"), t.save(), t.resetTransform(), t.clearRect(0, 0, i.width, i.height), t.restore();\n}\nfunction yi(i, t, e, s) {\n  Mn(i, t, e, s, null);\n}\nfunction Mn(i, t, e, s, n) {\n  var o, r, a, l, c, h;\n  var d = t.pointStyle,\n    u = t.rotation,\n    f = t.radius;\n  var g = (u || 0) * Co;\n  if (d && typeof d == \"object\" && (o = d.toString(), o === \"[object HTMLImageElement]\" || o === \"[object HTMLCanvasElement]\")) {\n    i.save(), i.translate(e, s), i.rotate(g), i.drawImage(d, -d.width / 2, -d.height / 2, d.width, d.height), i.restore();\n    return;\n  }\n  if (!(isNaN(f) || f <= 0)) {\n    switch (i.beginPath(), d) {\n      default:\n        n ? i.ellipse(e, s, n / 2, f, 0, 0, F) : i.arc(e, s, f, 0, F), i.closePath();\n        break;\n      case \"triangle\":\n        i.moveTo(e + Math.sin(g) * f, s - Math.cos(g) * f), g += Ki, i.lineTo(e + Math.sin(g) * f, s - Math.cos(g) * f), g += Ki, i.lineTo(e + Math.sin(g) * f, s - Math.cos(g) * f), i.closePath();\n        break;\n      case \"rectRounded\":\n        c = f * 0.516, l = f - c, r = Math.cos(g + $t) * l, a = Math.sin(g + $t) * l, i.arc(e - r, s - a, c, g - B, g - V), i.arc(e + a, s - r, c, g - V, g), i.arc(e + r, s + a, c, g, g + V), i.arc(e - a, s + r, c, g + V, g + B), i.closePath();\n        break;\n      case \"rect\":\n        if (!u) {\n          l = Math.SQRT1_2 * f, h = n ? n / 2 : l, i.rect(e - h, s - l, 2 * h, 2 * l);\n          break;\n        }\n        g += $t;\n      case \"rectRot\":\n        r = Math.cos(g) * f, a = Math.sin(g) * f, i.moveTo(e - r, s - a), i.lineTo(e + a, s - r), i.lineTo(e + r, s + a), i.lineTo(e - a, s + r), i.closePath();\n        break;\n      case \"crossRot\":\n        g += $t;\n      case \"cross\":\n        r = Math.cos(g) * f, a = Math.sin(g) * f, i.moveTo(e - r, s - a), i.lineTo(e + r, s + a), i.moveTo(e + a, s - r), i.lineTo(e - a, s + r);\n        break;\n      case \"star\":\n        r = Math.cos(g) * f, a = Math.sin(g) * f, i.moveTo(e - r, s - a), i.lineTo(e + r, s + a), i.moveTo(e + a, s - r), i.lineTo(e - a, s + r), g += $t, r = Math.cos(g) * f, a = Math.sin(g) * f, i.moveTo(e - r, s - a), i.lineTo(e + r, s + a), i.moveTo(e + a, s - r), i.lineTo(e - a, s + r);\n        break;\n      case \"line\":\n        r = n ? n / 2 : Math.cos(g) * f, a = Math.sin(g) * f, i.moveTo(e - r, s - a), i.lineTo(e + r, s + a);\n        break;\n      case \"dash\":\n        i.moveTo(e, s), i.lineTo(e + Math.cos(g) * f, s + Math.sin(g) * f);\n        break;\n    }\n    i.fill(), t.borderWidth > 0 && i.stroke();\n  }\n}\nfunction re(i, t, e) {\n  return e = e || 0.5, !t || i && i.x > t.left - e && i.x < t.right + e && i.y > t.top - e && i.y < t.bottom + e;\n}\nfunction Xe(i, t) {\n  i.save(), i.beginPath(), i.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), i.clip();\n}\nfunction Ue(i) {\n  i.restore();\n}\nfunction lr(i, t, e, s, n) {\n  if (!t) return i.lineTo(e.x, e.y);\n  if (n === \"middle\") {\n    var o = (t.x + e.x) / 2;\n    i.lineTo(o, t.y), i.lineTo(o, e.y);\n  } else n === \"after\" != !!s ? i.lineTo(t.x, e.y) : i.lineTo(e.x, t.y);\n  i.lineTo(e.x, e.y);\n}\nfunction cr(i, t, e, s) {\n  if (!t) return i.lineTo(e.x, e.y);\n  i.bezierCurveTo(s ? t.cp1x : t.cp2x, s ? t.cp1y : t.cp2y, s ? e.cp2x : e.cp1x, s ? e.cp2y : e.cp1y, e.x, e.y);\n}\nfunction Tt(i, t, e, s, n) {\n  var o = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n  var r = z(t) ? t : [t],\n    a = o.strokeWidth > 0 && o.strokeColor !== \"\";\n  var l, c;\n  for (i.save(), i.font = n.string, hr(i, o), l = 0; l < r.length; ++l) c = r[l], a && (o.strokeColor && (i.strokeStyle = o.strokeColor), T(o.strokeWidth) || (i.lineWidth = o.strokeWidth), i.strokeText(c, e, s, o.maxWidth)), i.fillText(c, e, s, o.maxWidth), dr(i, e, s, c, o), s += n.lineHeight;\n  i.restore();\n}\nfunction hr(i, t) {\n  t.translation && i.translate(t.translation[0], t.translation[1]), T(t.rotation) || i.rotate(t.rotation), t.color && (i.fillStyle = t.color), t.textAlign && (i.textAlign = t.textAlign), t.textBaseline && (i.textBaseline = t.textBaseline);\n}\nfunction dr(i, t, e, s, n) {\n  if (n.strikethrough || n.underline) {\n    var o = i.measureText(s),\n      r = t - o.actualBoundingBoxLeft,\n      a = t + o.actualBoundingBoxRight,\n      l = e - o.actualBoundingBoxAscent,\n      c = e + o.actualBoundingBoxDescent,\n      h = n.strikethrough ? (l + c) / 2 : c;\n    i.strokeStyle = i.fillStyle, i.beginPath(), i.lineWidth = n.decorationWidth || 2, i.moveTo(r, h), i.lineTo(a, h), i.stroke();\n  }\n}\nfunction ae(i, t) {\n  var e = t.x,\n    s = t.y,\n    n = t.w,\n    o = t.h,\n    r = t.radius;\n  i.arc(e + r.topLeft, s + r.topLeft, r.topLeft, -V, B, !0), i.lineTo(e, s + o - r.bottomLeft), i.arc(e + r.bottomLeft, s + o - r.bottomLeft, r.bottomLeft, B, V, !0), i.lineTo(e + n - r.bottomRight, s + o), i.arc(e + n - r.bottomRight, s + o - r.bottomRight, r.bottomRight, V, 0, !0), i.lineTo(e + n, s + r.topRight), i.arc(e + n - r.topRight, s + r.topRight, r.topRight, 0, -V, !0), i.lineTo(e + r.topLeft, s);\n}\nvar ur = new RegExp(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/),\n  fr = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);\nfunction gr(i, t) {\n  var e = (\"\" + i).match(ur);\n  if (!e || e[1] === \"normal\") return t * 1.2;\n  switch (i = +e[2], e[3]) {\n    case \"px\":\n      return i;\n    case \"%\":\n      i /= 100;\n      break;\n  }\n  return t * i;\n}\nvar pr = function pr(i) {\n  return +i || 0;\n};\nfunction Ii(i, t) {\n  var e = {},\n    s = D(t),\n    n = s ? Object.keys(t) : t,\n    o = D(i) ? s ? function (r) {\n      return C(i[r], i[t[r]]);\n    } : function (r) {\n      return i[r];\n    } : function () {\n      return i;\n    };\n  var _iterator4 = _createForOfIteratorHelper(n),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var r = _step4.value;\n      e[r] = pr(o(r));\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return e;\n}\nfunction kn(i) {\n  return Ii(i, {\n    top: \"y\",\n    right: \"x\",\n    bottom: \"y\",\n    left: \"x\"\n  });\n}\nfunction Dt(i) {\n  return Ii(i, [\"topLeft\", \"topRight\", \"bottomLeft\", \"bottomRight\"]);\n}\nfunction K(i) {\n  var t = kn(i);\n  return t.width = t.left + t.right, t.height = t.top + t.bottom, t;\n}\nfunction $(i, t) {\n  i = i || {}, t = t || O.font;\n  var e = C(i.size, t.size);\n  typeof e == \"string\" && (e = parseInt(e, 10));\n  var s = C(i.style, t.style);\n  s && !(\"\" + s).match(fr) && (console.warn('Invalid font style specified: \"' + s + '\"'), s = \"\");\n  var n = {\n    family: C(i.family, t.family),\n    lineHeight: gr(C(i.lineHeight, t.lineHeight), e),\n    size: e,\n    style: s,\n    weight: C(i.weight, t.weight),\n    string: \"\"\n  };\n  return n.string = rr(n), n;\n}\nfunction Zt(i, t, e, s) {\n  var n = !0,\n    o,\n    r,\n    a;\n  for (o = 0, r = i.length; o < r; ++o) if (a = i[o], a !== void 0 && (t !== void 0 && typeof a == \"function\" && (a = a(t), n = !1), e !== void 0 && z(a) && (a = a[e % a.length], n = !1), a !== void 0)) return s && !n && (s.cacheable = !1), a;\n}\nfunction mr(i, t, e) {\n  var s = i.min,\n    n = i.max,\n    o = an(t, (n - s) / 2),\n    r = function r(a, l) {\n      return e && a === 0 ? 0 : a + l;\n    };\n  return {\n    min: r(s, -Math.abs(o)),\n    max: r(n, o)\n  };\n}\nfunction vt(i, t) {\n  return Object.assign(Object.create(i), t);\n}\nfunction zi(i) {\n  var _o2;\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [\"\"];\n  var e = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : i;\n  var s = arguments.length > 3 ? arguments[3] : undefined;\n  var n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {\n    return i[0];\n  };\n  et(s) || (s = Cn(\"_fallback\", i));\n  var o = (_o2 = {}, _defineProperty(_o2, Symbol.toStringTag, \"Object\"), _defineProperty(_o2, \"_cacheable\", !0), _defineProperty(_o2, \"_scopes\", i), _defineProperty(_o2, \"_rootScopes\", e), _defineProperty(_o2, \"_fallback\", s), _defineProperty(_o2, \"_getTarget\", n), _defineProperty(_o2, \"override\", function override(r) {\n    return zi([r].concat(_toConsumableArray(i)), t, e, s);\n  }), _o2);\n  return new Proxy(o, {\n    deleteProperty: function deleteProperty(r, a) {\n      return delete r[a], delete r._keys, delete i[0][a], !0;\n    },\n    get: function get(r, a) {\n      return Sn(r, a, function () {\n        return wr(a, t, i, r);\n      });\n    },\n    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(r, a) {\n      return Reflect.getOwnPropertyDescriptor(r._scopes[0], a);\n    },\n    getPrototypeOf: function getPrototypeOf() {\n      return Reflect.getPrototypeOf(i[0]);\n    },\n    has: function has(r, a) {\n      return as(r).includes(a);\n    },\n    ownKeys: function ownKeys(r) {\n      return as(r);\n    },\n    set: function set(r, a, l) {\n      var c = r._storage || (r._storage = n());\n      return r[a] = c[a] = l, delete r._keys, !0;\n    }\n  });\n}\nfunction Vt(i, t, e, s) {\n  var n = {\n    _cacheable: !1,\n    _proxy: i,\n    _context: t,\n    _subProxy: e,\n    _stack: /* @__PURE__ */new Set(),\n    _descriptors: wn(i, s),\n    setContext: function setContext(o) {\n      return Vt(i, o, e, s);\n    },\n    override: function override(o) {\n      return Vt(i.override(o), t, e, s);\n    }\n  };\n  return new Proxy(n, {\n    deleteProperty: function deleteProperty(o, r) {\n      return delete o[r], delete i[r], !0;\n    },\n    get: function get(o, r, a) {\n      return Sn(o, r, function () {\n        return xr(o, r, a);\n      });\n    },\n    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(o, r) {\n      return o._descriptors.allKeys ? Reflect.has(i, r) ? {\n        enumerable: !0,\n        configurable: !0\n      } : void 0 : Reflect.getOwnPropertyDescriptor(i, r);\n    },\n    getPrototypeOf: function getPrototypeOf() {\n      return Reflect.getPrototypeOf(i);\n    },\n    has: function has(o, r) {\n      return Reflect.has(i, r);\n    },\n    ownKeys: function ownKeys() {\n      return Reflect.ownKeys(i);\n    },\n    set: function set(o, r, a) {\n      return i[r] = a, delete o[r], !0;\n    }\n  });\n}\nfunction wn(i) {\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    scriptable: !0,\n    indexable: !0\n  };\n  var _i$_scriptable = i._scriptable,\n    e = _i$_scriptable === void 0 ? t.scriptable : _i$_scriptable,\n    _i$_indexable = i._indexable,\n    s = _i$_indexable === void 0 ? t.indexable : _i$_indexable,\n    _i$_allKeys = i._allKeys,\n    n = _i$_allKeys === void 0 ? t.allKeys : _i$_allKeys;\n  return {\n    allKeys: n,\n    scriptable: e,\n    indexable: s,\n    isScriptable: yt(e) ? e : function () {\n      return e;\n    },\n    isIndexable: yt(s) ? s : function () {\n      return s;\n    }\n  };\n}\nvar br = function br(i, t) {\n    return i ? i + Oi(t) : t;\n  },\n  Bi = function Bi(i, t) {\n    return D(t) && i !== \"adapters\" && (Object.getPrototypeOf(t) === null || t.constructor === Object);\n  };\nfunction Sn(i, t, e) {\n  if (Object.prototype.hasOwnProperty.call(i, t)) return i[t];\n  var s = e();\n  return i[t] = s, s;\n}\nfunction xr(i, t, e) {\n  var s = i._proxy,\n    n = i._context,\n    o = i._subProxy,\n    r = i._descriptors;\n  var a = s[t];\n  return yt(a) && r.isScriptable(t) && (a = _r(t, a, i, e)), z(a) && a.length && (a = yr(t, a, i, r.isIndexable)), Bi(t, a) && (a = Vt(a, n, o && o[t], r)), a;\n}\nfunction _r(i, t, e, s) {\n  var n = e._proxy,\n    o = e._context,\n    r = e._subProxy,\n    a = e._stack;\n  if (a.has(i)) throw new Error(\"Recursion detected: \" + Array.from(a).join(\"->\") + \"->\" + i);\n  return a.add(i), t = t(o, r || s), a.delete(i), Bi(i, t) && (t = Vi(n._scopes, n, i, t)), t;\n}\nfunction yr(i, t, e, s) {\n  var n = e._proxy,\n    o = e._context,\n    r = e._subProxy,\n    a = e._descriptors;\n  if (et(o.index) && s(i)) t = t[o.index % t.length];else if (D(t[0])) {\n    var l = t,\n      c = n._scopes.filter(function (h) {\n        return h !== l;\n      });\n    t = [];\n    var _iterator5 = _createForOfIteratorHelper(l),\n      _step5;\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var h = _step5.value;\n        var d = Vi(c, n, i, h);\n        t.push(Vt(d, o, r && r[i], a));\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n  }\n  return t;\n}\nfunction Pn(i, t, e) {\n  return yt(i) ? i(t, e) : i;\n}\nvar vr = function vr(i, t) {\n  return i === !0 ? t : typeof i == \"string\" ? _t(t, i) : void 0;\n};\nfunction Mr(i, t, e, s, n) {\n  var _iterator6 = _createForOfIteratorHelper(t),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var o = _step6.value;\n      var r = vr(e, o);\n      if (r) {\n        i.add(r);\n        var a = Pn(r._fallback, e, n);\n        if (et(a) && a !== e && a !== s) return a;\n      } else if (r === !1 && et(s) && e !== s) return null;\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  return !1;\n}\nfunction Vi(i, t, e, s) {\n  var n = t._rootScopes,\n    o = Pn(t._fallback, e, s),\n    r = [].concat(_toConsumableArray(i), _toConsumableArray(n)),\n    a = /* @__PURE__ */new Set();\n  a.add(s);\n  var l = rs(a, r, e, o || e, s);\n  return l === null || et(o) && o !== e && (l = rs(a, r, o, l, s), l === null) ? !1 : zi(Array.from(a), [\"\"], n, o, function () {\n    return kr(t, e, s);\n  });\n}\nfunction rs(i, t, e, s, n) {\n  for (; e;) e = Mr(i, t, e, s, n);\n  return e;\n}\nfunction kr(i, t, e) {\n  var s = i._getTarget();\n  t in s || (s[t] = {});\n  var n = s[t];\n  return z(n) && D(e) ? e : n;\n}\nfunction wr(i, t, e, s) {\n  var n;\n  var _iterator7 = _createForOfIteratorHelper(t),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var o = _step7.value;\n      if (n = Cn(br(o, i), e), et(n)) return Bi(i, n) ? Vi(e, s, i, n) : n;\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n}\nfunction Cn(i, t) {\n  var _iterator8 = _createForOfIteratorHelper(t),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var e = _step8.value;\n      if (!e) continue;\n      var s = e[i];\n      if (et(s)) return s;\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n}\nfunction as(i) {\n  var t = i._keys;\n  return t || (t = i._keys = Sr(i._scopes)), t;\n}\nfunction Sr(i) {\n  var t = /* @__PURE__ */new Set();\n  var _iterator9 = _createForOfIteratorHelper(i),\n    _step9;\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var e = _step9.value;\n      var _iterator10 = _createForOfIteratorHelper(Object.keys(e).filter(function (n) {\n          return !n.startsWith(\"_\");\n        })),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var s = _step10.value;\n          t.add(s);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n  return Array.from(t);\n}\nfunction Dn(i, t, e, s) {\n  var n = i.iScale,\n    _this$_parsing$key = this._parsing.key,\n    o = _this$_parsing$key === void 0 ? \"r\" : _this$_parsing$key,\n    r = new Array(s);\n  var a, l, c, h;\n  for (a = 0, l = s; a < l; ++a) c = a + e, h = t[c], r[a] = {\n    r: n.parse(_t(h, o), c)\n  };\n  return r;\n}\nvar Pr = Number.EPSILON || 1e-14,\n  Wt = function Wt(i, t) {\n    return t < i.length && !i[t].skip && i[t];\n  },\n  On = function On(i) {\n    return i === \"x\" ? \"y\" : \"x\";\n  };\nfunction Cr(i, t, e, s) {\n  var n = i.skip ? t : i,\n    o = t,\n    r = e.skip ? t : e,\n    a = bi(o, n),\n    l = bi(r, o);\n  var c = a / (a + l),\n    h = l / (a + l);\n  c = isNaN(c) ? 0 : c, h = isNaN(h) ? 0 : h;\n  var d = s * c,\n    u = s * h;\n  return {\n    previous: {\n      x: o.x - d * (r.x - n.x),\n      y: o.y - d * (r.y - n.y)\n    },\n    next: {\n      x: o.x + u * (r.x - n.x),\n      y: o.y + u * (r.y - n.y)\n    }\n  };\n}\nfunction Dr(i, t, e) {\n  var s = i.length;\n  var n,\n    o,\n    r,\n    a,\n    l,\n    c = Wt(i, 0);\n  for (var h = 0; h < s - 1; ++h) if (l = c, c = Wt(i, h + 1), !(!l || !c)) {\n    if (te(t[h], 0, Pr)) {\n      e[h] = e[h + 1] = 0;\n      continue;\n    }\n    n = e[h] / t[h], o = e[h + 1] / t[h], a = Math.pow(n, 2) + Math.pow(o, 2), !(a <= 9) && (r = 3 / Math.sqrt(a), e[h] = n * r * t[h], e[h + 1] = o * r * t[h]);\n  }\n}\nfunction Or(i, t) {\n  var e = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"x\";\n  var s = On(e),\n    n = i.length;\n  var o,\n    r,\n    a,\n    l = Wt(i, 0);\n  for (var c = 0; c < n; ++c) {\n    if (r = a, a = l, l = Wt(i, c + 1), !a) continue;\n    var h = a[e],\n      d = a[s];\n    r && (o = (h - r[e]) / 3, a[\"cp1\".concat(e)] = h - o, a[\"cp1\".concat(s)] = d - o * t[c]), l && (o = (l[e] - h) / 3, a[\"cp2\".concat(e)] = h + o, a[\"cp2\".concat(s)] = d + o * t[c]);\n  }\n}\nfunction Ar(i) {\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"x\";\n  var e = On(t),\n    s = i.length,\n    n = Array(s).fill(0),\n    o = Array(s);\n  var r,\n    a,\n    l,\n    c = Wt(i, 0);\n  for (r = 0; r < s; ++r) if (a = l, l = c, c = Wt(i, r + 1), !!l) {\n    if (c) {\n      var h = c[t] - l[t];\n      n[r] = h !== 0 ? (c[e] - l[e]) / h : 0;\n    }\n    o[r] = a ? c ? lt(n[r - 1]) !== lt(n[r]) ? 0 : (n[r - 1] + n[r]) / 2 : n[r - 1] : n[r];\n  }\n  Dr(i, n, o), Or(i, o, t);\n}\nfunction De(i, t, e) {\n  return Math.max(Math.min(i, e), t);\n}\nfunction Tr(i, t) {\n  var e,\n    s,\n    n,\n    o,\n    r,\n    a = re(i[0], t);\n  for (e = 0, s = i.length; e < s; ++e) r = o, o = a, a = e < s - 1 && re(i[e + 1], t), o && (n = i[e], r && (n.cp1x = De(n.cp1x, t.left, t.right), n.cp1y = De(n.cp1y, t.top, t.bottom)), a && (n.cp2x = De(n.cp2x, t.left, t.right), n.cp2y = De(n.cp2y, t.top, t.bottom)));\n}\nfunction Lr(i, t, e, s, n) {\n  var o, r, a, l;\n  if (t.spanGaps && (i = i.filter(function (c) {\n    return !c.skip;\n  })), t.cubicInterpolationMode === \"monotone\") Ar(i, n);else {\n    var c = s ? i[i.length - 1] : i[0];\n    for (o = 0, r = i.length; o < r; ++o) a = i[o], l = Cr(c, a, i[Math.min(o + 1, r - (s ? 0 : 1)) % r], t.tension), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, c = a;\n  }\n  t.capBezierPoints && Tr(i, e);\n}\nfunction An() {\n  return typeof window < \"u\" && typeof document < \"u\";\n}\nfunction Wi(i) {\n  var t = i.parentNode;\n  return t && t.toString() === \"[object ShadowRoot]\" && (t = t.host), t;\n}\nfunction He(i, t, e) {\n  var s;\n  return typeof i == \"string\" ? (s = parseInt(i, 10), i.indexOf(\"%\") !== -1 && (s = s / 100 * t.parentNode[e])) : s = i, s;\n}\nvar Ke = function Ke(i) {\n  return window.getComputedStyle(i, null);\n};\nfunction Rr(i, t) {\n  return Ke(i).getPropertyValue(t);\n}\nvar Er = [\"top\", \"right\", \"bottom\", \"left\"];\nfunction Ot(i, t, e) {\n  var s = {};\n  e = e ? \"-\" + e : \"\";\n  for (var n = 0; n < 4; n++) {\n    var o = Er[n];\n    s[o] = parseFloat(i[t + \"-\" + o + e]) || 0;\n  }\n  return s.width = s.left + s.right, s.height = s.top + s.bottom, s;\n}\nvar Fr = function Fr(i, t, e) {\n  return (i > 0 || t > 0) && (!e || !e.shadowRoot);\n};\nfunction Ir(i, t) {\n  var e = i.touches,\n    s = e && e.length ? e[0] : i,\n    n = s.offsetX,\n    o = s.offsetY;\n  var r = !1,\n    a,\n    l;\n  if (Fr(n, o, i.target)) a = n, l = o;else {\n    var c = t.getBoundingClientRect();\n    a = s.clientX - c.left, l = s.clientY - c.top, r = !0;\n  }\n  return {\n    x: a,\n    y: l,\n    box: r\n  };\n}\nfunction Pt(i, t) {\n  if (\"native\" in i) return i;\n  var e = t.canvas,\n    s = t.currentDevicePixelRatio,\n    n = Ke(e),\n    o = n.boxSizing === \"border-box\",\n    r = Ot(n, \"padding\"),\n    a = Ot(n, \"border\", \"width\"),\n    _Ir = Ir(i, e),\n    l = _Ir.x,\n    c = _Ir.y,\n    h = _Ir.box,\n    d = r.left + (h && a.left),\n    u = r.top + (h && a.top);\n  var f = t.width,\n    g = t.height;\n  return o && (f -= r.width + a.width, g -= r.height + a.height), {\n    x: Math.round((l - d) / f * e.width / s),\n    y: Math.round((c - u) / g * e.height / s)\n  };\n}\nfunction zr(i, t, e) {\n  var s, n;\n  if (t === void 0 || e === void 0) {\n    var o = Wi(i);\n    if (!o) t = i.clientWidth, e = i.clientHeight;else {\n      var r = o.getBoundingClientRect(),\n        a = Ke(o),\n        l = Ot(a, \"border\", \"width\"),\n        c = Ot(a, \"padding\");\n      t = r.width - c.width - l.width, e = r.height - c.height - l.height, s = He(a.maxWidth, o, \"clientWidth\"), n = He(a.maxHeight, o, \"clientHeight\");\n    }\n  }\n  return {\n    width: t,\n    height: e,\n    maxWidth: s || Ve,\n    maxHeight: n || Ve\n  };\n}\nvar ai = function ai(i) {\n  return Math.round(i * 10) / 10;\n};\nfunction Br(i, t, e, s) {\n  var n = Ke(i),\n    o = Ot(n, \"margin\"),\n    r = He(n.maxWidth, i, \"clientWidth\") || Ve,\n    a = He(n.maxHeight, i, \"clientHeight\") || Ve,\n    l = zr(i, t, e);\n  var c = l.width,\n    h = l.height;\n  if (n.boxSizing === \"content-box\") {\n    var d = Ot(n, \"border\", \"width\"),\n      u = Ot(n, \"padding\");\n    c -= u.width + d.width, h -= u.height + d.height;\n  }\n  return c = Math.max(0, c - o.width), h = Math.max(0, s ? Math.floor(c / s) : h - o.height), c = ai(Math.min(c, r, l.maxWidth)), h = ai(Math.min(h, a, l.maxHeight)), c && !h && (h = ai(c / 2)), {\n    width: c,\n    height: h\n  };\n}\nfunction ls(i, t, e) {\n  var s = t || 1,\n    n = Math.floor(i.height * s),\n    o = Math.floor(i.width * s);\n  i.height = n / s, i.width = o / s;\n  var r = i.canvas;\n  return r.style && (e || !r.style.height && !r.style.width) && (r.style.height = \"\".concat(i.height, \"px\"), r.style.width = \"\".concat(i.width, \"px\")), i.currentDevicePixelRatio !== s || r.height !== n || r.width !== o ? (i.currentDevicePixelRatio = s, r.height = n, r.width = o, i.ctx.setTransform(s, 0, 0, s, 0, 0), !0) : !1;\n}\nvar Vr = function () {\n  var i = !1;\n  try {\n    var t = {\n      get passive() {\n        return i = !0, !1;\n      }\n    };\n    window.addEventListener(\"test\", null, t), window.removeEventListener(\"test\", null, t);\n  } catch (_unused) {}\n  return i;\n}();\nfunction cs(i, t) {\n  var e = Rr(i, t),\n    s = e && e.match(/^(\\d+)(\\.\\d+)?px$/);\n  return s ? +s[1] : void 0;\n}\nfunction Ct(i, t, e, s) {\n  return {\n    x: i.x + e * (t.x - i.x),\n    y: i.y + e * (t.y - i.y)\n  };\n}\nfunction Wr(i, t, e, s) {\n  return {\n    x: i.x + e * (t.x - i.x),\n    y: s === \"middle\" ? e < 0.5 ? i.y : t.y : s === \"after\" ? e < 1 ? i.y : t.y : e > 0 ? t.y : i.y\n  };\n}\nfunction Nr(i, t, e, s) {\n  var n = {\n      x: i.cp2x,\n      y: i.cp2y\n    },\n    o = {\n      x: t.cp1x,\n      y: t.cp1y\n    },\n    r = Ct(i, n, e),\n    a = Ct(n, o, e),\n    l = Ct(o, t, e),\n    c = Ct(r, a, e),\n    h = Ct(a, l, e);\n  return Ct(c, h, e);\n}\nvar hs = /* @__PURE__ */new Map();\nfunction Hr(i, t) {\n  t = t || {};\n  var e = i + JSON.stringify(t);\n  var s = hs.get(e);\n  return s || (s = new Intl.NumberFormat(i, t), hs.set(e, s)), s;\n}\nfunction de(i, t, e) {\n  return Hr(t, e).format(i);\n}\nvar jr = function jr(i, t) {\n    return {\n      x: function x(e) {\n        return i + i + t - e;\n      },\n      setWidth: function setWidth(e) {\n        t = e;\n      },\n      textAlign: function textAlign(e) {\n        return e === \"center\" ? e : e === \"right\" ? \"left\" : \"right\";\n      },\n      xPlus: function xPlus(e, s) {\n        return e - s;\n      },\n      leftForLtr: function leftForLtr(e, s) {\n        return e - s;\n      }\n    };\n  },\n  $r = function $r() {\n    return {\n      x: function x(i) {\n        return i;\n      },\n      setWidth: function setWidth(i) {},\n      textAlign: function textAlign(i) {\n        return i;\n      },\n      xPlus: function xPlus(i, t) {\n        return i + t;\n      },\n      leftForLtr: function leftForLtr(i, t) {\n        return i;\n      }\n    };\n  };\nfunction zt(i, t, e) {\n  return i ? jr(t, e) : $r();\n}\nfunction Tn(i, t) {\n  var e, s;\n  (t === \"ltr\" || t === \"rtl\") && (e = i.canvas.style, s = [e.getPropertyValue(\"direction\"), e.getPropertyPriority(\"direction\")], e.setProperty(\"direction\", t, \"important\"), i.prevTextDirection = s);\n}\nfunction Ln(i, t) {\n  t !== void 0 && (delete i.prevTextDirection, i.canvas.style.setProperty(\"direction\", t[0], t[1]));\n}\nfunction Rn(i) {\n  return i === \"angle\" ? {\n    between: oe,\n    compare: Ao,\n    normalize: Z\n  } : {\n    between: ut,\n    compare: function compare(t, e) {\n      return t - e;\n    },\n    normalize: function normalize(t) {\n      return t;\n    }\n  };\n}\nfunction ds(_ref) {\n  var i = _ref.start,\n    t = _ref.end,\n    e = _ref.count,\n    s = _ref.loop,\n    n = _ref.style;\n  return {\n    start: i % e,\n    end: t % e,\n    loop: s && (t - i + 1) % e === 0,\n    style: n\n  };\n}\nfunction Yr(i, t, e) {\n  var s = e.property,\n    n = e.start,\n    o = e.end,\n    _Rn = Rn(s),\n    r = _Rn.between,\n    a = _Rn.normalize,\n    l = t.length;\n  var c = i.start,\n    h = i.end,\n    d = i.loop,\n    u,\n    f;\n  if (d) {\n    for (c += l, h += l, u = 0, f = l; u < f && r(a(t[c % l][s]), n, o); ++u) c--, h--;\n    c %= l, h %= l;\n  }\n  return h < c && (h += l), {\n    start: c,\n    end: h,\n    loop: d,\n    style: i.style\n  };\n}\nfunction En(i, t, e) {\n  if (!e) return [i];\n  var s = e.property,\n    n = e.start,\n    o = e.end,\n    r = t.length,\n    _Rn2 = Rn(s),\n    a = _Rn2.compare,\n    l = _Rn2.between,\n    c = _Rn2.normalize,\n    _Yr = Yr(i, t, e),\n    h = _Yr.start,\n    d = _Yr.end,\n    u = _Yr.loop,\n    f = _Yr.style,\n    g = [];\n  var p = !1,\n    m = null,\n    b,\n    x,\n    v;\n  var y = function y() {\n      return l(n, v, b) && a(n, v) !== 0;\n    },\n    _ = function _() {\n      return a(o, b) === 0 || l(o, v, b);\n    },\n    M = function M() {\n      return p || y();\n    },\n    k = function k() {\n      return !p || _();\n    };\n  for (var S = h, w = h; S <= d; ++S) x = t[S % r], !x.skip && (b = c(x[s]), b !== v && (p = l(b, n, o), m === null && M() && (m = a(b, n) === 0 ? S : w), m !== null && k() && (g.push(ds({\n    start: m,\n    end: S,\n    loop: u,\n    count: r,\n    style: f\n  })), m = null), w = S, v = b));\n  return m !== null && g.push(ds({\n    start: m,\n    end: d,\n    loop: u,\n    count: r,\n    style: f\n  })), g;\n}\nfunction Fn(i, t) {\n  var e = [],\n    s = i.segments;\n  for (var n = 0; n < s.length; n++) {\n    var o = En(s[n], i.points, t);\n    o.length && e.push.apply(e, _toConsumableArray(o));\n  }\n  return e;\n}\nfunction Xr(i, t, e, s) {\n  var n = 0,\n    o = t - 1;\n  if (e && !s) for (; n < t && !i[n].skip;) n++;\n  for (; n < t && i[n].skip;) n++;\n  for (n %= t, e && (o += n); o > n && i[o % t].skip;) o--;\n  return o %= t, {\n    start: n,\n    end: o\n  };\n}\nfunction Ur(i, t, e, s) {\n  var n = i.length,\n    o = [];\n  var r = t,\n    a = i[t],\n    l;\n  for (l = t + 1; l <= e; ++l) {\n    var c = i[l % n];\n    c.skip || c.stop ? a.skip || (s = !1, o.push({\n      start: t % n,\n      end: (l - 1) % n,\n      loop: s\n    }), t = r = c.stop ? l : null) : (r = l, a.skip && (t = l)), a = c;\n  }\n  return r !== null && o.push({\n    start: t % n,\n    end: r % n,\n    loop: s\n  }), o;\n}\nfunction Kr(i, t) {\n  var e = i.points,\n    s = i.options.spanGaps,\n    n = e.length;\n  if (!n) return [];\n  var o = !!i._loop,\n    _Xr = Xr(e, n, o, s),\n    r = _Xr.start,\n    a = _Xr.end;\n  if (s === !0) return us(i, [{\n    start: r,\n    end: a,\n    loop: o\n  }], e, t);\n  var l = a < r ? a + n : a,\n    c = !!i._fullLoop && r === 0 && a === n - 1;\n  return us(i, Ur(e, r, l, c), e, t);\n}\nfunction us(i, t, e, s) {\n  return !s || !s.setContext || !e ? t : qr(i, t, e, s);\n}\nfunction qr(i, t, e, s) {\n  var n = i._chart.getContext(),\n    o = fs(i.options),\n    r = i._datasetIndex,\n    a = i.options.spanGaps,\n    l = e.length,\n    c = [];\n  var h = o,\n    d = t[0].start,\n    u = d;\n  function f(g, p, m, b) {\n    var x = a ? -1 : 1;\n    if (g !== p) {\n      for (g += l; e[g % l].skip;) g -= x;\n      for (; e[p % l].skip;) p += x;\n      g % l !== p % l && (c.push({\n        start: g % l,\n        end: p % l,\n        loop: m,\n        style: b\n      }), h = b, d = p % l);\n    }\n  }\n  var _iterator11 = _createForOfIteratorHelper(t),\n    _step11;\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var g = _step11.value;\n      d = a ? d : g.start;\n      var p = e[d % l],\n        m = void 0;\n      for (u = d + 1; u <= g.end; u++) {\n        var b = e[u % l];\n        m = fs(s.setContext(vt(n, {\n          type: \"segment\",\n          p0: p,\n          p1: b,\n          p0DataIndex: (u - 1) % l,\n          p1DataIndex: u % l,\n          datasetIndex: r\n        }))), Gr(m, h) && f(d, u - 1, g.loop, h), p = b, h = m;\n      }\n      d < u - 1 && f(d, u - 1, g.loop, h);\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n  return c;\n}\nfunction fs(i) {\n  return {\n    backgroundColor: i.backgroundColor,\n    borderCapStyle: i.borderCapStyle,\n    borderDash: i.borderDash,\n    borderDashOffset: i.borderDashOffset,\n    borderJoinStyle: i.borderJoinStyle,\n    borderWidth: i.borderWidth,\n    borderColor: i.borderColor\n  };\n}\nfunction Gr(i, t) {\n  return t && JSON.stringify(i) !== JSON.stringify(t);\n}\n/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */\nvar Zr = /*#__PURE__*/function () {\n  function Zr() {\n    _classCallCheck(this, Zr);\n    this._request = null, this._charts = /* @__PURE__ */new Map(), this._running = !1, this._lastDate = void 0;\n  }\n  _createClass(Zr, [{\n    key: \"_notify\",\n    value: function _notify(t, e, s, n) {\n      var o = e.listeners[n],\n        r = e.duration;\n      o.forEach(function (a) {\n        return a({\n          chart: t,\n          initial: e.initial,\n          numSteps: r,\n          currentStep: Math.min(s - e.start, r)\n        });\n      });\n    }\n  }, {\n    key: \"_refresh\",\n    value: function _refresh() {\n      var _this = this;\n      this._request || (this._running = !0, this._request = fn.call(window, function () {\n        _this._update(), _this._request = null, _this._running && _this._refresh();\n      }));\n    }\n  }, {\n    key: \"_update\",\n    value: function _update() {\n      var _this2 = this;\n      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Date.now();\n      var e = 0;\n      this._charts.forEach(function (s, n) {\n        if (!s.running || !s.items.length) return;\n        var o = s.items;\n        var r = o.length - 1,\n          a = !1,\n          l;\n        for (; r >= 0; --r) l = o[r], l._active ? (l._total > s.duration && (s.duration = l._total), l.tick(t), a = !0) : (o[r] = o[o.length - 1], o.pop());\n        a && (n.draw(), _this2._notify(n, s, t, \"progress\")), o.length || (s.running = !1, _this2._notify(n, s, t, \"complete\"), s.initial = !1), e += o.length;\n      }), this._lastDate = t, e === 0 && (this._running = !1);\n    }\n  }, {\n    key: \"_getAnims\",\n    value: function _getAnims(t) {\n      var e = this._charts;\n      var s = e.get(t);\n      return s || (s = {\n        running: !1,\n        initial: !0,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      }, e.set(t, s)), s;\n    }\n  }, {\n    key: \"listen\",\n    value: function listen(t, e, s) {\n      this._getAnims(t).listeners[e].push(s);\n    }\n  }, {\n    key: \"add\",\n    value: function add(t, e) {\n      var _this$_getAnims$items;\n      !e || !e.length || (_this$_getAnims$items = this._getAnims(t).items).push.apply(_this$_getAnims$items, _toConsumableArray(e));\n    }\n  }, {\n    key: \"has\",\n    value: function has(t) {\n      return this._getAnims(t).items.length > 0;\n    }\n  }, {\n    key: \"start\",\n    value: function start(t) {\n      var e = this._charts.get(t);\n      e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce(function (s, n) {\n        return Math.max(s, n._duration);\n      }, 0), this._refresh());\n    }\n  }, {\n    key: \"running\",\n    value: function running(t) {\n      if (!this._running) return !1;\n      var e = this._charts.get(t);\n      return !(!e || !e.running || !e.items.length);\n    }\n  }, {\n    key: \"stop\",\n    value: function stop(t) {\n      var e = this._charts.get(t);\n      if (!e || !e.items.length) return;\n      var s = e.items;\n      var n = s.length - 1;\n      for (; n >= 0; --n) s[n].cancel();\n      e.items = [], this._notify(t, e, Date.now(), \"complete\");\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(t) {\n      return this._charts.delete(t);\n    }\n  }]);\n  return Zr;\n}();\nvar at = new Zr();\nvar gs = \"transparent\",\n  Jr = {\n    boolean: function boolean(i, t, e) {\n      return e > 0.5 ? t : i;\n    },\n    color: function color(i, t, e) {\n      var s = ns(i || gs),\n        n = s.valid && ns(t || gs);\n      return n && n.valid ? n.mix(s, e).hexString() : t;\n    },\n    number: function number(i, t, e) {\n      return i + (t - i) * e;\n    }\n  };\nvar In = /*#__PURE__*/function () {\n  function In(t, e, s, n) {\n    _classCallCheck(this, In);\n    var o = e[s];\n    n = Zt([t.to, n, o, t.from]);\n    var r = Zt([t.from, o, n]);\n    this._active = !0, this._fn = t.fn || Jr[t.type || typeof r], this._easing = ee[t.easing] || ee.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = s, this._from = r, this._to = n, this._promises = void 0;\n  }\n  _createClass(In, [{\n    key: \"active\",\n    value: function active() {\n      return this._active;\n    }\n  }, {\n    key: \"update\",\n    value: function update(t, e, s) {\n      if (this._active) {\n        this._notify(!1);\n        var n = this._target[this._prop],\n          o = s - this._start,\n          r = this._duration - o;\n        this._start = s, this._duration = Math.floor(Math.max(r, t.duration)), this._total += o, this._loop = !!t.loop, this._to = Zt([t.to, e, n, t.from]), this._from = Zt([t.from, n, e]);\n      }\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));\n    }\n  }, {\n    key: \"tick\",\n    value: function tick(t) {\n      var e = t - this._start,\n        s = this._duration,\n        n = this._prop,\n        o = this._from,\n        r = this._loop,\n        a = this._to;\n      var l;\n      if (this._active = o !== a && (r || e < s), !this._active) {\n        this._target[n] = a, this._notify(!0);\n        return;\n      }\n      if (e < 0) {\n        this._target[n] = o;\n        return;\n      }\n      l = e / s % 2, l = r && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[n] = this._fn(o, a, l);\n    }\n  }, {\n    key: \"wait\",\n    value: function wait() {\n      var t = this._promises || (this._promises = []);\n      return new Promise(function (e, s) {\n        t.push({\n          res: e,\n          rej: s\n        });\n      });\n    }\n  }, {\n    key: \"_notify\",\n    value: function _notify(t) {\n      var e = t ? \"res\" : \"rej\",\n        s = this._promises || [];\n      for (var n = 0; n < s.length; n++) s[n][e]();\n    }\n  }]);\n  return In;\n}();\nvar Qr = [\"x\", \"y\", \"borderWidth\", \"radius\", \"tension\"],\n  ta = [\"color\", \"borderColor\", \"backgroundColor\"];\nO.set(\"animation\", {\n  delay: void 0,\n  duration: 1e3,\n  easing: \"easeOutQuart\",\n  fn: void 0,\n  from: void 0,\n  loop: void 0,\n  to: void 0,\n  type: void 0\n});\nvar ea = Object.keys(O.animation);\nO.describe(\"animation\", {\n  _fallback: !1,\n  _indexable: !1,\n  _scriptable: function _scriptable(i) {\n    return i !== \"onProgress\" && i !== \"onComplete\" && i !== \"fn\";\n  }\n});\nO.set(\"animations\", {\n  colors: {\n    type: \"color\",\n    properties: ta\n  },\n  numbers: {\n    type: \"number\",\n    properties: Qr\n  }\n});\nO.describe(\"animations\", {\n  _fallback: \"animation\"\n});\nO.set(\"transitions\", {\n  active: {\n    animation: {\n      duration: 400\n    }\n  },\n  resize: {\n    animation: {\n      duration: 0\n    }\n  },\n  show: {\n    animations: {\n      colors: {\n        from: \"transparent\"\n      },\n      visible: {\n        type: \"boolean\",\n        duration: 0\n      }\n    }\n  },\n  hide: {\n    animations: {\n      colors: {\n        to: \"transparent\"\n      },\n      visible: {\n        type: \"boolean\",\n        easing: \"linear\",\n        fn: function fn(i) {\n          return i | 0;\n        }\n      }\n    }\n  }\n});\nvar Ni = /*#__PURE__*/function () {\n  function Ni(t, e) {\n    _classCallCheck(this, Ni);\n    this._chart = t, this._properties = /* @__PURE__ */new Map(), this.configure(e);\n  }\n  _createClass(Ni, [{\n    key: \"configure\",\n    value: function configure(t) {\n      if (!D(t)) return;\n      var e = this._properties;\n      Object.getOwnPropertyNames(t).forEach(function (s) {\n        var n = t[s];\n        if (!D(n)) return;\n        var o = {};\n        for (var _i2 = 0, _ea = ea; _i2 < _ea.length; _i2++) {\n          var r = _ea[_i2];\n          o[r] = n[r];\n        }\n        (z(n.properties) && n.properties || [s]).forEach(function (r) {\n          (r === s || !e.has(r)) && e.set(r, o);\n        });\n      });\n    }\n  }, {\n    key: \"_animateOptions\",\n    value: function _animateOptions(t, e) {\n      var s = e.options,\n        n = sa(t, s);\n      if (!n) return [];\n      var o = this._createAnimations(n, s);\n      return s.$shared && ia(t.options.$animations, s).then(function () {\n        t.options = s;\n      }, function () {}), o;\n    }\n  }, {\n    key: \"_createAnimations\",\n    value: function _createAnimations(t, e) {\n      var s = this._properties,\n        n = [],\n        o = t.$animations || (t.$animations = {}),\n        r = Object.keys(e),\n        a = Date.now();\n      var l;\n      for (l = r.length - 1; l >= 0; --l) {\n        var c = r[l];\n        if (c.charAt(0) === \"$\") continue;\n        if (c === \"options\") {\n          n.push.apply(n, _toConsumableArray(this._animateOptions(t, e)));\n          continue;\n        }\n        var h = e[c];\n        var d = o[c];\n        var u = s.get(c);\n        if (d) if (u && d.active()) {\n          d.update(u, h, a);\n          continue;\n        } else d.cancel();\n        if (!u || !u.duration) {\n          t[c] = h;\n          continue;\n        }\n        o[c] = d = new In(u, t, c, h), n.push(d);\n      }\n      return n;\n    }\n  }, {\n    key: \"update\",\n    value: function update(t, e) {\n      if (this._properties.size === 0) {\n        Object.assign(t, e);\n        return;\n      }\n      var s = this._createAnimations(t, e);\n      if (s.length) return at.add(this._chart, s), !0;\n    }\n  }]);\n  return Ni;\n}();\nfunction ia(i, t) {\n  var e = [],\n    s = Object.keys(t);\n  for (var n = 0; n < s.length; n++) {\n    var o = i[s[n]];\n    o && o.active() && e.push(o.wait());\n  }\n  return Promise.all(e);\n}\nfunction sa(i, t) {\n  if (!t) return;\n  var e = i.options;\n  if (!e) {\n    i.options = t;\n    return;\n  }\n  return e.$shared && (i.options = e = Object.assign({}, e, {\n    $shared: !1,\n    $animations: {}\n  })), e;\n}\nfunction ps(i, t) {\n  var e = i && i.options || {},\n    s = e.reverse,\n    n = e.min === void 0 ? t : 0,\n    o = e.max === void 0 ? t : 0;\n  return {\n    start: s ? o : n,\n    end: s ? n : o\n  };\n}\nfunction na(i, t, e) {\n  if (e === !1) return !1;\n  var s = ps(i, e),\n    n = ps(t, e);\n  return {\n    top: n.end,\n    right: s.end,\n    bottom: n.start,\n    left: s.start\n  };\n}\nfunction oa(i) {\n  var t, e, s, n;\n  return D(i) ? (t = i.top, e = i.right, s = i.bottom, n = i.left) : t = e = s = n = i, {\n    top: t,\n    right: e,\n    bottom: s,\n    left: n,\n    disabled: i === !1\n  };\n}\nfunction zn(i, t) {\n  var e = [],\n    s = i._getSortedDatasetMetas(t);\n  var n, o;\n  for (n = 0, o = s.length; n < o; ++n) e.push(s[n].index);\n  return e;\n}\nfunction ms(i, t, e) {\n  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var n = i.keys,\n    o = s.mode === \"single\";\n  var r, a, l, c;\n  if (t !== null) {\n    for (r = 0, a = n.length; r < a; ++r) {\n      if (l = +n[r], l === e) {\n        if (s.all) continue;\n        break;\n      }\n      c = i.values[l], N(c) && (o || t === 0 || lt(t) === lt(c)) && (t += c);\n    }\n    return t;\n  }\n}\nfunction ra(i) {\n  var t = Object.keys(i),\n    e = new Array(t.length);\n  var s, n, o;\n  for (s = 0, n = t.length; s < n; ++s) o = t[s], e[s] = {\n    x: o,\n    y: i[o]\n  };\n  return e;\n}\nfunction bs(i, t) {\n  var e = i && i.options.stacked;\n  return e || e === void 0 && t.stack !== void 0;\n}\nfunction aa(i, t, e) {\n  return \"\".concat(i.id, \".\").concat(t.id, \".\").concat(e.stack || e.type);\n}\nfunction la(i) {\n  var _i$getUserBounds = i.getUserBounds(),\n    t = _i$getUserBounds.min,\n    e = _i$getUserBounds.max,\n    s = _i$getUserBounds.minDefined,\n    n = _i$getUserBounds.maxDefined;\n  return {\n    min: s ? t : Number.NEGATIVE_INFINITY,\n    max: n ? e : Number.POSITIVE_INFINITY\n  };\n}\nfunction ca(i, t, e) {\n  var s = i[t] || (i[t] = {});\n  return s[e] || (s[e] = {});\n}\nfunction xs(i, t, e, s) {\n  var _iterator12 = _createForOfIteratorHelper(t.getMatchingVisibleMetas(s).reverse()),\n    _step12;\n  try {\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      var n = _step12.value;\n      var o = i[n.index];\n      if (e && o > 0 || !e && o < 0) return n.index;\n    }\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n  return null;\n}\nfunction _s(i, t) {\n  var e = i.chart,\n    s = i._cachedMeta,\n    n = e._stacks || (e._stacks = {}),\n    o = s.iScale,\n    r = s.vScale,\n    a = s.index,\n    l = o.axis,\n    c = r.axis,\n    h = aa(o, r, s),\n    d = t.length;\n  var u;\n  for (var f = 0; f < d; ++f) {\n    var g = t[f],\n      p = g[l],\n      m = g[c],\n      b = g._stacks || (g._stacks = {});\n    u = b[c] = ca(n, h, p), u[a] = m, u._top = xs(u, r, !0, s.type), u._bottom = xs(u, r, !1, s.type);\n  }\n}\nfunction li(i, t) {\n  var e = i.scales;\n  return Object.keys(e).filter(function (s) {\n    return e[s].axis === t;\n  }).shift();\n}\nfunction ha(i, t) {\n  return vt(i, {\n    active: !1,\n    dataset: void 0,\n    datasetIndex: t,\n    index: t,\n    mode: \"default\",\n    type: \"dataset\"\n  });\n}\nfunction da(i, t, e) {\n  return vt(i, {\n    active: !1,\n    dataIndex: t,\n    parsed: void 0,\n    raw: void 0,\n    element: e,\n    index: t,\n    mode: \"default\",\n    type: \"data\"\n  });\n}\nfunction Yt(i, t) {\n  var e = i.controller.index,\n    s = i.vScale && i.vScale.axis;\n  if (s) {\n    t = t || i._parsed;\n    var _iterator13 = _createForOfIteratorHelper(t),\n      _step13;\n    try {\n      for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n        var n = _step13.value;\n        var o = n._stacks;\n        if (!o || o[s] === void 0 || o[s][e] === void 0) return;\n        delete o[s][e];\n      }\n    } catch (err) {\n      _iterator13.e(err);\n    } finally {\n      _iterator13.f();\n    }\n  }\n}\nvar ci = function ci(i) {\n    return i === \"reset\" || i === \"none\";\n  },\n  ys = function ys(i, t) {\n    return t ? i : Object.assign({}, i);\n  },\n  ua = function ua(i, t, e) {\n    return i && !t.hidden && t._stacked && {\n      keys: zn(e, !0),\n      values: null\n    };\n  };\nvar it = /*#__PURE__*/function () {\n  function it(t, e) {\n    _classCallCheck(this, it);\n    this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.initialize();\n  }\n  _createClass(it, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var t = this._cachedMeta;\n      this.configure(), this.linkScales(), t._stacked = bs(t.vScale, t), this.addElements();\n    }\n  }, {\n    key: \"updateIndex\",\n    value: function updateIndex(t) {\n      this.index !== t && Yt(this._cachedMeta), this.index = t;\n    }\n  }, {\n    key: \"linkScales\",\n    value: function linkScales() {\n      var t = this.chart,\n        e = this._cachedMeta,\n        s = this.getDataset(),\n        n = function n(d, u, f, g) {\n          return d === \"x\" ? u : d === \"r\" ? g : f;\n        },\n        o = e.xAxisID = C(s.xAxisID, li(t, \"x\")),\n        r = e.yAxisID = C(s.yAxisID, li(t, \"y\")),\n        a = e.rAxisID = C(s.rAxisID, li(t, \"r\")),\n        l = e.indexAxis,\n        c = e.iAxisID = n(l, o, r, a),\n        h = e.vAxisID = n(l, r, o, a);\n      e.xScale = this.getScaleForId(o), e.yScale = this.getScaleForId(r), e.rScale = this.getScaleForId(a), e.iScale = this.getScaleForId(c), e.vScale = this.getScaleForId(h);\n    }\n  }, {\n    key: \"getDataset\",\n    value: function getDataset() {\n      return this.chart.data.datasets[this.index];\n    }\n  }, {\n    key: \"getMeta\",\n    value: function getMeta() {\n      return this.chart.getDatasetMeta(this.index);\n    }\n  }, {\n    key: \"getScaleForId\",\n    value: function getScaleForId(t) {\n      return this.chart.scales[t];\n    }\n  }, {\n    key: \"_getOtherScale\",\n    value: function _getOtherScale(t) {\n      var e = this._cachedMeta;\n      return t === e.iScale ? e.vScale : e.iScale;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._update(\"reset\");\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      var t = this._cachedMeta;\n      this._data && Zi(this._data, this), t._stacked && Yt(t);\n    }\n  }, {\n    key: \"_dataCheck\",\n    value: function _dataCheck() {\n      var t = this.getDataset(),\n        e = t.data || (t.data = []),\n        s = this._data;\n      if (D(e)) this._data = ra(e);else if (s !== e) {\n        if (s) {\n          Zi(s, this);\n          var n = this._cachedMeta;\n          Yt(n), n._parsed = [];\n        }\n        e && Object.isExtensible(e) && Eo(e, this), this._syncList = [], this._data = e;\n      }\n    }\n  }, {\n    key: \"addElements\",\n    value: function addElements() {\n      var t = this._cachedMeta;\n      this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType());\n    }\n  }, {\n    key: \"buildOrUpdateElements\",\n    value: function buildOrUpdateElements(t) {\n      var e = this._cachedMeta,\n        s = this.getDataset();\n      var n = !1;\n      this._dataCheck();\n      var o = e._stacked;\n      e._stacked = bs(e.vScale, e), e.stack !== s.stack && (n = !0, Yt(e), e.stack = s.stack), this._resyncElements(t), (n || o !== e._stacked) && _s(this, e._parsed);\n    }\n  }, {\n    key: \"configure\",\n    value: function configure() {\n      var t = this.chart.config,\n        e = t.datasetScopeKeys(this._type),\n        s = t.getOptionScopes(this.getDataset(), e, !0);\n      this.options = t.createResolver(s, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(t, e) {\n      var s = this._cachedMeta,\n        n = this._data,\n        o = s.iScale,\n        r = s._stacked,\n        a = o.axis;\n      var l = t === 0 && e === n.length ? !0 : s._sorted,\n        c = t > 0 && s._parsed[t - 1],\n        h,\n        d,\n        u;\n      if (this._parsing === !1) s._parsed = n, s._sorted = !0, u = n;else {\n        z(n[t]) ? u = this.parseArrayData(s, n, t, e) : D(n[t]) ? u = this.parseObjectData(s, n, t, e) : u = this.parsePrimitiveData(s, n, t, e);\n        var f = function f() {\n          return d[a] === null || c && d[a] < c[a];\n        };\n        for (h = 0; h < e; ++h) s._parsed[h + t] = d = u[h], l && (f() && (l = !1), c = d);\n        s._sorted = l;\n      }\n      r && _s(this, u);\n    }\n  }, {\n    key: \"parsePrimitiveData\",\n    value: function parsePrimitiveData(t, e, s, n) {\n      var o = t.iScale,\n        r = t.vScale,\n        a = o.axis,\n        l = r.axis,\n        c = o.getLabels(),\n        h = o === r,\n        d = new Array(n);\n      var u, f, g;\n      for (u = 0, f = n; u < f; ++u) {\n        var _d$u;\n        g = u + s, d[u] = (_d$u = {}, _defineProperty(_d$u, a, h || o.parse(c[g], g)), _defineProperty(_d$u, l, r.parse(e[g], g)), _d$u);\n      }\n      return d;\n    }\n  }, {\n    key: \"parseArrayData\",\n    value: function parseArrayData(t, e, s, n) {\n      var o = t.xScale,\n        r = t.yScale,\n        a = new Array(n);\n      var l, c, h, d;\n      for (l = 0, c = n; l < c; ++l) h = l + s, d = e[h], a[l] = {\n        x: o.parse(d[0], h),\n        y: r.parse(d[1], h)\n      };\n      return a;\n    }\n  }, {\n    key: \"parseObjectData\",\n    value: function parseObjectData(t, e, s, n) {\n      var o = t.xScale,\n        r = t.yScale,\n        _this$_parsing = this._parsing,\n        _this$_parsing$xAxisK = _this$_parsing.xAxisKey,\n        a = _this$_parsing$xAxisK === void 0 ? \"x\" : _this$_parsing$xAxisK,\n        _this$_parsing$yAxisK = _this$_parsing.yAxisKey,\n        l = _this$_parsing$yAxisK === void 0 ? \"y\" : _this$_parsing$yAxisK,\n        c = new Array(n);\n      var h, d, u, f;\n      for (h = 0, d = n; h < d; ++h) u = h + s, f = e[u], c[h] = {\n        x: o.parse(_t(f, a), u),\n        y: r.parse(_t(f, l), u)\n      };\n      return c;\n    }\n  }, {\n    key: \"getParsed\",\n    value: function getParsed(t) {\n      return this._cachedMeta._parsed[t];\n    }\n  }, {\n    key: \"getDataElement\",\n    value: function getDataElement(t) {\n      return this._cachedMeta.data[t];\n    }\n  }, {\n    key: \"applyStack\",\n    value: function applyStack(t, e, s) {\n      var n = this.chart,\n        o = this._cachedMeta,\n        r = e[t.axis],\n        a = {\n          keys: zn(n, !0),\n          values: e._stacks[t.axis]\n        };\n      return ms(a, r, o.index, {\n        mode: s\n      });\n    }\n  }, {\n    key: \"updateRangeFromParsed\",\n    value: function updateRangeFromParsed(t, e, s, n) {\n      var o = s[e.axis];\n      var r = o === null ? NaN : o;\n      var a = n && s._stacks[e.axis];\n      n && a && (n.values = a, r = ms(n, o, this._cachedMeta.index)), t.min = Math.min(t.min, r), t.max = Math.max(t.max, r);\n    }\n  }, {\n    key: \"getMinMax\",\n    value: function getMinMax(t, e) {\n      var s = this._cachedMeta,\n        n = s._parsed,\n        o = s._sorted && t === s.iScale,\n        r = n.length,\n        a = this._getOtherScale(t),\n        l = ua(e, s, this.chart),\n        c = {\n          min: Number.POSITIVE_INFINITY,\n          max: Number.NEGATIVE_INFINITY\n        },\n        _la = la(a),\n        h = _la.min,\n        d = _la.max;\n      var u, f;\n      function g() {\n        f = n[u];\n        var p = f[a.axis];\n        return !N(f[t.axis]) || h > p || d < p;\n      }\n      for (u = 0; u < r && !(!g() && (this.updateRangeFromParsed(c, t, f, l), o)); ++u);\n      if (o) {\n        for (u = r - 1; u >= 0; --u) if (!g()) {\n          this.updateRangeFromParsed(c, t, f, l);\n          break;\n        }\n      }\n      return c;\n    }\n  }, {\n    key: \"getAllParsedValues\",\n    value: function getAllParsedValues(t) {\n      var e = this._cachedMeta._parsed,\n        s = [];\n      var n, o, r;\n      for (n = 0, o = e.length; n < o; ++n) r = e[n][t.axis], N(r) && s.push(r);\n      return s;\n    }\n  }, {\n    key: \"getMaxOverflow\",\n    value: function getMaxOverflow() {\n      return !1;\n    }\n  }, {\n    key: \"getLabelAndValue\",\n    value: function getLabelAndValue(t) {\n      var e = this._cachedMeta,\n        s = e.iScale,\n        n = e.vScale,\n        o = this.getParsed(t);\n      return {\n        label: s ? \"\" + s.getLabelForValue(o[s.axis]) : \"\",\n        value: n ? \"\" + n.getLabelForValue(o[n.axis]) : \"\"\n      };\n    }\n  }, {\n    key: \"_update\",\n    value: function _update(t) {\n      var e = this._cachedMeta;\n      this.update(t || \"default\"), e._clip = oa(C(this.options.clip, na(e.xScale, e.yScale, this.getMaxOverflow())));\n    }\n  }, {\n    key: \"update\",\n    value: function update(t) {}\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var t = this._ctx,\n        e = this.chart,\n        s = this._cachedMeta,\n        n = s.data || [],\n        o = e.chartArea,\n        r = [],\n        a = this._drawStart || 0,\n        l = this._drawCount || n.length - a,\n        c = this.options.drawActiveElementsOnTop;\n      var h;\n      for (s.dataset && s.dataset.draw(t, o, a, l), h = a; h < a + l; ++h) {\n        var d = n[h];\n        d.hidden || (d.active && c ? r.push(d) : d.draw(t, o));\n      }\n      for (h = 0; h < r.length; ++h) r[h].draw(t, o);\n    }\n  }, {\n    key: \"getStyle\",\n    value: function getStyle(t, e) {\n      var s = e ? \"active\" : \"default\";\n      return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(s) : this.resolveDataElementOptions(t || 0, s);\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext(t, e, s) {\n      var n = this.getDataset();\n      var o;\n      if (t >= 0 && t < this._cachedMeta.data.length) {\n        var r = this._cachedMeta.data[t];\n        o = r.$context || (r.$context = da(this.getContext(), t, r)), o.parsed = this.getParsed(t), o.raw = n.data[t], o.index = o.dataIndex = t;\n      } else o = this.$context || (this.$context = ha(this.chart.getContext(), this.index)), o.dataset = n, o.index = o.datasetIndex = this.index;\n      return o.active = !!e, o.mode = s, o;\n    }\n  }, {\n    key: \"resolveDatasetElementOptions\",\n    value: function resolveDatasetElementOptions(t) {\n      return this._resolveElementOptions(this.datasetElementType.id, t);\n    }\n  }, {\n    key: \"resolveDataElementOptions\",\n    value: function resolveDataElementOptions(t, e) {\n      return this._resolveElementOptions(this.dataElementType.id, e, t);\n    }\n  }, {\n    key: \"_resolveElementOptions\",\n    value: function _resolveElementOptions(t) {\n      var _this3 = this;\n      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"default\";\n      var s = arguments.length > 2 ? arguments[2] : undefined;\n      var n = e === \"active\",\n        o = this._cachedDataOpts,\n        r = t + \"-\" + e,\n        a = o[r],\n        l = this.enableOptionSharing && et(s);\n      if (a) return ys(a, l);\n      var c = this.chart.config,\n        h = c.datasetElementScopeKeys(this._type, t),\n        d = n ? [\"\".concat(t, \"Hover\"), \"hover\", t, \"\"] : [t, \"\"],\n        u = c.getOptionScopes(this.getDataset(), h),\n        f = Object.keys(O.elements[t]),\n        g = function g() {\n          return _this3.getContext(s, n);\n        },\n        p = c.resolveNamedOptions(u, f, g, d);\n      return p.$shared && (p.$shared = l, o[r] = Object.freeze(ys(p, l))), p;\n    }\n  }, {\n    key: \"_resolveAnimations\",\n    value: function _resolveAnimations(t, e, s) {\n      var n = this.chart,\n        o = this._cachedDataOpts,\n        r = \"animation-\".concat(e),\n        a = o[r];\n      if (a) return a;\n      var l;\n      if (n.options.animation !== !1) {\n        var h = this.chart.config,\n          d = h.datasetAnimationScopeKeys(this._type, e),\n          u = h.getOptionScopes(this.getDataset(), d);\n        l = h.createResolver(u, this.getContext(t, s, e));\n      }\n      var c = new Ni(n, l && l.animations);\n      return l && l._cacheable && (o[r] = Object.freeze(c)), c;\n    }\n  }, {\n    key: \"getSharedOptions\",\n    value: function getSharedOptions(t) {\n      if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));\n    }\n  }, {\n    key: \"includeOptions\",\n    value: function includeOptions(t, e) {\n      return !e || ci(t) || this.chart._animationsDisabled;\n    }\n  }, {\n    key: \"_getSharedOptions\",\n    value: function _getSharedOptions(t, e) {\n      var s = this.resolveDataElementOptions(t, e),\n        n = this._sharedOptions,\n        o = this.getSharedOptions(s),\n        r = this.includeOptions(e, o) || o !== n;\n      return this.updateSharedOptions(o, e, s), {\n        sharedOptions: o,\n        includeOptions: r\n      };\n    }\n  }, {\n    key: \"updateElement\",\n    value: function updateElement(t, e, s, n) {\n      ci(n) ? Object.assign(t, s) : this._resolveAnimations(e, n).update(t, s);\n    }\n  }, {\n    key: \"updateSharedOptions\",\n    value: function updateSharedOptions(t, e, s) {\n      t && !ci(e) && this._resolveAnimations(void 0, e).update(t, s);\n    }\n  }, {\n    key: \"_setStyle\",\n    value: function _setStyle(t, e, s, n) {\n      t.active = n;\n      var o = this.getStyle(e, n);\n      this._resolveAnimations(e, s, n).update(t, {\n        options: !n && this.getSharedOptions(o) || o\n      });\n    }\n  }, {\n    key: \"removeHoverStyle\",\n    value: function removeHoverStyle(t, e, s) {\n      this._setStyle(t, s, \"active\", !1);\n    }\n  }, {\n    key: \"setHoverStyle\",\n    value: function setHoverStyle(t, e, s) {\n      this._setStyle(t, s, \"active\", !0);\n    }\n  }, {\n    key: \"_removeDatasetHoverStyle\",\n    value: function _removeDatasetHoverStyle() {\n      var t = this._cachedMeta.dataset;\n      t && this._setStyle(t, void 0, \"active\", !1);\n    }\n  }, {\n    key: \"_setDatasetHoverStyle\",\n    value: function _setDatasetHoverStyle() {\n      var t = this._cachedMeta.dataset;\n      t && this._setStyle(t, void 0, \"active\", !0);\n    }\n  }, {\n    key: \"_resyncElements\",\n    value: function _resyncElements(t) {\n      var e = this._data,\n        s = this._cachedMeta.data;\n      var _iterator14 = _createForOfIteratorHelper(this._syncList),\n        _step14;\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var _step14$value = _slicedToArray(_step14.value, 3),\n            a = _step14$value[0],\n            l = _step14$value[1],\n            c = _step14$value[2];\n          this[a](l, c);\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n      this._syncList = [];\n      var n = s.length,\n        o = e.length,\n        r = Math.min(o, n);\n      r && this.parse(0, r), o > n ? this._insertElements(n, o - n, t) : o < n && this._removeElements(o, n - o);\n    }\n  }, {\n    key: \"_insertElements\",\n    value: function _insertElements(t, e) {\n      var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;\n      var n = this._cachedMeta,\n        o = n.data,\n        r = t + e;\n      var a;\n      var l = function l(c) {\n        for (c.length += e, a = c.length - 1; a >= r; a--) c[a] = c[a - e];\n      };\n      for (l(o), a = t; a < r; ++a) o[a] = new this.dataElementType();\n      this._parsing && l(n._parsed), this.parse(t, e), s && this.updateElements(o, t, e, \"reset\");\n    }\n  }, {\n    key: \"updateElements\",\n    value: function updateElements(t, e, s, n) {}\n  }, {\n    key: \"_removeElements\",\n    value: function _removeElements(t, e) {\n      var s = this._cachedMeta;\n      if (this._parsing) {\n        var n = s._parsed.splice(t, e);\n        s._stacked && Yt(s, n);\n      }\n      s.data.splice(t, e);\n    }\n  }, {\n    key: \"_sync\",\n    value: function _sync(t) {\n      if (this._parsing) this._syncList.push(t);else {\n        var _t2 = _slicedToArray(t, 3),\n          e = _t2[0],\n          s = _t2[1],\n          n = _t2[2];\n        this[e](s, n);\n      }\n      this.chart._dataChanges.push([this.index].concat(_toConsumableArray(t)));\n    }\n  }, {\n    key: \"_onDataPush\",\n    value: function _onDataPush() {\n      var t = arguments.length;\n      this._sync([\"_insertElements\", this.getDataset().data.length - t, t]);\n    }\n  }, {\n    key: \"_onDataPop\",\n    value: function _onDataPop() {\n      this._sync([\"_removeElements\", this._cachedMeta.data.length - 1, 1]);\n    }\n  }, {\n    key: \"_onDataShift\",\n    value: function _onDataShift() {\n      this._sync([\"_removeElements\", 0, 1]);\n    }\n  }, {\n    key: \"_onDataSplice\",\n    value: function _onDataSplice(t, e) {\n      e && this._sync([\"_removeElements\", t, e]);\n      var s = arguments.length - 2;\n      s && this._sync([\"_insertElements\", t, s]);\n    }\n  }, {\n    key: \"_onDataUnshift\",\n    value: function _onDataUnshift() {\n      this._sync([\"_insertElements\", 0, arguments.length]);\n    }\n  }]);\n  return it;\n}();\nit.defaults = {};\nit.prototype.datasetElementType = null;\nit.prototype.dataElementType = null;\nfunction fa(i, t) {\n  if (!i._cache.$bar) {\n    var e = i.getMatchingVisibleMetas(t);\n    var s = [];\n    for (var n = 0, o = e.length; n < o; n++) s = s.concat(e[n].controller.getAllParsedValues(i));\n    i._cache.$bar = un(s.sort(function (n, o) {\n      return n - o;\n    }));\n  }\n  return i._cache.$bar;\n}\nfunction ga(i) {\n  var t = i.iScale,\n    e = fa(t, i.type);\n  var s = t._length,\n    n,\n    o,\n    r,\n    a;\n  var l = function l() {\n    r === 32767 || r === -32768 || (et(a) && (s = Math.min(s, Math.abs(r - a) || s)), a = r);\n  };\n  for (n = 0, o = e.length; n < o; ++n) r = t.getPixelForValue(e[n]), l();\n  for (a = void 0, n = 0, o = t.ticks.length; n < o; ++n) r = t.getPixelForTick(n), l();\n  return s;\n}\nfunction pa(i, t, e, s) {\n  var n = e.barThickness;\n  var o, r;\n  return T(n) ? (o = t.min * e.categoryPercentage, r = e.barPercentage) : (o = n * s, r = 1), {\n    chunk: o / s,\n    ratio: r,\n    start: t.pixels[i] - o / 2\n  };\n}\nfunction ma(i, t, e, s) {\n  var n = t.pixels,\n    o = n[i];\n  var r = i > 0 ? n[i - 1] : null,\n    a = i < n.length - 1 ? n[i + 1] : null;\n  var l = e.categoryPercentage;\n  r === null && (r = o - (a === null ? t.end - t.start : a - o)), a === null && (a = o + o - r);\n  var c = o - (o - Math.min(r, a)) / 2 * l;\n  return {\n    chunk: Math.abs(a - r) / 2 * l / s,\n    ratio: e.barPercentage,\n    start: c\n  };\n}\nfunction ba(i, t, e, s) {\n  var n = e.parse(i[0], s),\n    o = e.parse(i[1], s),\n    r = Math.min(n, o),\n    a = Math.max(n, o);\n  var l = r,\n    c = a;\n  Math.abs(r) > Math.abs(a) && (l = a, c = r), t[e.axis] = c, t._custom = {\n    barStart: l,\n    barEnd: c,\n    start: n,\n    end: o,\n    min: r,\n    max: a\n  };\n}\nfunction Bn(i, t, e, s) {\n  return z(i) ? ba(i, t, e, s) : t[e.axis] = e.parse(i, s), t;\n}\nfunction vs(i, t, e, s) {\n  var n = i.iScale,\n    o = i.vScale,\n    r = n.getLabels(),\n    a = n === o,\n    l = [];\n  var c, h, d, u;\n  for (c = e, h = e + s; c < h; ++c) u = t[c], d = {}, d[n.axis] = a || n.parse(r[c], c), l.push(Bn(u, d, o, c));\n  return l;\n}\nfunction hi(i) {\n  return i && i.barStart !== void 0 && i.barEnd !== void 0;\n}\nfunction xa(i, t, e) {\n  return i !== 0 ? lt(i) : (t.isHorizontal() ? 1 : -1) * (t.min >= e ? 1 : -1);\n}\nfunction _a(i) {\n  var t, e, s, n, o;\n  return i.horizontal ? (t = i.base > i.x, e = \"left\", s = \"right\") : (t = i.base < i.y, e = \"bottom\", s = \"top\"), t ? (n = \"end\", o = \"start\") : (n = \"start\", o = \"end\"), {\n    start: e,\n    end: s,\n    reverse: t,\n    top: n,\n    bottom: o\n  };\n}\nfunction ya(i, t, e, s) {\n  var n = t.borderSkipped;\n  var o = {};\n  if (!n) {\n    i.borderSkipped = o;\n    return;\n  }\n  if (n === !0) {\n    i.borderSkipped = {\n      top: !0,\n      right: !0,\n      bottom: !0,\n      left: !0\n    };\n    return;\n  }\n  var _a2 = _a(i),\n    r = _a2.start,\n    a = _a2.end,\n    l = _a2.reverse,\n    c = _a2.top,\n    h = _a2.bottom;\n  n === \"middle\" && e && (i.enableBorderRadius = !0, (e._top || 0) === s ? n = c : (e._bottom || 0) === s ? n = h : (o[Ms(h, r, a, l)] = !0, n = c)), o[Ms(n, r, a, l)] = !0, i.borderSkipped = o;\n}\nfunction Ms(i, t, e, s) {\n  return s ? (i = va(i, t, e), i = ks(i, e, t)) : i = ks(i, t, e), i;\n}\nfunction va(i, t, e) {\n  return i === t ? e : i === e ? t : i;\n}\nfunction ks(i, t, e) {\n  return i === \"start\" ? t : i === \"end\" ? e : i;\n}\nfunction Ma(i, _ref2, e) {\n  var t = _ref2.inflateAmount;\n  i.inflateAmount = t === \"auto\" ? e === 1 ? 0.33 : 0 : t;\n}\nvar ue = /*#__PURE__*/function (_it) {\n  _inherits(ue, _it);\n  var _super = _createSuper(ue);\n  function ue() {\n    _classCallCheck(this, ue);\n    return _super.apply(this, arguments);\n  }\n  _createClass(ue, [{\n    key: \"parsePrimitiveData\",\n    value: function parsePrimitiveData(t, e, s, n) {\n      return vs(t, e, s, n);\n    }\n  }, {\n    key: \"parseArrayData\",\n    value: function parseArrayData(t, e, s, n) {\n      return vs(t, e, s, n);\n    }\n  }, {\n    key: \"parseObjectData\",\n    value: function parseObjectData(t, e, s, n) {\n      var o = t.iScale,\n        r = t.vScale,\n        _this$_parsing2 = this._parsing,\n        _this$_parsing2$xAxis = _this$_parsing2.xAxisKey,\n        a = _this$_parsing2$xAxis === void 0 ? \"x\" : _this$_parsing2$xAxis,\n        _this$_parsing2$yAxis = _this$_parsing2.yAxisKey,\n        l = _this$_parsing2$yAxis === void 0 ? \"y\" : _this$_parsing2$yAxis,\n        c = o.axis === \"x\" ? a : l,\n        h = r.axis === \"x\" ? a : l,\n        d = [];\n      var u, f, g, p;\n      for (u = s, f = s + n; u < f; ++u) p = e[u], g = {}, g[o.axis] = o.parse(_t(p, c), u), d.push(Bn(_t(p, h), g, r, u));\n      return d;\n    }\n  }, {\n    key: \"updateRangeFromParsed\",\n    value: function updateRangeFromParsed(t, e, s, n) {\n      _get(_getPrototypeOf(ue.prototype), \"updateRangeFromParsed\", this).call(this, t, e, s, n);\n      var o = s._custom;\n      o && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, o.min), t.max = Math.max(t.max, o.max));\n    }\n  }, {\n    key: \"getMaxOverflow\",\n    value: function getMaxOverflow() {\n      return 0;\n    }\n  }, {\n    key: \"getLabelAndValue\",\n    value: function getLabelAndValue(t) {\n      var e = this._cachedMeta,\n        s = e.iScale,\n        n = e.vScale,\n        o = this.getParsed(t),\n        r = o._custom,\n        a = hi(r) ? \"[\" + r.start + \", \" + r.end + \"]\" : \"\" + n.getLabelForValue(o[n.axis]);\n      return {\n        label: \"\" + s.getLabelForValue(o[s.axis]),\n        value: a\n      };\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      this.enableOptionSharing = !0, _get(_getPrototypeOf(ue.prototype), \"initialize\", this).call(this);\n      var t = this._cachedMeta;\n      t.stack = this.getDataset().stack;\n    }\n  }, {\n    key: \"update\",\n    value: function update(t) {\n      var e = this._cachedMeta;\n      this.updateElements(e.data, 0, e.data.length, t);\n    }\n  }, {\n    key: \"updateElements\",\n    value: function updateElements(t, e, s, n) {\n      var o = n === \"reset\",\n        r = this.index,\n        a = this._cachedMeta.vScale,\n        l = a.getBasePixel(),\n        c = a.isHorizontal(),\n        h = this._getRuler(),\n        _this$_getSharedOptio = this._getSharedOptions(e, n),\n        d = _this$_getSharedOptio.sharedOptions,\n        u = _this$_getSharedOptio.includeOptions;\n      for (var f = e; f < e + s; f++) {\n        var g = this.getParsed(f),\n          p = o || T(g[a.axis]) ? {\n            base: l,\n            head: l\n          } : this._calculateBarValuePixels(f),\n          m = this._calculateBarIndexPixels(f, h),\n          b = (g._stacks || {})[a.axis],\n          x = {\n            horizontal: c,\n            base: p.base,\n            enableBorderRadius: !b || hi(g._custom) || r === b._top || r === b._bottom,\n            x: c ? p.head : m.center,\n            y: c ? m.center : p.head,\n            height: c ? m.size : Math.abs(p.size),\n            width: c ? Math.abs(p.size) : m.size\n          };\n        u && (x.options = d || this.resolveDataElementOptions(f, t[f].active ? \"active\" : n));\n        var v = x.options || t[f].options;\n        ya(x, v, b, r), Ma(x, v, h.ratio), this.updateElement(t[f], f, x, n);\n      }\n    }\n  }, {\n    key: \"_getStacks\",\n    value: function _getStacks(t, e) {\n      var s = this._cachedMeta.iScale,\n        n = s.getMatchingVisibleMetas(this._type).filter(function (l) {\n          return l.controller.options.grouped;\n        }),\n        o = s.options.stacked,\n        r = [],\n        a = function a(l) {\n          var c = l.controller.getParsed(e),\n            h = c && c[l.vScale.axis];\n          if (T(h) || isNaN(h)) return !0;\n        };\n      var _iterator15 = _createForOfIteratorHelper(n),\n        _step15;\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var l = _step15.value;\n          if (!(e !== void 0 && a(l)) && ((o === !1 || r.indexOf(l.stack) === -1 || o === void 0 && l.stack === void 0) && r.push(l.stack), l.index === t)) break;\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n      return r.length || r.push(void 0), r;\n    }\n  }, {\n    key: \"_getStackCount\",\n    value: function _getStackCount(t) {\n      return this._getStacks(void 0, t).length;\n    }\n  }, {\n    key: \"_getStackIndex\",\n    value: function _getStackIndex(t, e, s) {\n      var n = this._getStacks(t, s),\n        o = e !== void 0 ? n.indexOf(e) : -1;\n      return o === -1 ? n.length - 1 : o;\n    }\n  }, {\n    key: \"_getRuler\",\n    value: function _getRuler() {\n      var t = this.options,\n        e = this._cachedMeta,\n        s = e.iScale,\n        n = [];\n      var o, r;\n      for (o = 0, r = e.data.length; o < r; ++o) n.push(s.getPixelForValue(this.getParsed(o)[s.axis], o));\n      var a = t.barThickness;\n      return {\n        min: a || ga(e),\n        pixels: n,\n        start: s._startPixel,\n        end: s._endPixel,\n        stackCount: this._getStackCount(),\n        scale: s,\n        grouped: t.grouped,\n        ratio: a ? 1 : t.categoryPercentage * t.barPercentage\n      };\n    }\n  }, {\n    key: \"_calculateBarValuePixels\",\n    value: function _calculateBarValuePixels(t) {\n      var _this$_cachedMeta = this._cachedMeta,\n        e = _this$_cachedMeta.vScale,\n        s = _this$_cachedMeta._stacked,\n        _this$options = this.options,\n        n = _this$options.base,\n        o = _this$options.minBarLength,\n        r = n || 0,\n        a = this.getParsed(t),\n        l = a._custom,\n        c = hi(l);\n      var h = a[e.axis],\n        d = 0,\n        u = s ? this.applyStack(e, a, s) : h,\n        f,\n        g;\n      u !== h && (d = u - h, u = h), c && (h = l.barStart, u = l.barEnd - l.barStart, h !== 0 && lt(h) !== lt(l.barEnd) && (d = 0), d += h);\n      var p = !T(n) && !c ? n : d;\n      var m = e.getPixelForValue(p);\n      if (this.chart.getDataVisibility(t) ? f = e.getPixelForValue(d + u) : f = m, g = f - m, Math.abs(g) < o) {\n        g = xa(g, e, r) * o, h === r && (m -= g / 2);\n        var b = e.getPixelForDecimal(0),\n          x = e.getPixelForDecimal(1),\n          v = Math.min(b, x),\n          y = Math.max(b, x);\n        m = Math.max(Math.min(m, y), v), f = m + g;\n      }\n      if (m === e.getPixelForValue(r)) {\n        var _b = lt(g) * e.getLineWidthForValue(r) / 2;\n        m += _b, g -= _b;\n      }\n      return {\n        size: g,\n        base: m,\n        head: f,\n        center: f + g / 2\n      };\n    }\n  }, {\n    key: \"_calculateBarIndexPixels\",\n    value: function _calculateBarIndexPixels(t, e) {\n      var s = e.scale,\n        n = this.options,\n        o = n.skipNull,\n        r = C(n.maxBarThickness, 1 / 0);\n      var a, l;\n      if (e.grouped) {\n        var c = o ? this._getStackCount(t) : e.stackCount,\n          h = n.barThickness === \"flex\" ? ma(t, e, n, c) : pa(t, e, n, c),\n          d = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0);\n        a = h.start + h.chunk * d + h.chunk / 2, l = Math.min(r, h.chunk * h.ratio);\n      } else a = s.getPixelForValue(this.getParsed(t)[s.axis], t), l = Math.min(r, e.min * e.ratio);\n      return {\n        base: a - l / 2,\n        head: a + l / 2,\n        center: a,\n        size: l\n      };\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var t = this._cachedMeta,\n        e = t.vScale,\n        s = t.data,\n        n = s.length;\n      var o = 0;\n      for (; o < n; ++o) this.getParsed(o)[e.axis] !== null && s[o].draw(this._ctx);\n    }\n  }]);\n  return ue;\n}(it);\nue.id = \"bar\";\nue.defaults = {\n  datasetElementType: !1,\n  dataElementType: \"bar\",\n  categoryPercentage: 0.8,\n  barPercentage: 0.9,\n  grouped: !0,\n  animations: {\n    numbers: {\n      type: \"number\",\n      properties: [\"x\", \"y\", \"base\", \"width\", \"height\"]\n    }\n  }\n};\nue.overrides = {\n  scales: {\n    _index_: {\n      type: \"category\",\n      offset: !0,\n      grid: {\n        offset: !0\n      }\n    },\n    _value_: {\n      type: \"linear\",\n      beginAtZero: !0\n    }\n  }\n};\nvar fe = /*#__PURE__*/function (_it2) {\n  _inherits(fe, _it2);\n  var _super2 = _createSuper(fe);\n  function fe() {\n    _classCallCheck(this, fe);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(fe, [{\n    key: \"initialize\",\n    value: function initialize() {\n      this.enableOptionSharing = !0, _get(_getPrototypeOf(fe.prototype), \"initialize\", this).call(this);\n    }\n  }, {\n    key: \"parsePrimitiveData\",\n    value: function parsePrimitiveData(t, e, s, n) {\n      var o = _get(_getPrototypeOf(fe.prototype), \"parsePrimitiveData\", this).call(this, t, e, s, n);\n      for (var r = 0; r < o.length; r++) o[r]._custom = this.resolveDataElementOptions(r + s).radius;\n      return o;\n    }\n  }, {\n    key: \"parseArrayData\",\n    value: function parseArrayData(t, e, s, n) {\n      var o = _get(_getPrototypeOf(fe.prototype), \"parseArrayData\", this).call(this, t, e, s, n);\n      for (var r = 0; r < o.length; r++) {\n        var a = e[s + r];\n        o[r]._custom = C(a[2], this.resolveDataElementOptions(r + s).radius);\n      }\n      return o;\n    }\n  }, {\n    key: \"parseObjectData\",\n    value: function parseObjectData(t, e, s, n) {\n      var o = _get(_getPrototypeOf(fe.prototype), \"parseObjectData\", this).call(this, t, e, s, n);\n      for (var r = 0; r < o.length; r++) {\n        var a = e[s + r];\n        o[r]._custom = C(a && a.r && +a.r, this.resolveDataElementOptions(r + s).radius);\n      }\n      return o;\n    }\n  }, {\n    key: \"getMaxOverflow\",\n    value: function getMaxOverflow() {\n      var t = this._cachedMeta.data;\n      var e = 0;\n      for (var s = t.length - 1; s >= 0; --s) e = Math.max(e, t[s].size(this.resolveDataElementOptions(s)) / 2);\n      return e > 0 && e;\n    }\n  }, {\n    key: \"getLabelAndValue\",\n    value: function getLabelAndValue(t) {\n      var e = this._cachedMeta,\n        s = e.xScale,\n        n = e.yScale,\n        o = this.getParsed(t),\n        r = s.getLabelForValue(o.x),\n        a = n.getLabelForValue(o.y),\n        l = o._custom;\n      return {\n        label: e.label,\n        value: \"(\" + r + \", \" + a + (l ? \", \" + l : \"\") + \")\"\n      };\n    }\n  }, {\n    key: \"update\",\n    value: function update(t) {\n      var e = this._cachedMeta.data;\n      this.updateElements(e, 0, e.length, t);\n    }\n  }, {\n    key: \"updateElements\",\n    value: function updateElements(t, e, s, n) {\n      var o = n === \"reset\",\n        _this$_cachedMeta2 = this._cachedMeta,\n        r = _this$_cachedMeta2.iScale,\n        a = _this$_cachedMeta2.vScale,\n        _this$_getSharedOptio2 = this._getSharedOptions(e, n),\n        l = _this$_getSharedOptio2.sharedOptions,\n        c = _this$_getSharedOptio2.includeOptions,\n        h = r.axis,\n        d = a.axis;\n      for (var u = e; u < e + s; u++) {\n        var f = t[u],\n          g = !o && this.getParsed(u),\n          p = {},\n          m = p[h] = o ? r.getPixelForDecimal(0.5) : r.getPixelForValue(g[h]),\n          b = p[d] = o ? a.getBasePixel() : a.getPixelForValue(g[d]);\n        p.skip = isNaN(m) || isNaN(b), c && (p.options = l || this.resolveDataElementOptions(u, f.active ? \"active\" : n), o && (p.options.radius = 0)), this.updateElement(f, u, p, n);\n      }\n    }\n  }, {\n    key: \"resolveDataElementOptions\",\n    value: function resolveDataElementOptions(t, e) {\n      var s = this.getParsed(t);\n      var n = _get(_getPrototypeOf(fe.prototype), \"resolveDataElementOptions\", this).call(this, t, e);\n      n.$shared && (n = Object.assign({}, n, {\n        $shared: !1\n      }));\n      var o = n.radius;\n      return e !== \"active\" && (n.radius = 0), n.radius += C(s && s._custom, o), n;\n    }\n  }]);\n  return fe;\n}(it);\nfe.id = \"bubble\";\nfe.defaults = {\n  datasetElementType: !1,\n  dataElementType: \"point\",\n  animations: {\n    numbers: {\n      type: \"number\",\n      properties: [\"x\", \"y\", \"borderWidth\", \"radius\"]\n    }\n  }\n};\nfe.overrides = {\n  scales: {\n    x: {\n      type: \"linear\"\n    },\n    y: {\n      type: \"linear\"\n    }\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title: function title() {\n          return \"\";\n        }\n      }\n    }\n  }\n};\nfunction ka(i, t, e) {\n  var s = 1,\n    n = 1,\n    o = 0,\n    r = 0;\n  if (t < F) {\n    var a = i,\n      l = a + t,\n      c = Math.cos(a),\n      h = Math.sin(a),\n      d = Math.cos(l),\n      u = Math.sin(l),\n      f = function f(v, y, _) {\n        return oe(v, a, l, !0) ? 1 : Math.max(y, y * e, _, _ * e);\n      },\n      g = function g(v, y, _) {\n        return oe(v, a, l, !0) ? -1 : Math.min(y, y * e, _, _ * e);\n      },\n      p = f(0, c, d),\n      m = f(V, h, u),\n      b = g(B, c, d),\n      x = g(B + V, h, u);\n    s = (p - b) / 2, n = (m - x) / 2, o = -(p + b) / 2, r = -(m + x) / 2;\n  }\n  return {\n    ratioX: s,\n    ratioY: n,\n    offsetX: o,\n    offsetY: r\n  };\n}\nvar Lt = /*#__PURE__*/function (_it3) {\n  _inherits(Lt, _it3);\n  var _super3 = _createSuper(Lt);\n  function Lt(t, e) {\n    var _this4;\n    _classCallCheck(this, Lt);\n    _this4 = _super3.call(this, t, e), _this4.enableOptionSharing = !0, _this4.innerRadius = void 0, _this4.outerRadius = void 0, _this4.offsetX = void 0, _this4.offsetY = void 0;\n    return _this4;\n  }\n  _createClass(Lt, [{\n    key: \"linkScales\",\n    value: function linkScales() {}\n  }, {\n    key: \"parse\",\n    value: function parse(t, e) {\n      var s = this.getDataset().data,\n        n = this._cachedMeta;\n      if (this._parsing === !1) n._parsed = s;else {\n        var o = function o(l) {\n          return +s[l];\n        };\n        if (D(s[t])) {\n          var _this$_parsing$key2 = this._parsing.key,\n            l = _this$_parsing$key2 === void 0 ? \"value\" : _this$_parsing$key2;\n          o = function o(c) {\n            return +_t(s[c], l);\n          };\n        }\n        var r, a;\n        for (r = t, a = t + e; r < a; ++r) n._parsed[r] = o(r);\n      }\n    }\n  }, {\n    key: \"_getRotation\",\n    value: function _getRotation() {\n      return nt(this.options.rotation - 90);\n    }\n  }, {\n    key: \"_getCircumference\",\n    value: function _getCircumference() {\n      return nt(this.options.circumference);\n    }\n  }, {\n    key: \"_getRotationExtents\",\n    value: function _getRotationExtents() {\n      var t = F,\n        e = -F;\n      for (var s = 0; s < this.chart.data.datasets.length; ++s) if (this.chart.isDatasetVisible(s)) {\n        var n = this.chart.getDatasetMeta(s).controller,\n          o = n._getRotation(),\n          r = n._getCircumference();\n        t = Math.min(t, o), e = Math.max(e, o + r);\n      }\n      return {\n        rotation: t,\n        circumference: e - t\n      };\n    }\n  }, {\n    key: \"update\",\n    value: function update(t) {\n      var e = this.chart,\n        s = e.chartArea,\n        n = this._cachedMeta,\n        o = n.data,\n        r = this.getMaxBorderWidth() + this.getMaxOffset(o) + this.options.spacing,\n        a = Math.max((Math.min(s.width, s.height) - r) / 2, 0),\n        l = Math.min(yo(this.options.cutout, a), 1),\n        c = this._getRingWeight(this.index),\n        _this$_getRotationExt = this._getRotationExtents(),\n        h = _this$_getRotationExt.circumference,\n        d = _this$_getRotationExt.rotation,\n        _ka = ka(d, h, l),\n        u = _ka.ratioX,\n        f = _ka.ratioY,\n        g = _ka.offsetX,\n        p = _ka.offsetY,\n        m = (s.width - r) / u,\n        b = (s.height - r) / f,\n        x = Math.max(Math.min(m, b) / 2, 0),\n        v = an(this.options.radius, x),\n        y = Math.max(v * l, 0),\n        _ = (v - y) / this._getVisibleDatasetWeightTotal();\n      this.offsetX = g * v, this.offsetY = p * v, n.total = this.calculateTotal(), this.outerRadius = v - _ * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - _ * c, 0), this.updateElements(o, 0, o.length, t);\n    }\n  }, {\n    key: \"_circumference\",\n    value: function _circumference(t, e) {\n      var s = this.options,\n        n = this._cachedMeta,\n        o = this._getCircumference();\n      return e && s.animation.animateRotate || !this.chart.getDataVisibility(t) || n._parsed[t] === null || n.data[t].hidden ? 0 : this.calculateCircumference(n._parsed[t] * o / F);\n    }\n  }, {\n    key: \"updateElements\",\n    value: function updateElements(t, e, s, n) {\n      var o = n === \"reset\",\n        r = this.chart,\n        a = r.chartArea,\n        c = r.options.animation,\n        h = (a.left + a.right) / 2,\n        d = (a.top + a.bottom) / 2,\n        u = o && c.animateScale,\n        f = u ? 0 : this.innerRadius,\n        g = u ? 0 : this.outerRadius,\n        _this$_getSharedOptio3 = this._getSharedOptions(e, n),\n        p = _this$_getSharedOptio3.sharedOptions,\n        m = _this$_getSharedOptio3.includeOptions;\n      var b = this._getRotation(),\n        x;\n      for (x = 0; x < e; ++x) b += this._circumference(x, o);\n      for (x = e; x < e + s; ++x) {\n        var v = this._circumference(x, o),\n          y = t[x],\n          _ = {\n            x: h + this.offsetX,\n            y: d + this.offsetY,\n            startAngle: b,\n            endAngle: b + v,\n            circumference: v,\n            outerRadius: g,\n            innerRadius: f\n          };\n        m && (_.options = p || this.resolveDataElementOptions(x, y.active ? \"active\" : n)), b += v, this.updateElement(y, x, _, n);\n      }\n    }\n  }, {\n    key: \"calculateTotal\",\n    value: function calculateTotal() {\n      var t = this._cachedMeta,\n        e = t.data;\n      var s = 0,\n        n;\n      for (n = 0; n < e.length; n++) {\n        var o = t._parsed[n];\n        o !== null && !isNaN(o) && this.chart.getDataVisibility(n) && !e[n].hidden && (s += Math.abs(o));\n      }\n      return s;\n    }\n  }, {\n    key: \"calculateCircumference\",\n    value: function calculateCircumference(t) {\n      var e = this._cachedMeta.total;\n      return e > 0 && !isNaN(t) ? F * (Math.abs(t) / e) : 0;\n    }\n  }, {\n    key: \"getLabelAndValue\",\n    value: function getLabelAndValue(t) {\n      var e = this._cachedMeta,\n        s = this.chart,\n        n = s.data.labels || [],\n        o = de(e._parsed[t], s.options.locale);\n      return {\n        label: n[t] || \"\",\n        value: o\n      };\n    }\n  }, {\n    key: \"getMaxBorderWidth\",\n    value: function getMaxBorderWidth(t) {\n      var e = 0;\n      var s = this.chart;\n      var n, o, r, a, l;\n      if (!t) {\n        for (n = 0, o = s.data.datasets.length; n < o; ++n) if (s.isDatasetVisible(n)) {\n          r = s.getDatasetMeta(n), t = r.data, a = r.controller;\n          break;\n        }\n      }\n      if (!t) return 0;\n      for (n = 0, o = t.length; n < o; ++n) l = a.resolveDataElementOptions(n), l.borderAlign !== \"inner\" && (e = Math.max(e, l.borderWidth || 0, l.hoverBorderWidth || 0));\n      return e;\n    }\n  }, {\n    key: \"getMaxOffset\",\n    value: function getMaxOffset(t) {\n      var e = 0;\n      for (var s = 0, n = t.length; s < n; ++s) {\n        var o = this.resolveDataElementOptions(s);\n        e = Math.max(e, o.offset || 0, o.hoverOffset || 0);\n      }\n      return e;\n    }\n  }, {\n    key: \"_getRingWeightOffset\",\n    value: function _getRingWeightOffset(t) {\n      var e = 0;\n      for (var s = 0; s < t; ++s) this.chart.isDatasetVisible(s) && (e += this._getRingWeight(s));\n      return e;\n    }\n  }, {\n    key: \"_getRingWeight\",\n    value: function _getRingWeight(t) {\n      return Math.max(C(this.chart.data.datasets[t].weight, 1), 0);\n    }\n  }, {\n    key: \"_getVisibleDatasetWeightTotal\",\n    value: function _getVisibleDatasetWeightTotal() {\n      return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n    }\n  }]);\n  return Lt;\n}(it);\nLt.id = \"doughnut\";\nLt.defaults = {\n  datasetElementType: !1,\n  dataElementType: \"arc\",\n  animation: {\n    animateRotate: !0,\n    animateScale: !1\n  },\n  animations: {\n    numbers: {\n      type: \"number\",\n      properties: [\"circumference\", \"endAngle\", \"innerRadius\", \"outerRadius\", \"startAngle\", \"x\", \"y\", \"offset\", \"borderWidth\", \"spacing\"]\n    }\n  },\n  cutout: \"50%\",\n  rotation: 0,\n  circumference: 360,\n  radius: \"100%\",\n  spacing: 0,\n  indexAxis: \"r\"\n};\nLt.descriptors = {\n  _scriptable: function _scriptable(i) {\n    return i !== \"spacing\";\n  },\n  _indexable: function _indexable(i) {\n    return i !== \"spacing\";\n  }\n};\nLt.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels: function generateLabels(i) {\n          var t = i.data;\n          if (t.labels.length && t.datasets.length) {\n            var e = i.legend.options.labels.pointStyle;\n            return t.labels.map(function (s, n) {\n              var r = i.getDatasetMeta(0).controller.getStyle(n);\n              return {\n                text: s,\n                fillStyle: r.backgroundColor,\n                strokeStyle: r.borderColor,\n                lineWidth: r.borderWidth,\n                pointStyle: e,\n                hidden: !i.getDataVisibility(n),\n                index: n\n              };\n            });\n          }\n          return [];\n        }\n      },\n      onClick: function onClick(i, t, e) {\n        e.chart.toggleDataVisibility(t.index), e.chart.update();\n      }\n    },\n    tooltip: {\n      callbacks: {\n        title: function title() {\n          return \"\";\n        },\n        label: function label(i) {\n          var t = i.label;\n          var e = \": \" + i.formattedValue;\n          return z(t) ? (t = t.slice(), t[0] += e) : t += e, t;\n        }\n      }\n    }\n  }\n};\nvar ge = /*#__PURE__*/function (_it4) {\n  _inherits(ge, _it4);\n  var _super4 = _createSuper(ge);\n  function ge() {\n    _classCallCheck(this, ge);\n    return _super4.apply(this, arguments);\n  }\n  _createClass(ge, [{\n    key: \"initialize\",\n    value: function initialize() {\n      this.enableOptionSharing = !0, this.supportsDecimation = !0, _get(_getPrototypeOf(ge.prototype), \"initialize\", this).call(this);\n    }\n  }, {\n    key: \"update\",\n    value: function update(t) {\n      var e = this._cachedMeta,\n        s = e.dataset,\n        _e$data = e.data,\n        n = _e$data === void 0 ? [] : _e$data,\n        o = e._dataset,\n        r = this.chart._animationsDisabled;\n      var _pn = pn(e, n, r),\n        a = _pn.start,\n        l = _pn.count;\n      this._drawStart = a, this._drawCount = l, mn(e) && (a = 0, l = n.length), s._chart = this.chart, s._datasetIndex = this.index, s._decimated = !!o._decimated, s.points = n;\n      var c = this.resolveDatasetElementOptions(t);\n      this.options.showLine || (c.borderWidth = 0), c.segment = this.options.segment, this.updateElement(s, void 0, {\n        animated: !r,\n        options: c\n      }, t), this.updateElements(n, a, l, t);\n    }\n  }, {\n    key: \"updateElements\",\n    value: function updateElements(t, e, s, n) {\n      var o = n === \"reset\",\n        _this$_cachedMeta3 = this._cachedMeta,\n        r = _this$_cachedMeta3.iScale,\n        a = _this$_cachedMeta3.vScale,\n        l = _this$_cachedMeta3._stacked,\n        c = _this$_cachedMeta3._dataset,\n        _this$_getSharedOptio4 = this._getSharedOptions(e, n),\n        h = _this$_getSharedOptio4.sharedOptions,\n        d = _this$_getSharedOptio4.includeOptions,\n        u = r.axis,\n        f = a.axis,\n        _this$options2 = this.options,\n        g = _this$options2.spanGaps,\n        p = _this$options2.segment,\n        m = Bt(g) ? g : Number.POSITIVE_INFINITY,\n        b = this.chart._animationsDisabled || o || n === \"none\";\n      var x = e > 0 && this.getParsed(e - 1);\n      for (var v = e; v < e + s; ++v) {\n        var y = t[v],\n          _ = this.getParsed(v),\n          M = b ? y : {},\n          k = T(_[f]),\n          S = M[u] = r.getPixelForValue(_[u], v),\n          w = M[f] = o || k ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, _, l) : _[f], v);\n        M.skip = isNaN(S) || isNaN(w) || k, M.stop = v > 0 && Math.abs(_[u] - x[u]) > m, p && (M.parsed = _, M.raw = c.data[v]), d && (M.options = h || this.resolveDataElementOptions(v, y.active ? \"active\" : n)), b || this.updateElement(y, v, M, n), x = _;\n      }\n    }\n  }, {\n    key: \"getMaxOverflow\",\n    value: function getMaxOverflow() {\n      var t = this._cachedMeta,\n        e = t.dataset,\n        s = e.options && e.options.borderWidth || 0,\n        n = t.data || [];\n      if (!n.length) return s;\n      var o = n[0].size(this.resolveDataElementOptions(0)),\n        r = n[n.length - 1].size(this.resolveDataElementOptions(n.length - 1));\n      return Math.max(s, o, r) / 2;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var t = this._cachedMeta;\n      t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), _get(_getPrototypeOf(ge.prototype), \"draw\", this).call(this);\n    }\n  }]);\n  return ge;\n}(it);\nge.id = \"line\";\nge.defaults = {\n  datasetElementType: \"line\",\n  dataElementType: \"point\",\n  showLine: !0,\n  spanGaps: !1\n};\nge.overrides = {\n  scales: {\n    _index_: {\n      type: \"category\"\n    },\n    _value_: {\n      type: \"linear\"\n    }\n  }\n};\nvar pe = /*#__PURE__*/function (_it5) {\n  _inherits(pe, _it5);\n  var _super5 = _createSuper(pe);\n  function pe(t, e) {\n    var _this5;\n    _classCallCheck(this, pe);\n    _this5 = _super5.call(this, t, e), _this5.innerRadius = void 0, _this5.outerRadius = void 0;\n    return _this5;\n  }\n  _createClass(pe, [{\n    key: \"getLabelAndValue\",\n    value: function getLabelAndValue(t) {\n      var e = this._cachedMeta,\n        s = this.chart,\n        n = s.data.labels || [],\n        o = de(e._parsed[t].r, s.options.locale);\n      return {\n        label: n[t] || \"\",\n        value: o\n      };\n    }\n  }, {\n    key: \"parseObjectData\",\n    value: function parseObjectData(t, e, s, n) {\n      return Dn.bind(this)(t, e, s, n);\n    }\n  }, {\n    key: \"update\",\n    value: function update(t) {\n      var e = this._cachedMeta.data;\n      this._updateRadius(), this.updateElements(e, 0, e.length, t);\n    }\n  }, {\n    key: \"getMinMax\",\n    value: function getMinMax() {\n      var _this6 = this;\n      var t = this._cachedMeta,\n        e = {\n          min: Number.POSITIVE_INFINITY,\n          max: Number.NEGATIVE_INFINITY\n        };\n      return t.data.forEach(function (s, n) {\n        var o = _this6.getParsed(n).r;\n        !isNaN(o) && _this6.chart.getDataVisibility(n) && (o < e.min && (e.min = o), o > e.max && (e.max = o));\n      }), e;\n    }\n  }, {\n    key: \"_updateRadius\",\n    value: function _updateRadius() {\n      var t = this.chart,\n        e = t.chartArea,\n        s = t.options,\n        n = Math.min(e.right - e.left, e.bottom - e.top),\n        o = Math.max(n / 2, 0),\n        r = Math.max(s.cutoutPercentage ? o / 100 * s.cutoutPercentage : 1, 0),\n        a = (o - r) / t.getVisibleDatasetCount();\n      this.outerRadius = o - a * this.index, this.innerRadius = this.outerRadius - a;\n    }\n  }, {\n    key: \"updateElements\",\n    value: function updateElements(t, e, s, n) {\n      var o = n === \"reset\",\n        r = this.chart,\n        l = r.options.animation,\n        c = this._cachedMeta.rScale,\n        h = c.xCenter,\n        d = c.yCenter,\n        u = c.getIndexAngle(0) - 0.5 * B;\n      var f = u,\n        g;\n      var p = 360 / this.countVisibleElements();\n      for (g = 0; g < e; ++g) f += this._computeAngle(g, n, p);\n      for (g = e; g < e + s; g++) {\n        var m = t[g];\n        var b = f,\n          x = f + this._computeAngle(g, n, p),\n          v = r.getDataVisibility(g) ? c.getDistanceFromCenterForValue(this.getParsed(g).r) : 0;\n        f = x, o && (l.animateScale && (v = 0), l.animateRotate && (b = x = u));\n        var y = {\n          x: h,\n          y: d,\n          innerRadius: 0,\n          outerRadius: v,\n          startAngle: b,\n          endAngle: x,\n          options: this.resolveDataElementOptions(g, m.active ? \"active\" : n)\n        };\n        this.updateElement(m, g, y, n);\n      }\n    }\n  }, {\n    key: \"countVisibleElements\",\n    value: function countVisibleElements() {\n      var _this7 = this;\n      var t = this._cachedMeta;\n      var e = 0;\n      return t.data.forEach(function (s, n) {\n        !isNaN(_this7.getParsed(n).r) && _this7.chart.getDataVisibility(n) && e++;\n      }), e;\n    }\n  }, {\n    key: \"_computeAngle\",\n    value: function _computeAngle(t, e, s) {\n      return this.chart.getDataVisibility(t) ? nt(this.resolveDataElementOptions(t, e).angle || s) : 0;\n    }\n  }]);\n  return pe;\n}(it);\npe.id = \"polarArea\";\npe.defaults = {\n  dataElementType: \"arc\",\n  animation: {\n    animateRotate: !0,\n    animateScale: !0\n  },\n  animations: {\n    numbers: {\n      type: \"number\",\n      properties: [\"x\", \"y\", \"startAngle\", \"endAngle\", \"innerRadius\", \"outerRadius\"]\n    }\n  },\n  indexAxis: \"r\",\n  startAngle: 0\n};\npe.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels: function generateLabels(i) {\n          var t = i.data;\n          if (t.labels.length && t.datasets.length) {\n            var e = i.legend.options.labels.pointStyle;\n            return t.labels.map(function (s, n) {\n              var r = i.getDatasetMeta(0).controller.getStyle(n);\n              return {\n                text: s,\n                fillStyle: r.backgroundColor,\n                strokeStyle: r.borderColor,\n                lineWidth: r.borderWidth,\n                pointStyle: e,\n                hidden: !i.getDataVisibility(n),\n                index: n\n              };\n            });\n          }\n          return [];\n        }\n      },\n      onClick: function onClick(i, t, e) {\n        e.chart.toggleDataVisibility(t.index), e.chart.update();\n      }\n    },\n    tooltip: {\n      callbacks: {\n        title: function title() {\n          return \"\";\n        },\n        label: function label(i) {\n          return i.chart.data.labels[i.dataIndex] + \": \" + i.formattedValue;\n        }\n      }\n    }\n  },\n  scales: {\n    r: {\n      type: \"radialLinear\",\n      angleLines: {\n        display: !1\n      },\n      beginAtZero: !0,\n      grid: {\n        circular: !0\n      },\n      pointLabels: {\n        display: !1\n      },\n      startAngle: 0\n    }\n  }\n};\nvar qe = /*#__PURE__*/function (_Lt) {\n  _inherits(qe, _Lt);\n  var _super6 = _createSuper(qe);\n  function qe() {\n    _classCallCheck(this, qe);\n    return _super6.apply(this, arguments);\n  }\n  return _createClass(qe);\n}(Lt);\nqe.id = \"pie\";\nqe.defaults = {\n  cutout: 0,\n  rotation: 0,\n  circumference: 360,\n  radius: \"100%\"\n};\nvar me = /*#__PURE__*/function (_it6) {\n  _inherits(me, _it6);\n  var _super7 = _createSuper(me);\n  function me() {\n    _classCallCheck(this, me);\n    return _super7.apply(this, arguments);\n  }\n  _createClass(me, [{\n    key: \"getLabelAndValue\",\n    value: function getLabelAndValue(t) {\n      var e = this._cachedMeta.vScale,\n        s = this.getParsed(t);\n      return {\n        label: e.getLabels()[t],\n        value: \"\" + e.getLabelForValue(s[e.axis])\n      };\n    }\n  }, {\n    key: \"parseObjectData\",\n    value: function parseObjectData(t, e, s, n) {\n      return Dn.bind(this)(t, e, s, n);\n    }\n  }, {\n    key: \"update\",\n    value: function update(t) {\n      var e = this._cachedMeta,\n        s = e.dataset,\n        n = e.data || [],\n        o = e.iScale.getLabels();\n      if (s.points = n, t !== \"resize\") {\n        var r = this.resolveDatasetElementOptions(t);\n        this.options.showLine || (r.borderWidth = 0);\n        var a = {\n          _loop: !0,\n          _fullLoop: o.length === n.length,\n          options: r\n        };\n        this.updateElement(s, void 0, a, t);\n      }\n      this.updateElements(n, 0, n.length, t);\n    }\n  }, {\n    key: \"updateElements\",\n    value: function updateElements(t, e, s, n) {\n      var o = this._cachedMeta.rScale,\n        r = n === \"reset\";\n      for (var a = e; a < e + s; a++) {\n        var l = t[a],\n          c = this.resolveDataElementOptions(a, l.active ? \"active\" : n),\n          h = o.getPointPositionForValue(a, this.getParsed(a).r),\n          d = r ? o.xCenter : h.x,\n          u = r ? o.yCenter : h.y,\n          f = {\n            x: d,\n            y: u,\n            angle: h.angle,\n            skip: isNaN(d) || isNaN(u),\n            options: c\n          };\n        this.updateElement(l, a, f, n);\n      }\n    }\n  }]);\n  return me;\n}(it);\nme.id = \"radar\";\nme.defaults = {\n  datasetElementType: \"line\",\n  dataElementType: \"point\",\n  indexAxis: \"r\",\n  showLine: !0,\n  elements: {\n    line: {\n      fill: \"start\"\n    }\n  }\n};\nme.overrides = {\n  aspectRatio: 1,\n  scales: {\n    r: {\n      type: \"radialLinear\"\n    }\n  }\n};\nvar st = /*#__PURE__*/function () {\n  function st() {\n    _classCallCheck(this, st);\n    this.x = void 0, this.y = void 0, this.active = !1, this.options = void 0, this.$animations = void 0;\n  }\n  _createClass(st, [{\n    key: \"tooltipPosition\",\n    value: function tooltipPosition(t) {\n      var _this$getProps = this.getProps([\"x\", \"y\"], t),\n        e = _this$getProps.x,\n        s = _this$getProps.y;\n      return {\n        x: e,\n        y: s\n      };\n    }\n  }, {\n    key: \"hasValue\",\n    value: function hasValue() {\n      return Bt(this.x) && Bt(this.y);\n    }\n  }, {\n    key: \"getProps\",\n    value: function getProps(t, e) {\n      var _this8 = this;\n      var s = this.$animations;\n      if (!e || !s) return this;\n      var n = {};\n      return t.forEach(function (o) {\n        n[o] = s[o] && s[o].active() ? s[o]._to : _this8[o];\n      }), n;\n    }\n  }]);\n  return st;\n}();\nst.defaults = {};\nst.defaultRoutes = void 0;\nvar Vn = {\n  values: function values(i) {\n    return z(i) ? i : \"\" + i;\n  },\n  numeric: function numeric(i, t, e) {\n    if (i === 0) return \"0\";\n    var s = this.chart.options.locale;\n    var n,\n      o = i;\n    if (e.length > 1) {\n      var c = Math.max(Math.abs(e[0].value), Math.abs(e[e.length - 1].value));\n      (c < 1e-4 || c > 1e15) && (n = \"scientific\"), o = wa(i, e);\n    }\n    var r = tt(Math.abs(o)),\n      a = Math.max(Math.min(-1 * Math.floor(r), 20), 0),\n      l = {\n        notation: n,\n        minimumFractionDigits: a,\n        maximumFractionDigits: a\n      };\n    return Object.assign(l, this.options.ticks.format), de(i, s, l);\n  },\n  logarithmic: function logarithmic(i, t, e) {\n    if (i === 0) return \"0\";\n    var s = i / Math.pow(10, Math.floor(tt(i)));\n    return s === 1 || s === 2 || s === 5 ? Vn.numeric.call(this, i, t, e) : \"\";\n  }\n};\nfunction wa(i, t) {\n  var e = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;\n  return Math.abs(e) >= 1 && i !== Math.floor(i) && (e = i - Math.floor(i)), e;\n}\nvar be = {\n  formatters: Vn\n};\nO.set(\"scale\", {\n  display: !0,\n  offset: !1,\n  reverse: !1,\n  beginAtZero: !1,\n  bounds: \"ticks\",\n  grace: 0,\n  grid: {\n    display: !0,\n    lineWidth: 1,\n    drawBorder: !0,\n    drawOnChartArea: !0,\n    drawTicks: !0,\n    tickLength: 8,\n    tickWidth: function tickWidth(i, t) {\n      return t.lineWidth;\n    },\n    tickColor: function tickColor(i, t) {\n      return t.color;\n    },\n    offset: !1,\n    borderDash: [],\n    borderDashOffset: 0,\n    borderWidth: 1\n  },\n  title: {\n    display: !1,\n    text: \"\",\n    padding: {\n      top: 4,\n      bottom: 4\n    }\n  },\n  ticks: {\n    minRotation: 0,\n    maxRotation: 50,\n    mirror: !1,\n    textStrokeWidth: 0,\n    textStrokeColor: \"\",\n    padding: 3,\n    display: !0,\n    autoSkip: !0,\n    autoSkipPadding: 3,\n    labelOffset: 0,\n    callback: be.formatters.values,\n    minor: {},\n    major: {},\n    align: \"center\",\n    crossAlign: \"near\",\n    showLabelBackdrop: !1,\n    backdropColor: \"rgba(255, 255, 255, 0.75)\",\n    backdropPadding: 2\n  }\n});\nO.route(\"scale.ticks\", \"color\", \"\", \"color\");\nO.route(\"scale.grid\", \"color\", \"\", \"borderColor\");\nO.route(\"scale.grid\", \"borderColor\", \"\", \"borderColor\");\nO.route(\"scale.title\", \"color\", \"\", \"color\");\nO.describe(\"scale\", {\n  _fallback: !1,\n  _scriptable: function _scriptable(i) {\n    return !i.startsWith(\"before\") && !i.startsWith(\"after\") && i !== \"callback\" && i !== \"parser\";\n  },\n  _indexable: function _indexable(i) {\n    return i !== \"borderDash\" && i !== \"tickBorderDash\";\n  }\n});\nO.describe(\"scales\", {\n  _fallback: \"scale\"\n});\nO.describe(\"scale.ticks\", {\n  _scriptable: function _scriptable(i) {\n    return i !== \"backdropPadding\" && i !== \"callback\";\n  },\n  _indexable: function _indexable(i) {\n    return i !== \"backdropPadding\";\n  }\n});\nfunction Sa(i, t) {\n  var e = i.options.ticks,\n    s = e.maxTicksLimit || Pa(i),\n    n = e.major.enabled ? Da(t) : [],\n    o = n.length,\n    r = n[0],\n    a = n[o - 1],\n    l = [];\n  if (o > s) return Oa(t, l, n, o / s), l;\n  var c = Ca(n, t, s);\n  if (o > 0) {\n    var h, d;\n    var u = o > 1 ? Math.round((a - r) / (o - 1)) : null;\n    for (Oe(t, l, c, T(u) ? 0 : r - u, r), h = 0, d = o - 1; h < d; h++) Oe(t, l, c, n[h], n[h + 1]);\n    return Oe(t, l, c, a, T(u) ? t.length : a + u), l;\n  }\n  return Oe(t, l, c), l;\n}\nfunction Pa(i) {\n  var t = i.options.offset,\n    e = i._tickSize(),\n    s = i._length / e + (t ? 0 : 1),\n    n = i._maxLength / e;\n  return Math.floor(Math.min(s, n));\n}\nfunction Ca(i, t, e) {\n  var s = Aa(i),\n    n = t.length / e;\n  if (!s) return Math.max(n, 1);\n  var o = Do(s);\n  for (var r = 0, a = o.length - 1; r < a; r++) {\n    var l = o[r];\n    if (l > n) return l;\n  }\n  return Math.max(n, 1);\n}\nfunction Da(i) {\n  var t = [];\n  var e, s;\n  for (e = 0, s = i.length; e < s; e++) i[e].major && t.push(e);\n  return t;\n}\nfunction Oa(i, t, e, s) {\n  var n = 0,\n    o = e[0],\n    r;\n  for (s = Math.ceil(s), r = 0; r < i.length; r++) r === o && (t.push(i[r]), n++, o = e[n * s]);\n}\nfunction Oe(i, t, e, s, n) {\n  var o = C(s, 0),\n    r = Math.min(C(n, i.length), i.length);\n  var a = 0,\n    l,\n    c,\n    h;\n  for (e = Math.ceil(e), n && (l = n - s, e = l / Math.floor(l / e)), h = o; h < 0;) a++, h = Math.round(o + a * e);\n  for (c = Math.max(o, 0); c < r; c++) c === h && (t.push(i[c]), a++, h = Math.round(o + a * e));\n}\nfunction Aa(i) {\n  var t = i.length;\n  var e, s;\n  if (t < 2) return !1;\n  for (s = i[0], e = 1; e < t; ++e) if (i[e] - i[e - 1] !== s) return !1;\n  return s;\n}\nvar Ta = function Ta(i) {\n    return i === \"left\" ? \"right\" : i === \"right\" ? \"left\" : i;\n  },\n  ws = function ws(i, t, e) {\n    return t === \"top\" || t === \"left\" ? i[t] + e : i[t] - e;\n  };\nfunction Ss(i, t) {\n  var e = [],\n    s = i.length / t,\n    n = i.length;\n  var o = 0;\n  for (; o < n; o += s) e.push(i[Math.floor(o)]);\n  return e;\n}\nfunction La(i, t, e) {\n  var s = i.ticks.length,\n    n = Math.min(t, s - 1),\n    o = i._startPixel,\n    r = i._endPixel,\n    a = 1e-6;\n  var l = i.getPixelForTick(n),\n    c;\n  if (!(e && (s === 1 ? c = Math.max(l - o, r - l) : t === 0 ? c = (i.getPixelForTick(1) - l) / 2 : c = (l - i.getPixelForTick(n - 1)) / 2, l += n < t ? c : -c, l < o - a || l > r + a))) return l;\n}\nfunction Ra(i, t) {\n  E(i, function (e) {\n    var s = e.gc,\n      n = s.length / 2;\n    var o;\n    if (n > t) {\n      for (o = 0; o < n; ++o) delete e.data[s[o]];\n      s.splice(0, n);\n    }\n  });\n}\nfunction Xt(i) {\n  return i.drawTicks ? i.tickLength : 0;\n}\nfunction Ps(i, t) {\n  if (!i.display) return 0;\n  var e = $(i.font, t),\n    s = K(i.padding);\n  return (z(i.text) ? i.text.length : 1) * e.lineHeight + s.height;\n}\nfunction Ea(i, t) {\n  return vt(i, {\n    scale: t,\n    type: \"scale\"\n  });\n}\nfunction Fa(i, t, e) {\n  return vt(i, {\n    tick: e,\n    index: t,\n    type: \"tick\"\n  });\n}\nfunction Ia(i, t, e) {\n  var s = Li(i);\n  return (e && t !== \"right\" || !e && t === \"right\") && (s = Ta(s)), s;\n}\nfunction za(i, t, e, s) {\n  var n = i.top,\n    o = i.left,\n    r = i.bottom,\n    a = i.right,\n    l = i.chart,\n    c = l.chartArea,\n    h = l.scales;\n  var d = 0,\n    u,\n    f,\n    g;\n  var p = r - n,\n    m = a - o;\n  if (i.isHorizontal()) {\n    if (f = U(s, o, a), D(e)) {\n      var b = Object.keys(e)[0],\n        x = e[b];\n      g = h[b].getPixelForValue(x) + p - t;\n    } else e === \"center\" ? g = (c.bottom + c.top) / 2 + p - t : g = ws(i, e, t);\n    u = a - o;\n  } else {\n    if (D(e)) {\n      var _b2 = Object.keys(e)[0],\n        _x = e[_b2];\n      f = h[_b2].getPixelForValue(_x) - m + t;\n    } else e === \"center\" ? f = (c.left + c.right) / 2 - m + t : f = ws(i, e, t);\n    g = U(s, r, n), d = e === \"left\" ? -V : V;\n  }\n  return {\n    titleX: f,\n    titleY: g,\n    maxWidth: u,\n    rotation: d\n  };\n}\nvar Mt = /*#__PURE__*/function (_st) {\n  _inherits(Mt, _st);\n  var _super8 = _createSuper(Mt);\n  function Mt(t) {\n    var _this9;\n    _classCallCheck(this, Mt);\n    _this9 = _super8.call(this), _this9.id = t.id, _this9.type = t.type, _this9.options = void 0, _this9.ctx = t.ctx, _this9.chart = t.chart, _this9.top = void 0, _this9.bottom = void 0, _this9.left = void 0, _this9.right = void 0, _this9.width = void 0, _this9.height = void 0, _this9._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, _this9.maxWidth = void 0, _this9.maxHeight = void 0, _this9.paddingTop = void 0, _this9.paddingBottom = void 0, _this9.paddingLeft = void 0, _this9.paddingRight = void 0, _this9.axis = void 0, _this9.labelRotation = void 0, _this9.min = void 0, _this9.max = void 0, _this9._range = void 0, _this9.ticks = [], _this9._gridLineItems = null, _this9._labelItems = null, _this9._labelSizes = null, _this9._length = 0, _this9._maxLength = 0, _this9._longestTextCache = {}, _this9._startPixel = void 0, _this9._endPixel = void 0, _this9._reversePixels = !1, _this9._userMax = void 0, _this9._userMin = void 0, _this9._suggestedMax = void 0, _this9._suggestedMin = void 0, _this9._ticksLength = 0, _this9._borderValue = 0, _this9._cache = {}, _this9._dataLimitsCached = !1, _this9.$context = void 0;\n    return _this9;\n  }\n  _createClass(Mt, [{\n    key: \"init\",\n    value: function init(t) {\n      this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(t, e) {\n      return t;\n    }\n  }, {\n    key: \"getUserBounds\",\n    value: function getUserBounds() {\n      var t = this._userMin,\n        e = this._userMax,\n        s = this._suggestedMin,\n        n = this._suggestedMax;\n      return t = Q(t, Number.POSITIVE_INFINITY), e = Q(e, Number.NEGATIVE_INFINITY), s = Q(s, Number.POSITIVE_INFINITY), n = Q(n, Number.NEGATIVE_INFINITY), {\n        min: Q(t, s),\n        max: Q(e, n),\n        minDefined: N(t),\n        maxDefined: N(e)\n      };\n    }\n  }, {\n    key: \"getMinMax\",\n    value: function getMinMax(t) {\n      var _this$getUserBounds = this.getUserBounds(),\n        e = _this$getUserBounds.min,\n        s = _this$getUserBounds.max,\n        n = _this$getUserBounds.minDefined,\n        o = _this$getUserBounds.maxDefined,\n        r;\n      if (n && o) return {\n        min: e,\n        max: s\n      };\n      var a = this.getMatchingVisibleMetas();\n      for (var l = 0, c = a.length; l < c; ++l) r = a[l].controller.getMinMax(this, t), n || (e = Math.min(e, r.min)), o || (s = Math.max(s, r.max));\n      return e = o && e > s ? s : e, s = n && e > s ? e : s, {\n        min: Q(e, Q(s, e)),\n        max: Q(s, Q(e, s))\n      };\n    }\n  }, {\n    key: \"getPadding\",\n    value: function getPadding() {\n      return {\n        left: this.paddingLeft || 0,\n        top: this.paddingTop || 0,\n        right: this.paddingRight || 0,\n        bottom: this.paddingBottom || 0\n      };\n    }\n  }, {\n    key: \"getTicks\",\n    value: function getTicks() {\n      return this.ticks;\n    }\n  }, {\n    key: \"getLabels\",\n    value: function getLabels() {\n      var t = this.chart.data;\n      return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];\n    }\n  }, {\n    key: \"beforeLayout\",\n    value: function beforeLayout() {\n      this._cache = {}, this._dataLimitsCached = !1;\n    }\n  }, {\n    key: \"beforeUpdate\",\n    value: function beforeUpdate() {\n      I(this.options.beforeUpdate, [this]);\n    }\n  }, {\n    key: \"update\",\n    value: function update(t, e, s) {\n      var _this$options3 = this.options,\n        n = _this$options3.beginAtZero,\n        o = _this$options3.grace,\n        r = _this$options3.ticks,\n        a = r.sampleSize;\n      this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = s = Object.assign({\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      }, s), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + s.left + s.right : this.height + s.top + s.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = mr(this, o, n), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();\n      var l = a < this.ticks.length;\n      this._convertTicksToLabels(l ? Ss(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), r.display && (r.autoSkip || r.source === \"auto\") && (this.ticks = Sa(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();\n    }\n  }, {\n    key: \"configure\",\n    value: function configure() {\n      var t = this.options.reverse,\n        e,\n        s;\n      this.isHorizontal() ? (e = this.left, s = this.right) : (e = this.top, s = this.bottom, t = !t), this._startPixel = e, this._endPixel = s, this._reversePixels = t, this._length = s - e, this._alignToPixels = this.options.alignToPixels;\n    }\n  }, {\n    key: \"afterUpdate\",\n    value: function afterUpdate() {\n      I(this.options.afterUpdate, [this]);\n    }\n  }, {\n    key: \"beforeSetDimensions\",\n    value: function beforeSetDimensions() {\n      I(this.options.beforeSetDimensions, [this]);\n    }\n  }, {\n    key: \"setDimensions\",\n    value: function setDimensions() {\n      this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;\n    }\n  }, {\n    key: \"afterSetDimensions\",\n    value: function afterSetDimensions() {\n      I(this.options.afterSetDimensions, [this]);\n    }\n  }, {\n    key: \"_callHooks\",\n    value: function _callHooks(t) {\n      this.chart.notifyPlugins(t, this.getContext()), I(this.options[t], [this]);\n    }\n  }, {\n    key: \"beforeDataLimits\",\n    value: function beforeDataLimits() {\n      this._callHooks(\"beforeDataLimits\");\n    }\n  }, {\n    key: \"determineDataLimits\",\n    value: function determineDataLimits() {}\n  }, {\n    key: \"afterDataLimits\",\n    value: function afterDataLimits() {\n      this._callHooks(\"afterDataLimits\");\n    }\n  }, {\n    key: \"beforeBuildTicks\",\n    value: function beforeBuildTicks() {\n      this._callHooks(\"beforeBuildTicks\");\n    }\n  }, {\n    key: \"buildTicks\",\n    value: function buildTicks() {\n      return [];\n    }\n  }, {\n    key: \"afterBuildTicks\",\n    value: function afterBuildTicks() {\n      this._callHooks(\"afterBuildTicks\");\n    }\n  }, {\n    key: \"beforeTickToLabelConversion\",\n    value: function beforeTickToLabelConversion() {\n      I(this.options.beforeTickToLabelConversion, [this]);\n    }\n  }, {\n    key: \"generateTickLabels\",\n    value: function generateTickLabels(t) {\n      var e = this.options.ticks;\n      var s, n, o;\n      for (s = 0, n = t.length; s < n; s++) o = t[s], o.label = I(e.callback, [o.value, s, t], this);\n    }\n  }, {\n    key: \"afterTickToLabelConversion\",\n    value: function afterTickToLabelConversion() {\n      I(this.options.afterTickToLabelConversion, [this]);\n    }\n  }, {\n    key: \"beforeCalculateLabelRotation\",\n    value: function beforeCalculateLabelRotation() {\n      I(this.options.beforeCalculateLabelRotation, [this]);\n    }\n  }, {\n    key: \"calculateLabelRotation\",\n    value: function calculateLabelRotation() {\n      var t = this.options,\n        e = t.ticks,\n        s = this.ticks.length,\n        n = e.minRotation || 0,\n        o = e.maxRotation;\n      var r = n,\n        a,\n        l,\n        c;\n      if (!this._isVisible() || !e.display || n >= o || s <= 1 || !this.isHorizontal()) {\n        this.labelRotation = n;\n        return;\n      }\n      var h = this._getLabelSizes(),\n        d = h.widest.width,\n        u = h.highest.height,\n        f = Y(this.chart.width - d, 0, this.maxWidth);\n      a = t.offset ? this.maxWidth / s : f / (s - 1), d + 6 > a && (a = f / (s - (t.offset ? 0.5 : 1)), l = this.maxHeight - Xt(t.grid) - e.padding - Ps(t.title, this.chart.options.font), c = Math.sqrt(d * d + u * u), r = Ai(Math.min(Math.asin(Y((h.highest.height + 6) / a, -1, 1)), Math.asin(Y(l / c, -1, 1)) - Math.asin(Y(u / c, -1, 1)))), r = Math.max(n, Math.min(o, r))), this.labelRotation = r;\n    }\n  }, {\n    key: \"afterCalculateLabelRotation\",\n    value: function afterCalculateLabelRotation() {\n      I(this.options.afterCalculateLabelRotation, [this]);\n    }\n  }, {\n    key: \"afterAutoSkip\",\n    value: function afterAutoSkip() {}\n  }, {\n    key: \"beforeFit\",\n    value: function beforeFit() {\n      I(this.options.beforeFit, [this]);\n    }\n  }, {\n    key: \"fit\",\n    value: function fit() {\n      var t = {\n          width: 0,\n          height: 0\n        },\n        e = this.chart,\n        _this$options4 = this.options,\n        s = _this$options4.ticks,\n        n = _this$options4.title,\n        o = _this$options4.grid,\n        r = this._isVisible(),\n        a = this.isHorizontal();\n      if (r) {\n        var l = Ps(n, e.options.font);\n        if (a ? (t.width = this.maxWidth, t.height = Xt(o) + l) : (t.height = this.maxHeight, t.width = Xt(o) + l), s.display && this.ticks.length) {\n          var _this$_getLabelSizes = this._getLabelSizes(),\n            c = _this$_getLabelSizes.first,\n            h = _this$_getLabelSizes.last,\n            d = _this$_getLabelSizes.widest,\n            u = _this$_getLabelSizes.highest,\n            f = s.padding * 2,\n            g = nt(this.labelRotation),\n            p = Math.cos(g),\n            m = Math.sin(g);\n          if (a) {\n            var b = s.mirror ? 0 : m * d.width + p * u.height;\n            t.height = Math.min(this.maxHeight, t.height + b + f);\n          } else {\n            var _b3 = s.mirror ? 0 : p * d.width + m * u.height;\n            t.width = Math.min(this.maxWidth, t.width + _b3 + f);\n          }\n          this._calculatePadding(c, h, m, p);\n        }\n      }\n      this._handleMargins(), a ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom);\n    }\n  }, {\n    key: \"_calculatePadding\",\n    value: function _calculatePadding(t, e, s, n) {\n      var _this$options5 = this.options,\n        _this$options5$ticks = _this$options5.ticks,\n        o = _this$options5$ticks.align,\n        r = _this$options5$ticks.padding,\n        a = _this$options5.position,\n        l = this.labelRotation !== 0,\n        c = a !== \"top\" && this.axis === \"x\";\n      if (this.isHorizontal()) {\n        var h = this.getPixelForTick(0) - this.left,\n          d = this.right - this.getPixelForTick(this.ticks.length - 1);\n        var u = 0,\n          f = 0;\n        l ? c ? (u = n * t.width, f = s * e.height) : (u = s * t.height, f = n * e.width) : o === \"start\" ? f = e.width : o === \"end\" ? u = t.width : o !== \"inner\" && (u = t.width / 2, f = e.width / 2), this.paddingLeft = Math.max((u - h + r) * this.width / (this.width - h), 0), this.paddingRight = Math.max((f - d + r) * this.width / (this.width - d), 0);\n      } else {\n        var _h = e.height / 2,\n          _d = t.height / 2;\n        o === \"start\" ? (_h = 0, _d = t.height) : o === \"end\" && (_h = e.height, _d = 0), this.paddingTop = _h + r, this.paddingBottom = _d + r;\n      }\n    }\n  }, {\n    key: \"_handleMargins\",\n    value: function _handleMargins() {\n      this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));\n    }\n  }, {\n    key: \"afterFit\",\n    value: function afterFit() {\n      I(this.options.afterFit, [this]);\n    }\n  }, {\n    key: \"isHorizontal\",\n    value: function isHorizontal() {\n      var _this$options6 = this.options,\n        t = _this$options6.axis,\n        e = _this$options6.position;\n      return e === \"top\" || e === \"bottom\" || t === \"x\";\n    }\n  }, {\n    key: \"isFullSize\",\n    value: function isFullSize() {\n      return this.options.fullSize;\n    }\n  }, {\n    key: \"_convertTicksToLabels\",\n    value: function _convertTicksToLabels(t) {\n      this.beforeTickToLabelConversion(), this.generateTickLabels(t);\n      var e, s;\n      for (e = 0, s = t.length; e < s; e++) T(t[e].label) && (t.splice(e, 1), s--, e--);\n      this.afterTickToLabelConversion();\n    }\n  }, {\n    key: \"_getLabelSizes\",\n    value: function _getLabelSizes() {\n      var t = this._labelSizes;\n      if (!t) {\n        var e = this.options.ticks.sampleSize;\n        var s = this.ticks;\n        e < s.length && (s = Ss(s, e)), this._labelSizes = t = this._computeLabelSizes(s, s.length);\n      }\n      return t;\n    }\n  }, {\n    key: \"_computeLabelSizes\",\n    value: function _computeLabelSizes(t, e) {\n      var s = this.ctx,\n        n = this._longestTextCache,\n        o = [],\n        r = [];\n      var a = 0,\n        l = 0,\n        c,\n        h,\n        d,\n        u,\n        f,\n        g,\n        p,\n        m,\n        b,\n        x,\n        v;\n      for (c = 0; c < e; ++c) {\n        if (u = t[c].label, f = this._resolveTickFontOptions(c), s.font = g = f.string, p = n[g] = n[g] || {\n          data: {},\n          gc: []\n        }, m = f.lineHeight, b = x = 0, !T(u) && !z(u)) b = Ne(s, p.data, p.gc, b, u), x = m;else if (z(u)) for (h = 0, d = u.length; h < d; ++h) v = u[h], !T(v) && !z(v) && (b = Ne(s, p.data, p.gc, b, v), x += m);\n        o.push(b), r.push(x), a = Math.max(b, a), l = Math.max(x, l);\n      }\n      Ra(n, e);\n      var y = o.indexOf(a),\n        _ = r.indexOf(l),\n        M = function M(k) {\n          return {\n            width: o[k] || 0,\n            height: r[k] || 0\n          };\n        };\n      return {\n        first: M(0),\n        last: M(e - 1),\n        widest: M(y),\n        highest: M(_),\n        widths: o,\n        heights: r\n      };\n    }\n  }, {\n    key: \"getLabelForValue\",\n    value: function getLabelForValue(t) {\n      return t;\n    }\n  }, {\n    key: \"getPixelForValue\",\n    value: function getPixelForValue(t, e) {\n      return NaN;\n    }\n  }, {\n    key: \"getValueForPixel\",\n    value: function getValueForPixel(t) {}\n  }, {\n    key: \"getPixelForTick\",\n    value: function getPixelForTick(t) {\n      var e = this.ticks;\n      return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);\n    }\n  }, {\n    key: \"getPixelForDecimal\",\n    value: function getPixelForDecimal(t) {\n      this._reversePixels && (t = 1 - t);\n      var e = this._startPixel + t * this._length;\n      return To(this._alignToPixels ? wt(this.chart, e, 0) : e);\n    }\n  }, {\n    key: \"getDecimalForPixel\",\n    value: function getDecimalForPixel(t) {\n      var e = (t - this._startPixel) / this._length;\n      return this._reversePixels ? 1 - e : e;\n    }\n  }, {\n    key: \"getBasePixel\",\n    value: function getBasePixel() {\n      return this.getPixelForValue(this.getBaseValue());\n    }\n  }, {\n    key: \"getBaseValue\",\n    value: function getBaseValue() {\n      var t = this.min,\n        e = this.max;\n      return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext(t) {\n      var e = this.ticks || [];\n      if (t >= 0 && t < e.length) {\n        var s = e[t];\n        return s.$context || (s.$context = Fa(this.getContext(), t, s));\n      }\n      return this.$context || (this.$context = Ea(this.chart.getContext(), this));\n    }\n  }, {\n    key: \"_tickSize\",\n    value: function _tickSize() {\n      var t = this.options.ticks,\n        e = nt(this.labelRotation),\n        s = Math.abs(Math.cos(e)),\n        n = Math.abs(Math.sin(e)),\n        o = this._getLabelSizes(),\n        r = t.autoSkipPadding || 0,\n        a = o ? o.widest.width + r : 0,\n        l = o ? o.highest.height + r : 0;\n      return this.isHorizontal() ? l * s > a * n ? a / s : l / n : l * n < a * s ? l / s : a / n;\n    }\n  }, {\n    key: \"_isVisible\",\n    value: function _isVisible() {\n      var t = this.options.display;\n      return t !== \"auto\" ? !!t : this.getMatchingVisibleMetas().length > 0;\n    }\n  }, {\n    key: \"_computeGridLineItems\",\n    value: function _computeGridLineItems(t) {\n      var e = this.axis,\n        s = this.chart,\n        n = this.options,\n        o = n.grid,\n        r = n.position,\n        a = o.offset,\n        l = this.isHorizontal(),\n        h = this.ticks.length + (a ? 1 : 0),\n        d = Xt(o),\n        u = [],\n        f = o.setContext(this.getContext()),\n        g = f.drawBorder ? f.borderWidth : 0,\n        p = g / 2,\n        m = function m(P) {\n          return wt(s, P, g);\n        };\n      var b, x, v, y, _, M, k, S, w, L, R, A;\n      if (r === \"top\") b = m(this.bottom), M = this.bottom - d, S = b - p, L = m(t.top) + p, A = t.bottom;else if (r === \"bottom\") b = m(this.top), L = t.top, A = m(t.bottom) - p, M = b + p, S = this.top + d;else if (r === \"left\") b = m(this.right), _ = this.right - d, k = b - p, w = m(t.left) + p, R = t.right;else if (r === \"right\") b = m(this.left), w = t.left, R = m(t.right) - p, _ = b + p, k = this.left + d;else if (e === \"x\") {\n        if (r === \"center\") b = m((t.top + t.bottom) / 2 + 0.5);else if (D(r)) {\n          var P = Object.keys(r)[0],\n            j = r[P];\n          b = m(this.chart.scales[P].getPixelForValue(j));\n        }\n        L = t.top, A = t.bottom, M = b + p, S = M + d;\n      } else if (e === \"y\") {\n        if (r === \"center\") b = m((t.left + t.right) / 2);else if (D(r)) {\n          var _P = Object.keys(r)[0],\n            _j = r[_P];\n          b = m(this.chart.scales[_P].getPixelForValue(_j));\n        }\n        _ = b - p, k = _ - d, w = t.left, R = t.right;\n      }\n      var H = C(n.ticks.maxTicksLimit, h),\n        q = Math.max(1, Math.ceil(h / H));\n      for (x = 0; x < h; x += q) {\n        var _P2 = o.setContext(this.getContext(x)),\n          _j2 = _P2.lineWidth,\n          W = _P2.color,\n          kt = _P2.borderDash || [],\n          ti = _P2.borderDashOffset,\n          Rt = _P2.tickWidth,\n          ke = _P2.tickColor,\n          Et = _P2.tickBorderDash || [],\n          jt = _P2.tickBorderDashOffset;\n        v = La(this, x, a), v !== void 0 && (y = wt(s, v, _j2), l ? _ = k = w = R = y : M = S = L = A = y, u.push({\n          tx1: _,\n          ty1: M,\n          tx2: k,\n          ty2: S,\n          x1: w,\n          y1: L,\n          x2: R,\n          y2: A,\n          width: _j2,\n          color: W,\n          borderDash: kt,\n          borderDashOffset: ti,\n          tickWidth: Rt,\n          tickColor: ke,\n          tickBorderDash: Et,\n          tickBorderDashOffset: jt\n        }));\n      }\n      return this._ticksLength = h, this._borderValue = b, u;\n    }\n  }, {\n    key: \"_computeLabelItems\",\n    value: function _computeLabelItems(t) {\n      var e = this.axis,\n        s = this.options,\n        n = s.position,\n        o = s.ticks,\n        r = this.isHorizontal(),\n        a = this.ticks,\n        l = o.align,\n        c = o.crossAlign,\n        h = o.padding,\n        d = o.mirror,\n        u = Xt(s.grid),\n        f = u + h,\n        g = d ? -h : f,\n        p = -nt(this.labelRotation),\n        m = [];\n      var b,\n        x,\n        v,\n        y,\n        _,\n        M,\n        k,\n        S,\n        w,\n        L,\n        R,\n        A,\n        H = \"middle\";\n      if (n === \"top\") M = this.bottom - g, k = this._getXAxisLabelAlignment();else if (n === \"bottom\") M = this.top + g, k = this._getXAxisLabelAlignment();else if (n === \"left\") {\n        var P = this._getYAxisLabelAlignment(u);\n        k = P.textAlign, _ = P.x;\n      } else if (n === \"right\") {\n        var _P3 = this._getYAxisLabelAlignment(u);\n        k = _P3.textAlign, _ = _P3.x;\n      } else if (e === \"x\") {\n        if (n === \"center\") M = (t.top + t.bottom) / 2 + f;else if (D(n)) {\n          var _P4 = Object.keys(n)[0],\n            j = n[_P4];\n          M = this.chart.scales[_P4].getPixelForValue(j) + f;\n        }\n        k = this._getXAxisLabelAlignment();\n      } else if (e === \"y\") {\n        if (n === \"center\") _ = (t.left + t.right) / 2 - f;else if (D(n)) {\n          var _P5 = Object.keys(n)[0],\n            _j3 = n[_P5];\n          _ = this.chart.scales[_P5].getPixelForValue(_j3);\n        }\n        k = this._getYAxisLabelAlignment(u).textAlign;\n      }\n      e === \"y\" && (l === \"start\" ? H = \"top\" : l === \"end\" && (H = \"bottom\"));\n      var q = this._getLabelSizes();\n      for (b = 0, x = a.length; b < x; ++b) {\n        v = a[b], y = v.label;\n        var _P6 = o.setContext(this.getContext(b));\n        S = this.getPixelForTick(b) + o.labelOffset, w = this._resolveTickFontOptions(b), L = w.lineHeight, R = z(y) ? y.length : 1;\n        var _j4 = R / 2,\n          W = _P6.color,\n          kt = _P6.textStrokeColor,\n          ti = _P6.textStrokeWidth;\n        var Rt = k;\n        r ? (_ = S, k === \"inner\" && (b === x - 1 ? Rt = this.options.reverse ? \"left\" : \"right\" : b === 0 ? Rt = this.options.reverse ? \"right\" : \"left\" : Rt = \"center\"), n === \"top\" ? c === \"near\" || p !== 0 ? A = -R * L + L / 2 : c === \"center\" ? A = -q.highest.height / 2 - _j4 * L + L : A = -q.highest.height + L / 2 : c === \"near\" || p !== 0 ? A = L / 2 : c === \"center\" ? A = q.highest.height / 2 - _j4 * L : A = q.highest.height - R * L, d && (A *= -1)) : (M = S, A = (1 - R) * L / 2);\n        var ke = void 0;\n        if (_P6.showLabelBackdrop) {\n          var Et = K(_P6.backdropPadding),\n            jt = q.heights[b],\n            ei = q.widths[b];\n          var ii = M + A - Et.top,\n            si = _ - Et.left;\n          switch (H) {\n            case \"middle\":\n              ii -= jt / 2;\n              break;\n            case \"bottom\":\n              ii -= jt;\n              break;\n          }\n          switch (k) {\n            case \"center\":\n              si -= ei / 2;\n              break;\n            case \"right\":\n              si -= ei;\n              break;\n          }\n          ke = {\n            left: si,\n            top: ii,\n            width: ei + Et.width,\n            height: jt + Et.height,\n            color: _P6.backdropColor\n          };\n        }\n        m.push({\n          rotation: p,\n          label: y,\n          font: w,\n          color: W,\n          strokeColor: kt,\n          strokeWidth: ti,\n          textOffset: A,\n          textAlign: Rt,\n          textBaseline: H,\n          translation: [_, M],\n          backdrop: ke\n        });\n      }\n      return m;\n    }\n  }, {\n    key: \"_getXAxisLabelAlignment\",\n    value: function _getXAxisLabelAlignment() {\n      var _this$options7 = this.options,\n        t = _this$options7.position,\n        e = _this$options7.ticks;\n      if (-nt(this.labelRotation)) return t === \"top\" ? \"left\" : \"right\";\n      var n = \"center\";\n      return e.align === \"start\" ? n = \"left\" : e.align === \"end\" ? n = \"right\" : e.align === \"inner\" && (n = \"inner\"), n;\n    }\n  }, {\n    key: \"_getYAxisLabelAlignment\",\n    value: function _getYAxisLabelAlignment(t) {\n      var _this$options8 = this.options,\n        e = _this$options8.position,\n        _this$options8$ticks = _this$options8.ticks,\n        s = _this$options8$ticks.crossAlign,\n        n = _this$options8$ticks.mirror,\n        o = _this$options8$ticks.padding,\n        r = this._getLabelSizes(),\n        a = t + o,\n        l = r.widest.width;\n      var c, h;\n      return e === \"left\" ? n ? (h = this.right + o, s === \"near\" ? c = \"left\" : s === \"center\" ? (c = \"center\", h += l / 2) : (c = \"right\", h += l)) : (h = this.right - a, s === \"near\" ? c = \"right\" : s === \"center\" ? (c = \"center\", h -= l / 2) : (c = \"left\", h = this.left)) : e === \"right\" ? n ? (h = this.left + o, s === \"near\" ? c = \"right\" : s === \"center\" ? (c = \"center\", h -= l / 2) : (c = \"left\", h -= l)) : (h = this.left + a, s === \"near\" ? c = \"left\" : s === \"center\" ? (c = \"center\", h += l / 2) : (c = \"right\", h = this.right)) : c = \"right\", {\n        textAlign: c,\n        x: h\n      };\n    }\n  }, {\n    key: \"_computeLabelArea\",\n    value: function _computeLabelArea() {\n      if (this.options.ticks.mirror) return;\n      var t = this.chart,\n        e = this.options.position;\n      if (e === \"left\" || e === \"right\") return {\n        top: 0,\n        left: this.left,\n        bottom: t.height,\n        right: this.right\n      };\n      if (e === \"top\" || e === \"bottom\") return {\n        top: this.top,\n        left: 0,\n        bottom: this.bottom,\n        right: t.width\n      };\n    }\n  }, {\n    key: \"drawBackground\",\n    value: function drawBackground() {\n      var t = this.ctx,\n        e = this.options.backgroundColor,\n        s = this.left,\n        n = this.top,\n        o = this.width,\n        r = this.height;\n      e && (t.save(), t.fillStyle = e, t.fillRect(s, n, o, r), t.restore());\n    }\n  }, {\n    key: \"getLineWidthForValue\",\n    value: function getLineWidthForValue(t) {\n      var e = this.options.grid;\n      if (!this._isVisible() || !e.display) return 0;\n      var n = this.ticks.findIndex(function (o) {\n        return o.value === t;\n      });\n      return n >= 0 ? e.setContext(this.getContext(n)).lineWidth : 0;\n    }\n  }, {\n    key: \"drawGrid\",\n    value: function drawGrid(t) {\n      var e = this.options.grid,\n        s = this.ctx,\n        n = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));\n      var o, r;\n      var a = function a(l, c, h) {\n        !h.width || !h.color || (s.save(), s.lineWidth = h.width, s.strokeStyle = h.color, s.setLineDash(h.borderDash || []), s.lineDashOffset = h.borderDashOffset, s.beginPath(), s.moveTo(l.x, l.y), s.lineTo(c.x, c.y), s.stroke(), s.restore());\n      };\n      if (e.display) for (o = 0, r = n.length; o < r; ++o) {\n        var l = n[o];\n        e.drawOnChartArea && a({\n          x: l.x1,\n          y: l.y1\n        }, {\n          x: l.x2,\n          y: l.y2\n        }, l), e.drawTicks && a({\n          x: l.tx1,\n          y: l.ty1\n        }, {\n          x: l.tx2,\n          y: l.ty2\n        }, {\n          color: l.tickColor,\n          width: l.tickWidth,\n          borderDash: l.tickBorderDash,\n          borderDashOffset: l.tickBorderDashOffset\n        });\n      }\n    }\n  }, {\n    key: \"drawBorder\",\n    value: function drawBorder() {\n      var t = this.chart,\n        e = this.ctx,\n        s = this.options.grid,\n        n = s.setContext(this.getContext()),\n        o = s.drawBorder ? n.borderWidth : 0;\n      if (!o) return;\n      var r = s.setContext(this.getContext(0)).lineWidth,\n        a = this._borderValue;\n      var l, c, h, d;\n      this.isHorizontal() ? (l = wt(t, this.left, o) - o / 2, c = wt(t, this.right, r) + r / 2, h = d = a) : (h = wt(t, this.top, o) - o / 2, d = wt(t, this.bottom, r) + r / 2, l = c = a), e.save(), e.lineWidth = n.borderWidth, e.strokeStyle = n.borderColor, e.beginPath(), e.moveTo(l, h), e.lineTo(c, d), e.stroke(), e.restore();\n    }\n  }, {\n    key: \"drawLabels\",\n    value: function drawLabels(t) {\n      if (!this.options.ticks.display) return;\n      var s = this.ctx,\n        n = this._computeLabelArea();\n      n && Xe(s, n);\n      var o = this._labelItems || (this._labelItems = this._computeLabelItems(t));\n      var r, a;\n      for (r = 0, a = o.length; r < a; ++r) {\n        var l = o[r],\n          c = l.font,\n          h = l.label;\n        l.backdrop && (s.fillStyle = l.backdrop.color, s.fillRect(l.backdrop.left, l.backdrop.top, l.backdrop.width, l.backdrop.height));\n        var d = l.textOffset;\n        Tt(s, h, 0, d, c, l);\n      }\n      n && Ue(s);\n    }\n  }, {\n    key: \"drawTitle\",\n    value: function drawTitle() {\n      var t = this.ctx,\n        _this$options9 = this.options,\n        e = _this$options9.position,\n        s = _this$options9.title,\n        n = _this$options9.reverse;\n      if (!s.display) return;\n      var o = $(s.font),\n        r = K(s.padding),\n        a = s.align;\n      var l = o.lineHeight / 2;\n      e === \"bottom\" || e === \"center\" || D(e) ? (l += r.bottom, z(s.text) && (l += o.lineHeight * (s.text.length - 1))) : l += r.top;\n      var _za = za(this, l, e, a),\n        c = _za.titleX,\n        h = _za.titleY,\n        d = _za.maxWidth,\n        u = _za.rotation;\n      Tt(t, s.text, 0, 0, o, {\n        color: s.color,\n        maxWidth: d,\n        rotation: u,\n        textAlign: Ia(a, e, n),\n        textBaseline: \"middle\",\n        translation: [c, h]\n      });\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(t) {\n      this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));\n    }\n  }, {\n    key: \"_layers\",\n    value: function _layers() {\n      var _this10 = this;\n      var t = this.options,\n        e = t.ticks && t.ticks.z || 0,\n        s = C(t.grid && t.grid.z, -1);\n      return !this._isVisible() || this.draw !== Mt.prototype.draw ? [{\n        z: e,\n        draw: function draw(n) {\n          _this10.draw(n);\n        }\n      }] : [{\n        z: s,\n        draw: function draw(n) {\n          _this10.drawBackground(), _this10.drawGrid(n), _this10.drawTitle();\n        }\n      }, {\n        z: s + 1,\n        draw: function draw() {\n          _this10.drawBorder();\n        }\n      }, {\n        z: e,\n        draw: function draw(n) {\n          _this10.drawLabels(n);\n        }\n      }];\n    }\n  }, {\n    key: \"getMatchingVisibleMetas\",\n    value: function getMatchingVisibleMetas(t) {\n      var e = this.chart.getSortedVisibleDatasetMetas(),\n        s = this.axis + \"AxisID\",\n        n = [];\n      var o, r;\n      for (o = 0, r = e.length; o < r; ++o) {\n        var a = e[o];\n        a[s] === this.id && (!t || a.type === t) && n.push(a);\n      }\n      return n;\n    }\n  }, {\n    key: \"_resolveTickFontOptions\",\n    value: function _resolveTickFontOptions(t) {\n      var e = this.options.ticks.setContext(this.getContext(t));\n      return $(e.font);\n    }\n  }, {\n    key: \"_maxDigits\",\n    value: function _maxDigits() {\n      var t = this._resolveTickFontOptions(0).lineHeight;\n      return (this.isHorizontal() ? this.width : this.height) / t;\n    }\n  }]);\n  return Mt;\n}(st);\nvar Ae = /*#__PURE__*/function () {\n  function Ae(t, e, s) {\n    _classCallCheck(this, Ae);\n    this.type = t, this.scope = e, this.override = s, this.items = /* @__PURE__ */Object.create(null);\n  }\n  _createClass(Ae, [{\n    key: \"isForType\",\n    value: function isForType(t) {\n      return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);\n    }\n  }, {\n    key: \"register\",\n    value: function register(t) {\n      var e = Object.getPrototypeOf(t);\n      var s;\n      Wa(e) && (s = this.register(e));\n      var n = this.items,\n        o = t.id,\n        r = this.scope + \".\" + o;\n      if (!o) throw new Error(\"class does not have id: \" + t);\n      return o in n || (n[o] = t, Ba(t, r, s), this.override && O.override(t.id, t.overrides)), r;\n    }\n  }, {\n    key: \"get\",\n    value: function get(t) {\n      return this.items[t];\n    }\n  }, {\n    key: \"unregister\",\n    value: function unregister(t) {\n      var e = this.items,\n        s = t.id,\n        n = this.scope;\n      s in e && delete e[s], n && s in O[n] && (delete O[n][s], this.override && delete At[s]);\n    }\n  }]);\n  return Ae;\n}();\nfunction Ba(i, t, e) {\n  var s = ne( /* @__PURE__ */Object.create(null), [e ? O.get(e) : {}, O.get(t), i.defaults]);\n  O.set(t, s), i.defaultRoutes && Va(t, i.defaultRoutes), i.descriptors && O.describe(t, i.descriptors);\n}\nfunction Va(i, t) {\n  Object.keys(t).forEach(function (e) {\n    var s = e.split(\".\"),\n      n = s.pop(),\n      o = [i].concat(s).join(\".\"),\n      r = t[e].split(\".\"),\n      a = r.pop(),\n      l = r.join(\".\");\n    O.route(o, n, l, a);\n  });\n}\nfunction Wa(i) {\n  return \"id\" in i && \"defaults\" in i;\n}\nvar Na = /*#__PURE__*/function () {\n  function Na() {\n    _classCallCheck(this, Na);\n    this.controllers = new Ae(it, \"datasets\", !0), this.elements = new Ae(st, \"elements\"), this.plugins = new Ae(Object, \"plugins\"), this.scales = new Ae(Mt, \"scales\"), this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n  _createClass(Na, [{\n    key: \"add\",\n    value: function add() {\n      for (var _len4 = arguments.length, t = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        t[_key4] = arguments[_key4];\n      }\n      this._each(\"register\", t);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      for (var _len5 = arguments.length, t = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        t[_key5] = arguments[_key5];\n      }\n      this._each(\"unregister\", t);\n    }\n  }, {\n    key: \"addControllers\",\n    value: function addControllers() {\n      for (var _len6 = arguments.length, t = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        t[_key6] = arguments[_key6];\n      }\n      this._each(\"register\", t, this.controllers);\n    }\n  }, {\n    key: \"addElements\",\n    value: function addElements() {\n      for (var _len7 = arguments.length, t = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        t[_key7] = arguments[_key7];\n      }\n      this._each(\"register\", t, this.elements);\n    }\n  }, {\n    key: \"addPlugins\",\n    value: function addPlugins() {\n      for (var _len8 = arguments.length, t = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        t[_key8] = arguments[_key8];\n      }\n      this._each(\"register\", t, this.plugins);\n    }\n  }, {\n    key: \"addScales\",\n    value: function addScales() {\n      for (var _len9 = arguments.length, t = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        t[_key9] = arguments[_key9];\n      }\n      this._each(\"register\", t, this.scales);\n    }\n  }, {\n    key: \"getController\",\n    value: function getController(t) {\n      return this._get(t, this.controllers, \"controller\");\n    }\n  }, {\n    key: \"getElement\",\n    value: function getElement(t) {\n      return this._get(t, this.elements, \"element\");\n    }\n  }, {\n    key: \"getPlugin\",\n    value: function getPlugin(t) {\n      return this._get(t, this.plugins, \"plugin\");\n    }\n  }, {\n    key: \"getScale\",\n    value: function getScale(t) {\n      return this._get(t, this.scales, \"scale\");\n    }\n  }, {\n    key: \"removeControllers\",\n    value: function removeControllers() {\n      for (var _len10 = arguments.length, t = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        t[_key10] = arguments[_key10];\n      }\n      this._each(\"unregister\", t, this.controllers);\n    }\n  }, {\n    key: \"removeElements\",\n    value: function removeElements() {\n      for (var _len11 = arguments.length, t = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        t[_key11] = arguments[_key11];\n      }\n      this._each(\"unregister\", t, this.elements);\n    }\n  }, {\n    key: \"removePlugins\",\n    value: function removePlugins() {\n      for (var _len12 = arguments.length, t = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        t[_key12] = arguments[_key12];\n      }\n      this._each(\"unregister\", t, this.plugins);\n    }\n  }, {\n    key: \"removeScales\",\n    value: function removeScales() {\n      for (var _len13 = arguments.length, t = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        t[_key13] = arguments[_key13];\n      }\n      this._each(\"unregister\", t, this.scales);\n    }\n  }, {\n    key: \"_each\",\n    value: function _each(t, e, s) {\n      var _this11 = this;\n      _toConsumableArray(e).forEach(function (n) {\n        var o = s || _this11._getRegistryForType(n);\n        s || o.isForType(n) || o === _this11.plugins && n.id ? _this11._exec(t, o, n) : E(n, function (r) {\n          var a = s || _this11._getRegistryForType(r);\n          _this11._exec(t, a, r);\n        });\n      });\n    }\n  }, {\n    key: \"_exec\",\n    value: function _exec(t, e, s) {\n      var n = Oi(t);\n      I(s[\"before\" + n], [], s), e[t](s), I(s[\"after\" + n], [], s);\n    }\n  }, {\n    key: \"_getRegistryForType\",\n    value: function _getRegistryForType(t) {\n      for (var e = 0; e < this._typedRegistries.length; e++) {\n        var s = this._typedRegistries[e];\n        if (s.isForType(t)) return s;\n      }\n      return this.plugins;\n    }\n  }, {\n    key: \"_get\",\n    value: function _get(t, e, s) {\n      var n = e.get(t);\n      if (n === void 0) throw new Error('\"' + t + '\" is not a registered ' + s + \".\");\n      return n;\n    }\n  }]);\n  return Na;\n}();\nvar ot = new Na();\nvar xe = /*#__PURE__*/function (_it7) {\n  _inherits(xe, _it7);\n  var _super9 = _createSuper(xe);\n  function xe() {\n    _classCallCheck(this, xe);\n    return _super9.apply(this, arguments);\n  }\n  _createClass(xe, [{\n    key: \"update\",\n    value: function update(t) {\n      var e = this._cachedMeta,\n        _e$data2 = e.data,\n        s = _e$data2 === void 0 ? [] : _e$data2,\n        n = this.chart._animationsDisabled;\n      var _pn2 = pn(e, s, n),\n        o = _pn2.start,\n        r = _pn2.count;\n      if (this._drawStart = o, this._drawCount = r, mn(e) && (o = 0, r = s.length), this.options.showLine) {\n        var a = e.dataset,\n          l = e._dataset;\n        a._chart = this.chart, a._datasetIndex = this.index, a._decimated = !!l._decimated, a.points = s;\n        var c = this.resolveDatasetElementOptions(t);\n        c.segment = this.options.segment, this.updateElement(a, void 0, {\n          animated: !n,\n          options: c\n        }, t);\n      }\n      this.updateElements(s, o, r, t);\n    }\n  }, {\n    key: \"addElements\",\n    value: function addElements() {\n      var t = this.options.showLine;\n      !this.datasetElementType && t && (this.datasetElementType = ot.getElement(\"line\")), _get(_getPrototypeOf(xe.prototype), \"addElements\", this).call(this);\n    }\n  }, {\n    key: \"updateElements\",\n    value: function updateElements(t, e, s, n) {\n      var o = n === \"reset\",\n        _this$_cachedMeta4 = this._cachedMeta,\n        r = _this$_cachedMeta4.iScale,\n        a = _this$_cachedMeta4.vScale,\n        l = _this$_cachedMeta4._stacked,\n        c = _this$_cachedMeta4._dataset,\n        h = this.resolveDataElementOptions(e, n),\n        d = this.getSharedOptions(h),\n        u = this.includeOptions(n, d),\n        f = r.axis,\n        g = a.axis,\n        _this$options10 = this.options,\n        p = _this$options10.spanGaps,\n        m = _this$options10.segment,\n        b = Bt(p) ? p : Number.POSITIVE_INFINITY,\n        x = this.chart._animationsDisabled || o || n === \"none\";\n      var v = e > 0 && this.getParsed(e - 1);\n      for (var y = e; y < e + s; ++y) {\n        var _ = t[y],\n          M = this.getParsed(y),\n          k = x ? _ : {},\n          S = T(M[g]),\n          w = k[f] = r.getPixelForValue(M[f], y),\n          L = k[g] = o || S ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, M, l) : M[g], y);\n        k.skip = isNaN(w) || isNaN(L) || S, k.stop = y > 0 && Math.abs(M[f] - v[f]) > b, m && (k.parsed = M, k.raw = c.data[y]), u && (k.options = d || this.resolveDataElementOptions(y, _.active ? \"active\" : n)), x || this.updateElement(_, y, k, n), v = M;\n      }\n      this.updateSharedOptions(d, n, h);\n    }\n  }, {\n    key: \"getMaxOverflow\",\n    value: function getMaxOverflow() {\n      var t = this._cachedMeta,\n        e = t.data || [];\n      if (!this.options.showLine) {\n        var a = 0;\n        for (var l = e.length - 1; l >= 0; --l) a = Math.max(a, e[l].size(this.resolveDataElementOptions(l)) / 2);\n        return a > 0 && a;\n      }\n      var s = t.dataset,\n        n = s.options && s.options.borderWidth || 0;\n      if (!e.length) return n;\n      var o = e[0].size(this.resolveDataElementOptions(0)),\n        r = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1));\n      return Math.max(n, o, r) / 2;\n    }\n  }]);\n  return xe;\n}(it);\nxe.id = \"scatter\";\nxe.defaults = {\n  datasetElementType: !1,\n  dataElementType: \"point\",\n  showLine: !1,\n  fill: !1\n};\nxe.overrides = {\n  interaction: {\n    mode: \"point\"\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title: function title() {\n          return \"\";\n        },\n        label: function label(i) {\n          return \"(\" + i.label + \", \" + i.formattedValue + \")\";\n        }\n      }\n    }\n  },\n  scales: {\n    x: {\n      type: \"linear\"\n    },\n    y: {\n      type: \"linear\"\n    }\n  }\n};\nvar Wn = /* @__PURE__ */Object.freeze({\n  __proto__: null,\n  BarController: ue,\n  BubbleController: fe,\n  DoughnutController: Lt,\n  LineController: ge,\n  PolarAreaController: pe,\n  PieController: qe,\n  RadarController: me,\n  ScatterController: xe\n});\nfunction St() {\n  throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\");\n}\nvar vi = /*#__PURE__*/function () {\n  function vi(t) {\n    _classCallCheck(this, vi);\n    this.options = t || {};\n  }\n  _createClass(vi, [{\n    key: \"init\",\n    value: function init(t) {}\n  }, {\n    key: \"formats\",\n    value: function formats() {\n      return St();\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(t, e) {\n      return St();\n    }\n  }, {\n    key: \"format\",\n    value: function format(t, e) {\n      return St();\n    }\n  }, {\n    key: \"add\",\n    value: function add(t, e, s) {\n      return St();\n    }\n  }, {\n    key: \"diff\",\n    value: function diff(t, e, s) {\n      return St();\n    }\n  }, {\n    key: \"startOf\",\n    value: function startOf(t, e, s) {\n      return St();\n    }\n  }, {\n    key: \"endOf\",\n    value: function endOf(t, e) {\n      return St();\n    }\n  }]);\n  return vi;\n}();\nvi.override = function (i) {\n  Object.assign(vi.prototype, i);\n};\nvar Nn = {\n  _date: vi\n};\nfunction Ha(i, t, e, s) {\n  var n = i.controller,\n    o = i.data,\n    r = i._sorted,\n    a = n._cachedMeta.iScale;\n  if (a && t === a.axis && t !== \"r\" && r && o.length) {\n    var l = a._reversePixels ? Lo : ft;\n    if (s) {\n      if (n._sharedOptions) {\n        var c = o[0],\n          h = typeof c.getRange == \"function\" && c.getRange(t);\n        if (h) {\n          var d = l(o, t, e - h),\n            u = l(o, t, e + h);\n          return {\n            lo: d.lo,\n            hi: u.hi\n          };\n        }\n      }\n    } else return l(o, t, e);\n  }\n  return {\n    lo: 0,\n    hi: o.length - 1\n  };\n}\nfunction _e(i, t, e, s, n) {\n  var o = i.getSortedVisibleDatasetMetas(),\n    r = e[t];\n  for (var a = 0, l = o.length; a < l; ++a) {\n    var _o$a = o[a],\n      c = _o$a.index,\n      h = _o$a.data,\n      _Ha = Ha(o[a], t, r, n),\n      d = _Ha.lo,\n      u = _Ha.hi;\n    for (var f = d; f <= u; ++f) {\n      var g = h[f];\n      g.skip || s(g, c, f);\n    }\n  }\n}\nfunction ja(i) {\n  var t = i.indexOf(\"x\") !== -1,\n    e = i.indexOf(\"y\") !== -1;\n  return function (s, n) {\n    var o = t ? Math.abs(s.x - n.x) : 0,\n      r = e ? Math.abs(s.y - n.y) : 0;\n    return Math.sqrt(Math.pow(o, 2) + Math.pow(r, 2));\n  };\n}\nfunction di(i, t, e, s, n) {\n  var o = [];\n  return !n && !i.isPointInArea(t) || _e(i, e, t, function (a, l, c) {\n    !n && !re(a, i.chartArea, 0) || a.inRange(t.x, t.y, s) && o.push({\n      element: a,\n      datasetIndex: l,\n      index: c\n    });\n  }, !0), o;\n}\nfunction $a(i, t, e, s) {\n  var n = [];\n  function o(r, a, l) {\n    var _r$getProps = r.getProps([\"startAngle\", \"endAngle\"], s),\n      c = _r$getProps.startAngle,\n      h = _r$getProps.endAngle,\n      _hn = hn(r, {\n        x: t.x,\n        y: t.y\n      }),\n      d = _hn.angle;\n    oe(d, c, h) && n.push({\n      element: r,\n      datasetIndex: a,\n      index: l\n    });\n  }\n  return _e(i, e, t, o), n;\n}\nfunction Ya(i, t, e, s, n, o) {\n  var r = [];\n  var a = ja(e);\n  var l = Number.POSITIVE_INFINITY;\n  function c(h, d, u) {\n    var f = h.inRange(t.x, t.y, n);\n    if (s && !f) return;\n    var g = h.getCenterPoint(n);\n    if (!(!!o || i.isPointInArea(g)) && !f) return;\n    var m = a(t, g);\n    m < l ? (r = [{\n      element: h,\n      datasetIndex: d,\n      index: u\n    }], l = m) : m === l && r.push({\n      element: h,\n      datasetIndex: d,\n      index: u\n    });\n  }\n  return _e(i, e, t, c), r;\n}\nfunction ui(i, t, e, s, n, o) {\n  return !o && !i.isPointInArea(t) ? [] : e === \"r\" && !s ? $a(i, t, e, n) : Ya(i, t, e, s, n, o);\n}\nfunction Cs(i, t, e, s, n) {\n  var o = [],\n    r = e === \"x\" ? \"inXRange\" : \"inYRange\";\n  var a = !1;\n  return _e(i, e, t, function (l, c, h) {\n    l[r](t[e], n) && (o.push({\n      element: l,\n      datasetIndex: c,\n      index: h\n    }), a = a || l.inRange(t.x, t.y, n));\n  }), s && !a ? [] : o;\n}\nvar Hn = {\n  evaluateInteractionItems: _e,\n  modes: {\n    index: function index(i, t, e, s) {\n      var n = Pt(t, i),\n        o = e.axis || \"x\",\n        r = e.includeInvisible || !1,\n        a = e.intersect ? di(i, n, o, s, r) : ui(i, n, o, !1, s, r),\n        l = [];\n      return a.length ? (i.getSortedVisibleDatasetMetas().forEach(function (c) {\n        var h = a[0].index,\n          d = c.data[h];\n        d && !d.skip && l.push({\n          element: d,\n          datasetIndex: c.index,\n          index: h\n        });\n      }), l) : [];\n    },\n    dataset: function dataset(i, t, e, s) {\n      var n = Pt(t, i),\n        o = e.axis || \"xy\",\n        r = e.includeInvisible || !1;\n      var a = e.intersect ? di(i, n, o, s, r) : ui(i, n, o, !1, s, r);\n      if (a.length > 0) {\n        var l = a[0].datasetIndex,\n          c = i.getDatasetMeta(l).data;\n        a = [];\n        for (var h = 0; h < c.length; ++h) a.push({\n          element: c[h],\n          datasetIndex: l,\n          index: h\n        });\n      }\n      return a;\n    },\n    point: function point(i, t, e, s) {\n      var n = Pt(t, i),\n        o = e.axis || \"xy\",\n        r = e.includeInvisible || !1;\n      return di(i, n, o, s, r);\n    },\n    nearest: function nearest(i, t, e, s) {\n      var n = Pt(t, i),\n        o = e.axis || \"xy\",\n        r = e.includeInvisible || !1;\n      return ui(i, n, o, e.intersect, s, r);\n    },\n    x: function x(i, t, e, s) {\n      var n = Pt(t, i);\n      return Cs(i, n, \"x\", e.intersect, s);\n    },\n    y: function y(i, t, e, s) {\n      var n = Pt(t, i);\n      return Cs(i, n, \"y\", e.intersect, s);\n    }\n  }\n};\nvar jn = [\"left\", \"top\", \"right\", \"bottom\"];\nfunction Ut(i, t) {\n  return i.filter(function (e) {\n    return e.pos === t;\n  });\n}\nfunction Ds(i, t) {\n  return i.filter(function (e) {\n    return jn.indexOf(e.pos) === -1 && e.box.axis === t;\n  });\n}\nfunction Kt(i, t) {\n  return i.sort(function (e, s) {\n    var n = t ? s : e,\n      o = t ? e : s;\n    return n.weight === o.weight ? n.index - o.index : n.weight - o.weight;\n  });\n}\nfunction Xa(i) {\n  var t = [];\n  var e, s, n, o, r, a;\n  for (e = 0, s = (i || []).length; e < s; ++e) {\n    var _n2, _n2$options, _n2$options$stackWeig;\n    n = i[e], (_n2 = n, o = _n2.position, _n2$options = _n2.options, r = _n2$options.stack, _n2$options$stackWeig = _n2$options.stackWeight, a = _n2$options$stackWeig === void 0 ? 1 : _n2$options$stackWeig), t.push({\n      index: e,\n      box: n,\n      pos: o,\n      horizontal: n.isHorizontal(),\n      weight: n.weight,\n      stack: r && o + r,\n      stackWeight: a\n    });\n  }\n  return t;\n}\nfunction Ua(i) {\n  var t = {};\n  var _iterator16 = _createForOfIteratorHelper(i),\n    _step16;\n  try {\n    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n      var e = _step16.value;\n      var s = e.stack,\n        n = e.pos,\n        o = e.stackWeight;\n      if (!s || !jn.includes(n)) continue;\n      var r = t[s] || (t[s] = {\n        count: 0,\n        placed: 0,\n        weight: 0,\n        size: 0\n      });\n      r.count++, r.weight += o;\n    }\n  } catch (err) {\n    _iterator16.e(err);\n  } finally {\n    _iterator16.f();\n  }\n  return t;\n}\nfunction Ka(i, t) {\n  var e = Ua(i),\n    s = t.vBoxMaxWidth,\n    n = t.hBoxMaxHeight;\n  var o, r, a;\n  for (o = 0, r = i.length; o < r; ++o) {\n    a = i[o];\n    var l = a.box.fullSize,\n      c = e[a.stack],\n      h = c && a.stackWeight / c.weight;\n    a.horizontal ? (a.width = h ? h * s : l && t.availableWidth, a.height = n) : (a.width = s, a.height = h ? h * n : l && t.availableHeight);\n  }\n  return e;\n}\nfunction qa(i) {\n  var t = Xa(i),\n    e = Kt(t.filter(function (c) {\n      return c.box.fullSize;\n    }), !0),\n    s = Kt(Ut(t, \"left\"), !0),\n    n = Kt(Ut(t, \"right\")),\n    o = Kt(Ut(t, \"top\"), !0),\n    r = Kt(Ut(t, \"bottom\")),\n    a = Ds(t, \"x\"),\n    l = Ds(t, \"y\");\n  return {\n    fullSize: e,\n    leftAndTop: s.concat(o),\n    rightAndBottom: n.concat(l).concat(r).concat(a),\n    chartArea: Ut(t, \"chartArea\"),\n    vertical: s.concat(n).concat(l),\n    horizontal: o.concat(r).concat(a)\n  };\n}\nfunction Os(i, t, e, s) {\n  return Math.max(i[e], t[e]) + Math.max(i[s], t[s]);\n}\nfunction $n(i, t) {\n  i.top = Math.max(i.top, t.top), i.left = Math.max(i.left, t.left), i.bottom = Math.max(i.bottom, t.bottom), i.right = Math.max(i.right, t.right);\n}\nfunction Ga(i, t, e, s) {\n  var n = e.pos,\n    o = e.box,\n    r = i.maxPadding;\n  if (!D(n)) {\n    e.size && (i[n] -= e.size);\n    var d = s[e.stack] || {\n      size: 0,\n      count: 1\n    };\n    d.size = Math.max(d.size, e.horizontal ? o.height : o.width), e.size = d.size / d.count, i[n] += e.size;\n  }\n  o.getPadding && $n(r, o.getPadding());\n  var a = Math.max(0, t.outerWidth - Os(r, i, \"left\", \"right\")),\n    l = Math.max(0, t.outerHeight - Os(r, i, \"top\", \"bottom\")),\n    c = a !== i.w,\n    h = l !== i.h;\n  return i.w = a, i.h = l, e.horizontal ? {\n    same: c,\n    other: h\n  } : {\n    same: h,\n    other: c\n  };\n}\nfunction Za(i) {\n  var t = i.maxPadding;\n  function e(s) {\n    var n = Math.max(t[s] - i[s], 0);\n    return i[s] += n, n;\n  }\n  i.y += e(\"top\"), i.x += e(\"left\"), e(\"right\"), e(\"bottom\");\n}\nfunction Ja(i, t) {\n  var e = t.maxPadding;\n  function s(n) {\n    var o = {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n    return n.forEach(function (r) {\n      o[r] = Math.max(t[r], e[r]);\n    }), o;\n  }\n  return s(i ? [\"left\", \"right\"] : [\"top\", \"bottom\"]);\n}\nfunction Jt(i, t, e, s) {\n  var n = [];\n  var o, r, a, l, c, h;\n  for (o = 0, r = i.length, c = 0; o < r; ++o) {\n    a = i[o], l = a.box, l.update(a.width || t.w, a.height || t.h, Ja(a.horizontal, t));\n    var _Ga = Ga(t, e, a, s),\n      d = _Ga.same,\n      u = _Ga.other;\n    c |= d && n.length, h = h || u, l.fullSize || n.push(a);\n  }\n  return c && Jt(n, t, e, s) || h;\n}\nfunction Te(i, t, e, s, n) {\n  i.top = e, i.left = t, i.right = t + s, i.bottom = e + n, i.width = s, i.height = n;\n}\nfunction As(i, t, e, s) {\n  var n = e.padding;\n  var o = t.x,\n    r = t.y;\n  var _iterator17 = _createForOfIteratorHelper(i),\n    _step17;\n  try {\n    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n      var a = _step17.value;\n      var l = a.box,\n        c = s[a.stack] || {\n          count: 1,\n          placed: 0,\n          weight: 1\n        },\n        h = a.stackWeight / c.weight || 1;\n      if (a.horizontal) {\n        var d = t.w * h,\n          u = c.size || l.height;\n        et(c.start) && (r = c.start), l.fullSize ? Te(l, n.left, r, e.outerWidth - n.right - n.left, u) : Te(l, t.left + c.placed, r, d, u), c.start = r, c.placed += d, r = l.bottom;\n      } else {\n        var _d2 = t.h * h,\n          _u = c.size || l.width;\n        et(c.start) && (o = c.start), l.fullSize ? Te(l, o, n.top, _u, e.outerHeight - n.bottom - n.top) : Te(l, o, t.top + c.placed, _u, _d2), c.start = o, c.placed += _d2, o = l.right;\n      }\n    }\n  } catch (err) {\n    _iterator17.e(err);\n  } finally {\n    _iterator17.f();\n  }\n  t.x = o, t.y = r;\n}\nO.set(\"layout\", {\n  autoPadding: !0,\n  padding: {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  }\n});\nvar X = {\n  addBox: function addBox(i, t) {\n    i.boxes || (i.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || \"top\", t.weight = t.weight || 0, t._layers = t._layers || function () {\n      return [{\n        z: 0,\n        draw: function draw(e) {\n          t.draw(e);\n        }\n      }];\n    }, i.boxes.push(t);\n  },\n  removeBox: function removeBox(i, t) {\n    var e = i.boxes ? i.boxes.indexOf(t) : -1;\n    e !== -1 && i.boxes.splice(e, 1);\n  },\n  configure: function configure(i, t, e) {\n    t.fullSize = e.fullSize, t.position = e.position, t.weight = e.weight;\n  },\n  update: function update(i, t, e, s) {\n    if (!i) return;\n    var n = K(i.options.layout.padding),\n      o = Math.max(t - n.width, 0),\n      r = Math.max(e - n.height, 0),\n      a = qa(i.boxes),\n      l = a.vertical,\n      c = a.horizontal;\n    E(i.boxes, function (p) {\n      typeof p.beforeLayout == \"function\" && p.beforeLayout();\n    });\n    var h = l.reduce(function (p, m) {\n        return m.box.options && m.box.options.display === !1 ? p : p + 1;\n      }, 0) || 1,\n      d = Object.freeze({\n        outerWidth: t,\n        outerHeight: e,\n        padding: n,\n        availableWidth: o,\n        availableHeight: r,\n        vBoxMaxWidth: o / 2 / h,\n        hBoxMaxHeight: r / 2\n      }),\n      u = Object.assign({}, n);\n    $n(u, K(s));\n    var f = Object.assign({\n        maxPadding: u,\n        w: o,\n        h: r,\n        x: n.left,\n        y: n.top\n      }, n),\n      g = Ka(l.concat(c), d);\n    Jt(a.fullSize, f, d, g), Jt(l, f, d, g), Jt(c, f, d, g) && Jt(l, f, d, g), Za(f), As(a.leftAndTop, f, d, g), f.x += f.w, f.y += f.h, As(a.rightAndBottom, f, d, g), i.chartArea = {\n      left: f.left,\n      top: f.top,\n      right: f.left + f.w,\n      bottom: f.top + f.h,\n      height: f.h,\n      width: f.w\n    }, E(a.chartArea, function (p) {\n      var m = p.box;\n      Object.assign(m, i.chartArea), m.update(f.w, f.h, {\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0\n      });\n    });\n  }\n};\nvar Hi = /*#__PURE__*/function () {\n  function Hi() {\n    _classCallCheck(this, Hi);\n  }\n  _createClass(Hi, [{\n    key: \"acquireContext\",\n    value: function acquireContext(t, e) {}\n  }, {\n    key: \"releaseContext\",\n    value: function releaseContext(t) {\n      return !1;\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(t, e, s) {}\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(t, e, s) {}\n  }, {\n    key: \"getDevicePixelRatio\",\n    value: function getDevicePixelRatio() {\n      return 1;\n    }\n  }, {\n    key: \"getMaximumSize\",\n    value: function getMaximumSize(t, e, s, n) {\n      return e = Math.max(0, e || t.width), s = s || t.height, {\n        width: e,\n        height: Math.max(0, n ? Math.floor(e / n) : s)\n      };\n    }\n  }, {\n    key: \"isAttached\",\n    value: function isAttached(t) {\n      return !0;\n    }\n  }, {\n    key: \"updateConfig\",\n    value: function updateConfig(t) {}\n  }]);\n  return Hi;\n}();\nvar Yn = /*#__PURE__*/function (_Hi) {\n  _inherits(Yn, _Hi);\n  var _super10 = _createSuper(Yn);\n  function Yn() {\n    _classCallCheck(this, Yn);\n    return _super10.apply(this, arguments);\n  }\n  _createClass(Yn, [{\n    key: \"acquireContext\",\n    value: function acquireContext(t) {\n      return t && t.getContext && t.getContext(\"2d\") || null;\n    }\n  }, {\n    key: \"updateConfig\",\n    value: function updateConfig(t) {\n      t.options.animation = !1;\n    }\n  }]);\n  return Yn;\n}(Hi);\nvar Ie = \"$chartjs\",\n  Qa = {\n    touchstart: \"mousedown\",\n    touchmove: \"mousemove\",\n    touchend: \"mouseup\",\n    pointerenter: \"mouseenter\",\n    pointerdown: \"mousedown\",\n    pointermove: \"mousemove\",\n    pointerup: \"mouseup\",\n    pointerleave: \"mouseout\",\n    pointerout: \"mouseout\"\n  },\n  Ts = function Ts(i) {\n    return i === null || i === \"\";\n  };\nfunction tl(i, t) {\n  var e = i.style,\n    s = i.getAttribute(\"height\"),\n    n = i.getAttribute(\"width\");\n  if (i[Ie] = {\n    initial: {\n      height: s,\n      width: n,\n      style: {\n        display: e.display,\n        height: e.height,\n        width: e.width\n      }\n    }\n  }, e.display = e.display || \"block\", e.boxSizing = e.boxSizing || \"border-box\", Ts(n)) {\n    var o = cs(i, \"width\");\n    o !== void 0 && (i.width = o);\n  }\n  if (Ts(s)) if (i.style.height === \"\") i.height = i.width / (t || 2);else {\n    var _o3 = cs(i, \"height\");\n    _o3 !== void 0 && (i.height = _o3);\n  }\n  return i;\n}\nvar Xn = Vr ? {\n  passive: !0\n} : !1;\nfunction el(i, t, e) {\n  i.addEventListener(t, e, Xn);\n}\nfunction il(i, t, e) {\n  i.canvas.removeEventListener(t, e, Xn);\n}\nfunction sl(i, t) {\n  var e = Qa[i.type] || i.type,\n    _Pt = Pt(i, t),\n    s = _Pt.x,\n    n = _Pt.y;\n  return {\n    type: e,\n    chart: t,\n    native: i,\n    x: s !== void 0 ? s : null,\n    y: n !== void 0 ? n : null\n  };\n}\nfunction je(i, t) {\n  var _iterator18 = _createForOfIteratorHelper(i),\n    _step18;\n  try {\n    for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n      var e = _step18.value;\n      if (e === t || e.contains(t)) return !0;\n    }\n  } catch (err) {\n    _iterator18.e(err);\n  } finally {\n    _iterator18.f();\n  }\n}\nfunction nl(i, t, e) {\n  var s = i.canvas,\n    n = new MutationObserver(function (o) {\n      var r = !1;\n      var _iterator19 = _createForOfIteratorHelper(o),\n        _step19;\n      try {\n        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n          var a = _step19.value;\n          r = r || je(a.addedNodes, s), r = r && !je(a.removedNodes, s);\n        }\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n      r && e();\n    });\n  return n.observe(document, {\n    childList: !0,\n    subtree: !0\n  }), n;\n}\nfunction ol(i, t, e) {\n  var s = i.canvas,\n    n = new MutationObserver(function (o) {\n      var r = !1;\n      var _iterator20 = _createForOfIteratorHelper(o),\n        _step20;\n      try {\n        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n          var a = _step20.value;\n          r = r || je(a.removedNodes, s), r = r && !je(a.addedNodes, s);\n        }\n      } catch (err) {\n        _iterator20.e(err);\n      } finally {\n        _iterator20.f();\n      }\n      r && e();\n    });\n  return n.observe(document, {\n    childList: !0,\n    subtree: !0\n  }), n;\n}\nvar le = /* @__PURE__ */new Map();\nvar Ls = 0;\nfunction Un() {\n  var i = window.devicePixelRatio;\n  i !== Ls && (Ls = i, le.forEach(function (t, e) {\n    e.currentDevicePixelRatio !== i && t();\n  }));\n}\nfunction rl(i, t) {\n  le.size || window.addEventListener(\"resize\", Un), le.set(i, t);\n}\nfunction al(i) {\n  le.delete(i), le.size || window.removeEventListener(\"resize\", Un);\n}\nfunction ll(i, t, e) {\n  var s = i.canvas,\n    n = s && Wi(s);\n  if (!n) return;\n  var o = gn(function (a, l) {\n      var c = n.clientWidth;\n      e(a, l), c < n.clientWidth && e();\n    }, window),\n    r = new ResizeObserver(function (a) {\n      var l = a[0],\n        c = l.contentRect.width,\n        h = l.contentRect.height;\n      c === 0 && h === 0 || o(c, h);\n    });\n  return r.observe(n), rl(i, o), r;\n}\nfunction fi(i, t, e) {\n  e && e.disconnect(), t === \"resize\" && al(i);\n}\nfunction cl(i, t, e) {\n  var s = i.canvas,\n    n = gn(function (o) {\n      i.ctx !== null && e(sl(o, i));\n    }, i, function (o) {\n      var r = o[0];\n      return [r, r.offsetX, r.offsetY];\n    });\n  return el(s, t, n), n;\n}\nvar Kn = /*#__PURE__*/function (_Hi2) {\n  _inherits(Kn, _Hi2);\n  var _super11 = _createSuper(Kn);\n  function Kn() {\n    _classCallCheck(this, Kn);\n    return _super11.apply(this, arguments);\n  }\n  _createClass(Kn, [{\n    key: \"acquireContext\",\n    value: function acquireContext(t, e) {\n      var s = t && t.getContext && t.getContext(\"2d\");\n      return s && s.canvas === t ? (tl(t, e), s) : null;\n    }\n  }, {\n    key: \"releaseContext\",\n    value: function releaseContext(t) {\n      var e = t.canvas;\n      if (!e[Ie]) return !1;\n      var s = e[Ie].initial;\n      [\"height\", \"width\"].forEach(function (o) {\n        var r = s[o];\n        T(r) ? e.removeAttribute(o) : e.setAttribute(o, r);\n      });\n      var n = s.style || {};\n      return Object.keys(n).forEach(function (o) {\n        e.style[o] = n[o];\n      }), e.width = e.width, delete e[Ie], !0;\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(t, e, s) {\n      this.removeEventListener(t, e);\n      var n = t.$proxies || (t.$proxies = {}),\n        r = {\n          attach: nl,\n          detach: ol,\n          resize: ll\n        }[e] || cl;\n      n[e] = r(t, e, s);\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(t, e) {\n      var s = t.$proxies || (t.$proxies = {}),\n        n = s[e];\n      if (!n) return;\n      (({\n        attach: fi,\n        detach: fi,\n        resize: fi\n      })[e] || il)(t, e, n), s[e] = void 0;\n    }\n  }, {\n    key: \"getDevicePixelRatio\",\n    value: function getDevicePixelRatio() {\n      return window.devicePixelRatio;\n    }\n  }, {\n    key: \"getMaximumSize\",\n    value: function getMaximumSize(t, e, s, n) {\n      return Br(t, e, s, n);\n    }\n  }, {\n    key: \"isAttached\",\n    value: function isAttached(t) {\n      var e = Wi(t);\n      return !!(e && e.isConnected);\n    }\n  }]);\n  return Kn;\n}(Hi);\nfunction qn(i) {\n  return !An() || typeof OffscreenCanvas < \"u\" && i instanceof OffscreenCanvas ? Yn : Kn;\n}\nvar hl = /*#__PURE__*/function () {\n  function hl() {\n    _classCallCheck(this, hl);\n    this._init = [];\n  }\n  _createClass(hl, [{\n    key: \"notify\",\n    value: function notify(t, e, s, n) {\n      e === \"beforeInit\" && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, \"install\"));\n      var o = n ? this._descriptors(t).filter(n) : this._descriptors(t),\n        r = this._notify(o, t, e, s);\n      return e === \"afterDestroy\" && (this._notify(o, t, \"stop\"), this._notify(this._init, t, \"uninstall\")), r;\n    }\n  }, {\n    key: \"_notify\",\n    value: function _notify(t, e, s, n) {\n      n = n || {};\n      var _iterator21 = _createForOfIteratorHelper(t),\n        _step21;\n      try {\n        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n          var o = _step21.value;\n          var r = o.plugin,\n            a = r[s],\n            l = [e, n, o.options];\n          if (I(a, l, r) === !1 && n.cancelable) return !1;\n        }\n      } catch (err) {\n        _iterator21.e(err);\n      } finally {\n        _iterator21.f();\n      }\n      return !0;\n    }\n  }, {\n    key: \"invalidate\",\n    value: function invalidate() {\n      T(this._cache) || (this._oldCache = this._cache, this._cache = void 0);\n    }\n  }, {\n    key: \"_descriptors\",\n    value: function _descriptors(t) {\n      if (this._cache) return this._cache;\n      var e = this._cache = this._createDescriptors(t);\n      return this._notifyStateChanges(t), e;\n    }\n  }, {\n    key: \"_createDescriptors\",\n    value: function _createDescriptors(t, e) {\n      var s = t && t.config,\n        n = C(s.options && s.options.plugins, {}),\n        o = dl(s);\n      return n === !1 && !e ? [] : fl(t, o, n, e);\n    }\n  }, {\n    key: \"_notifyStateChanges\",\n    value: function _notifyStateChanges(t) {\n      var e = this._oldCache || [],\n        s = this._cache,\n        n = function n(o, r) {\n          return o.filter(function (a) {\n            return !r.some(function (l) {\n              return a.plugin.id === l.plugin.id;\n            });\n          });\n        };\n      this._notify(n(e, s), t, \"stop\"), this._notify(n(s, e), t, \"start\");\n    }\n  }]);\n  return hl;\n}();\nfunction dl(i) {\n  var t = {},\n    e = [],\n    s = Object.keys(ot.plugins.items);\n  for (var o = 0; o < s.length; o++) e.push(ot.getPlugin(s[o]));\n  var n = i.plugins || [];\n  for (var _o4 = 0; _o4 < n.length; _o4++) {\n    var r = n[_o4];\n    e.indexOf(r) === -1 && (e.push(r), t[r.id] = !0);\n  }\n  return {\n    plugins: e,\n    localIds: t\n  };\n}\nfunction ul(i, t) {\n  return !t && i === !1 ? null : i === !0 ? {} : i;\n}\nfunction fl(i, _ref3, s, n) {\n  var t = _ref3.plugins,\n    e = _ref3.localIds;\n  var o = [],\n    r = i.getContext();\n  var _iterator22 = _createForOfIteratorHelper(t),\n    _step22;\n  try {\n    for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n      var a = _step22.value;\n      var l = a.id,\n        c = ul(s[l], n);\n      c !== null && o.push({\n        plugin: a,\n        options: gl(i.config, {\n          plugin: a,\n          local: e[l]\n        }, c, r)\n      });\n    }\n  } catch (err) {\n    _iterator22.e(err);\n  } finally {\n    _iterator22.f();\n  }\n  return o;\n}\nfunction gl(i, _ref4, s, n) {\n  var t = _ref4.plugin,\n    e = _ref4.local;\n  var o = i.pluginScopeKeys(t),\n    r = i.getOptionScopes(s, o);\n  return e && t.defaults && r.push(t.defaults), i.createResolver(r, n, [\"\"], {\n    scriptable: !1,\n    indexable: !1,\n    allKeys: !0\n  });\n}\nfunction Mi(i, t) {\n  var e = O.datasets[i] || {};\n  return ((t.datasets || {})[i] || {}).indexAxis || t.indexAxis || e.indexAxis || \"x\";\n}\nfunction pl(i, t) {\n  var e = i;\n  return i === \"_index_\" ? e = t : i === \"_value_\" && (e = t === \"x\" ? \"y\" : \"x\"), e;\n}\nfunction ml(i, t) {\n  return i === t ? \"_index_\" : \"_value_\";\n}\nfunction bl(i) {\n  if (i === \"top\" || i === \"bottom\") return \"x\";\n  if (i === \"left\" || i === \"right\") return \"y\";\n}\nfunction ki(i, t) {\n  return i === \"x\" || i === \"y\" ? i : t.axis || bl(t.position) || i.charAt(0).toLowerCase();\n}\nfunction xl(i, t) {\n  var e = At[i.type] || {\n      scales: {}\n    },\n    s = t.scales || {},\n    n = Mi(i.type, t),\n    o = /* @__PURE__ */Object.create(null),\n    r = /* @__PURE__ */Object.create(null);\n  return Object.keys(s).forEach(function (a) {\n    var l = s[a];\n    if (!D(l)) return console.error(\"Invalid scale configuration for scale: \".concat(a));\n    if (l._proxy) return console.warn(\"Ignoring resolver passed as options for scale: \".concat(a));\n    var c = ki(a, l),\n      h = ml(c, n),\n      d = e.scales || {};\n    o[c] = o[c] || a, r[a] = Qt( /* @__PURE__ */Object.create(null), [{\n      axis: c\n    }, l, d[c], d[h]]);\n  }), i.data.datasets.forEach(function (a) {\n    var l = a.type || i.type,\n      c = a.indexAxis || Mi(l, t),\n      d = (At[l] || {}).scales || {};\n    Object.keys(d).forEach(function (u) {\n      var f = pl(u, c),\n        g = a[f + \"AxisID\"] || o[f] || f;\n      r[g] = r[g] || /* @__PURE__ */Object.create(null), Qt(r[g], [{\n        axis: f\n      }, s[g], d[u]]);\n    });\n  }), Object.keys(r).forEach(function (a) {\n    var l = r[a];\n    Qt(l, [O.scales[l.type], O.scale]);\n  }), r;\n}\nfunction Gn(i) {\n  var t = i.options || (i.options = {});\n  t.plugins = C(t.plugins, {}), t.scales = xl(i, t);\n}\nfunction Zn(i) {\n  return i = i || {}, i.datasets = i.datasets || [], i.labels = i.labels || [], i;\n}\nfunction _l(i) {\n  return i = i || {}, i.data = Zn(i.data), Gn(i), i;\n}\nvar Rs = /* @__PURE__ */new Map(),\n  Jn = /* @__PURE__ */new Set();\nfunction Le(i, t) {\n  var e = Rs.get(i);\n  return e || (e = t(), Rs.set(i, e), Jn.add(e)), e;\n}\nvar qt = function qt(i, t, e) {\n  var s = _t(t, e);\n  s !== void 0 && i.add(s);\n};\nvar yl = /*#__PURE__*/function () {\n  function yl(t) {\n    _classCallCheck(this, yl);\n    this._config = _l(t), this._scopeCache = /* @__PURE__ */new Map(), this._resolverCache = /* @__PURE__ */new Map();\n  }\n  _createClass(yl, [{\n    key: \"platform\",\n    get: function get() {\n      return this._config.platform;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._config.type;\n    },\n    set: function set(t) {\n      this._config.type = t;\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this._config.data;\n    },\n    set: function set(t) {\n      this._config.data = Zn(t);\n    }\n  }, {\n    key: \"options\",\n    get: function get() {\n      return this._config.options;\n    },\n    set: function set(t) {\n      this._config.options = t;\n    }\n  }, {\n    key: \"plugins\",\n    get: function get() {\n      return this._config.plugins;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var t = this._config;\n      this.clearCache(), Gn(t);\n    }\n  }, {\n    key: \"clearCache\",\n    value: function clearCache() {\n      this._scopeCache.clear(), this._resolverCache.clear();\n    }\n  }, {\n    key: \"datasetScopeKeys\",\n    value: function datasetScopeKeys(t) {\n      return Le(t, function () {\n        return [[\"datasets.\".concat(t), \"\"]];\n      });\n    }\n  }, {\n    key: \"datasetAnimationScopeKeys\",\n    value: function datasetAnimationScopeKeys(t, e) {\n      return Le(\"\".concat(t, \".transition.\").concat(e), function () {\n        return [[\"datasets.\".concat(t, \".transitions.\").concat(e), \"transitions.\".concat(e)], [\"datasets.\".concat(t), \"\"]];\n      });\n    }\n  }, {\n    key: \"datasetElementScopeKeys\",\n    value: function datasetElementScopeKeys(t, e) {\n      return Le(\"\".concat(t, \"-\").concat(e), function () {\n        return [[\"datasets.\".concat(t, \".elements.\").concat(e), \"datasets.\".concat(t), \"elements.\".concat(e), \"\"]];\n      });\n    }\n  }, {\n    key: \"pluginScopeKeys\",\n    value: function pluginScopeKeys(t) {\n      var e = t.id,\n        s = this.type;\n      return Le(\"\".concat(s, \"-plugin-\").concat(e), function () {\n        return [[\"plugins.\".concat(e)].concat(_toConsumableArray(t.additionalOptionScopes || []))];\n      });\n    }\n  }, {\n    key: \"_cachedScopes\",\n    value: function _cachedScopes(t, e) {\n      var s = this._scopeCache;\n      var n = s.get(t);\n      return (!n || e) && (n = /* @__PURE__ */new Map(), s.set(t, n)), n;\n    }\n  }, {\n    key: \"getOptionScopes\",\n    value: function getOptionScopes(t, e, s) {\n      var n = this.options,\n        o = this.type,\n        r = this._cachedScopes(t, s),\n        a = r.get(e);\n      if (a) return a;\n      var l = /* @__PURE__ */new Set();\n      e.forEach(function (h) {\n        t && (l.add(t), h.forEach(function (d) {\n          return qt(l, t, d);\n        })), h.forEach(function (d) {\n          return qt(l, n, d);\n        }), h.forEach(function (d) {\n          return qt(l, At[o] || {}, d);\n        }), h.forEach(function (d) {\n          return qt(l, O, d);\n        }), h.forEach(function (d) {\n          return qt(l, _i, d);\n        });\n      });\n      var c = Array.from(l);\n      return c.length === 0 && c.push( /* @__PURE__ */Object.create(null)), Jn.has(e) && r.set(e, c), c;\n    }\n  }, {\n    key: \"chartOptionScopes\",\n    value: function chartOptionScopes() {\n      var t = this.options,\n        e = this.type;\n      return [t, At[e] || {}, O.datasets[e] || {}, {\n        type: e\n      }, O, _i];\n    }\n  }, {\n    key: \"resolveNamedOptions\",\n    value: function resolveNamedOptions(t, e, s) {\n      var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [\"\"];\n      var o = {\n          $shared: !0\n        },\n        _Es = Es(this._resolverCache, t, n),\n        r = _Es.resolver,\n        a = _Es.subPrefixes;\n      var l = r;\n      if (Ml(r, e)) {\n        o.$shared = !1, s = yt(s) ? s() : s;\n        var c = this.createResolver(t, s, a);\n        l = Vt(r, s, c);\n      }\n      var _iterator23 = _createForOfIteratorHelper(e),\n        _step23;\n      try {\n        for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n          var _c2 = _step23.value;\n          o[_c2] = l[_c2];\n        }\n      } catch (err) {\n        _iterator23.e(err);\n      } finally {\n        _iterator23.f();\n      }\n      return o;\n    }\n  }, {\n    key: \"createResolver\",\n    value: function createResolver(t, e) {\n      var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [\"\"];\n      var n = arguments.length > 3 ? arguments[3] : undefined;\n      var _Es2 = Es(this._resolverCache, t, s),\n        o = _Es2.resolver;\n      return D(e) ? Vt(o, e, void 0, n) : o;\n    }\n  }]);\n  return yl;\n}();\nfunction Es(i, t, e) {\n  var s = i.get(t);\n  s || (s = /* @__PURE__ */new Map(), i.set(t, s));\n  var n = e.join();\n  var o = s.get(n);\n  return o || (o = {\n    resolver: zi(t, e),\n    subPrefixes: e.filter(function (a) {\n      return !a.toLowerCase().includes(\"hover\");\n    })\n  }, s.set(n, o)), o;\n}\nvar vl = function vl(i) {\n  return D(i) && Object.getOwnPropertyNames(i).reduce(function (t, e) {\n    return t || yt(i[e]);\n  }, !1);\n};\nfunction Ml(i, t) {\n  var _wn = wn(i),\n    e = _wn.isScriptable,\n    s = _wn.isIndexable;\n  var _iterator24 = _createForOfIteratorHelper(t),\n    _step24;\n  try {\n    for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n      var n = _step24.value;\n      var o = e(n),\n        r = s(n),\n        a = (r || o) && i[n];\n      if (o && (yt(a) || vl(a)) || r && z(a)) return !0;\n    }\n  } catch (err) {\n    _iterator24.e(err);\n  } finally {\n    _iterator24.f();\n  }\n  return !1;\n}\nvar kl = \"3.9.1\";\nvar wl = [\"top\", \"bottom\", \"left\", \"right\", \"chartArea\"];\nfunction Fs(i, t) {\n  return i === \"top\" || i === \"bottom\" || wl.indexOf(i) === -1 && t === \"x\";\n}\nfunction Is(i, t) {\n  return function (e, s) {\n    return e[i] === s[i] ? e[t] - s[t] : e[i] - s[i];\n  };\n}\nfunction zs(i) {\n  var t = i.chart,\n    e = t.options.animation;\n  t.notifyPlugins(\"afterRender\"), I(e && e.onComplete, [i], t);\n}\nfunction Sl(i) {\n  var t = i.chart,\n    e = t.options.animation;\n  I(e && e.onProgress, [i], t);\n}\nfunction Qn(i) {\n  return An() && typeof i == \"string\" ? i = document.getElementById(i) : i && i.length && (i = i[0]), i && i.canvas && (i = i.canvas), i;\n}\nvar $e = {},\n  to = function to(i) {\n    var t = Qn(i);\n    return Object.values($e).filter(function (e) {\n      return e.canvas === t;\n    }).pop();\n  };\nfunction Pl(i, t, e) {\n  var s = Object.keys(i);\n  for (var _i3 = 0, _s2 = s; _i3 < _s2.length; _i3++) {\n    var n = _s2[_i3];\n    var o = +n;\n    if (o >= t) {\n      var r = i[n];\n      delete i[n], (e > 0 || o > t) && (i[o + e] = r);\n    }\n  }\n}\nfunction Cl(i, t, e, s) {\n  return !e || i.type === \"mouseout\" ? null : s ? t : i;\n}\nvar ji = /*#__PURE__*/function () {\n  function ji(t, e) {\n    var _this12 = this;\n    _classCallCheck(this, ji);\n    var s = this.config = new yl(e),\n      n = Qn(t),\n      o = to(n);\n    if (o) throw new Error(\"Canvas is already in use. Chart with ID '\" + o.id + \"' must be destroyed before the canvas with ID '\" + o.canvas.id + \"' can be reused.\");\n    var r = s.createResolver(s.chartOptionScopes(), this.getContext());\n    this.platform = new (s.platform || qn(n))(), this.platform.updateConfig(s);\n    var a = this.platform.acquireContext(n, r.aspectRatio),\n      l = a && a.canvas,\n      c = l && l.height,\n      h = l && l.width;\n    if (this.id = _o(), this.ctx = a, this.canvas = l, this.width = h, this.height = c, this._options = r, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new hl(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = Fo(function (d) {\n      return _this12.update(d);\n    }, r.resizeDelay || 0), this._dataChanges = [], $e[this.id] = this, !a || !l) {\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n    at.listen(this, \"complete\", zs), at.listen(this, \"progress\", Sl), this._initialize(), this.attached && this.update();\n  }\n  _createClass(ji, [{\n    key: \"aspectRatio\",\n    get: function get() {\n      var _this$options11 = this.options,\n        t = _this$options11.aspectRatio,\n        e = _this$options11.maintainAspectRatio,\n        s = this.width,\n        n = this.height,\n        o = this._aspectRatio;\n      return T(t) ? e && o ? o : n ? s / n : null : t;\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this.config.data;\n    },\n    set: function set(t) {\n      this.config.data = t;\n    }\n  }, {\n    key: \"options\",\n    get: function get() {\n      return this._options;\n    },\n    set: function set(t) {\n      this.config.options = t;\n    }\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      return this.notifyPlugins(\"beforeInit\"), this.options.responsive ? this.resize() : ls(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins(\"afterInit\"), this;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      return os(this.canvas, this.ctx), this;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      return at.stop(this), this;\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(t, e) {\n      at.running(this) ? this._resizeBeforeDraw = {\n        width: t,\n        height: e\n      } : this._resize(t, e);\n    }\n  }, {\n    key: \"_resize\",\n    value: function _resize(t, e) {\n      var s = this.options,\n        n = this.canvas,\n        o = s.maintainAspectRatio && this.aspectRatio,\n        r = this.platform.getMaximumSize(n, t, e, o),\n        a = s.devicePixelRatio || this.platform.getDevicePixelRatio(),\n        l = this.width ? \"resize\" : \"attach\";\n      this.width = r.width, this.height = r.height, this._aspectRatio = this.aspectRatio, ls(this, a, !0) && (this.notifyPlugins(\"resize\", {\n        size: r\n      }), I(s.onResize, [this, r], this), this.attached && this._doResize(l) && this.render());\n    }\n  }, {\n    key: \"ensureScalesHaveIDs\",\n    value: function ensureScalesHaveIDs() {\n      var e = this.options.scales || {};\n      E(e, function (s, n) {\n        s.id = n;\n      });\n    }\n  }, {\n    key: \"buildOrUpdateScales\",\n    value: function buildOrUpdateScales() {\n      var _this13 = this;\n      var t = this.options,\n        e = t.scales,\n        s = this.scales,\n        n = Object.keys(s).reduce(function (r, a) {\n          return r[a] = !1, r;\n        }, {});\n      var o = [];\n      e && (o = o.concat(Object.keys(e).map(function (r) {\n        var a = e[r],\n          l = ki(r, a),\n          c = l === \"r\",\n          h = l === \"x\";\n        return {\n          options: a,\n          dposition: c ? \"chartArea\" : h ? \"bottom\" : \"left\",\n          dtype: c ? \"radialLinear\" : h ? \"category\" : \"linear\"\n        };\n      }))), E(o, function (r) {\n        var a = r.options,\n          l = a.id,\n          c = ki(l, a),\n          h = C(a.type, r.dtype);\n        (a.position === void 0 || Fs(a.position, c) !== Fs(r.dposition)) && (a.position = r.dposition), n[l] = !0;\n        var d = null;\n        if (l in s && s[l].type === h) d = s[l];else {\n          var u = ot.getScale(h);\n          d = new u({\n            id: l,\n            type: h,\n            ctx: _this13.ctx,\n            chart: _this13\n          }), s[d.id] = d;\n        }\n        d.init(a, t);\n      }), E(n, function (r, a) {\n        r || delete s[a];\n      }), E(s, function (r) {\n        X.configure(_this13, r, r.options), X.addBox(_this13, r);\n      });\n    }\n  }, {\n    key: \"_updateMetasets\",\n    value: function _updateMetasets() {\n      var t = this._metasets,\n        e = this.data.datasets.length,\n        s = t.length;\n      if (t.sort(function (n, o) {\n        return n.index - o.index;\n      }), s > e) {\n        for (var n = e; n < s; ++n) this._destroyDatasetMeta(n);\n        t.splice(e, s - e);\n      }\n      this._sortedMetasets = t.slice(0).sort(Is(\"order\", \"index\"));\n    }\n  }, {\n    key: \"_removeUnreferencedMetasets\",\n    value: function _removeUnreferencedMetasets() {\n      var _this14 = this;\n      var t = this._metasets,\n        e = this.data.datasets;\n      t.length > e.length && delete this._stacks, t.forEach(function (s, n) {\n        e.filter(function (o) {\n          return o === s._dataset;\n        }).length === 0 && _this14._destroyDatasetMeta(n);\n      });\n    }\n  }, {\n    key: \"buildOrUpdateControllers\",\n    value: function buildOrUpdateControllers() {\n      var t = [],\n        e = this.data.datasets;\n      var s, n;\n      for (this._removeUnreferencedMetasets(), s = 0, n = e.length; s < n; s++) {\n        var o = e[s];\n        var r = this.getDatasetMeta(s);\n        var a = o.type || this.config.type;\n        if (r.type && r.type !== a && (this._destroyDatasetMeta(s), r = this.getDatasetMeta(s)), r.type = a, r.indexAxis = o.indexAxis || Mi(a, this.options), r.order = o.order || 0, r.index = s, r.label = \"\" + o.label, r.visible = this.isDatasetVisible(s), r.controller) r.controller.updateIndex(s), r.controller.linkScales();else {\n          var l = ot.getController(a),\n            _O$datasets$a = O.datasets[a],\n            c = _O$datasets$a.datasetElementType,\n            h = _O$datasets$a.dataElementType;\n          Object.assign(l.prototype, {\n            dataElementType: ot.getElement(h),\n            datasetElementType: c && ot.getElement(c)\n          }), r.controller = new l(this, s), t.push(r.controller);\n        }\n      }\n      return this._updateMetasets(), t;\n    }\n  }, {\n    key: \"_resetElements\",\n    value: function _resetElements() {\n      var _this15 = this;\n      E(this.data.datasets, function (t, e) {\n        _this15.getDatasetMeta(e).controller.reset();\n      }, this);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._resetElements(), this.notifyPlugins(\"reset\");\n    }\n  }, {\n    key: \"update\",\n    value: function update(t) {\n      var e = this.config;\n      e.update();\n      var s = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()),\n        n = this._animationsDisabled = !s.animation;\n      if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins(\"beforeUpdate\", {\n        mode: t,\n        cancelable: !0\n      }) === !1) return;\n      var o = this.buildOrUpdateControllers();\n      this.notifyPlugins(\"beforeElementsUpdate\");\n      var r = 0;\n      for (var c = 0, h = this.data.datasets.length; c < h; c++) {\n        var _this$getDatasetMeta = this.getDatasetMeta(c),\n          d = _this$getDatasetMeta.controller,\n          u = !n && o.indexOf(d) === -1;\n        d.buildOrUpdateElements(u), r = Math.max(+d.getMaxOverflow(), r);\n      }\n      r = this._minPadding = s.layout.autoPadding ? r : 0, this._updateLayout(r), n || E(o, function (c) {\n        c.reset();\n      }), this._updateDatasets(t), this.notifyPlugins(\"afterUpdate\", {\n        mode: t\n      }), this._layers.sort(Is(\"z\", \"_idx\"));\n      var a = this._active,\n        l = this._lastEvent;\n      l ? this._eventHandler(l, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render();\n    }\n  }, {\n    key: \"_updateScales\",\n    value: function _updateScales() {\n      var _this16 = this;\n      E(this.scales, function (t) {\n        X.removeBox(_this16, t);\n      }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();\n    }\n  }, {\n    key: \"_checkEventBindings\",\n    value: function _checkEventBindings() {\n      var t = this.options,\n        e = new Set(Object.keys(this._listeners)),\n        s = new Set(t.events);\n      (!Ui(e, s) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents());\n    }\n  }, {\n    key: \"_updateHiddenIndices\",\n    value: function _updateHiddenIndices() {\n      var t = this._hiddenIndices,\n        e = this._getUniformDataChanges() || [];\n      var _iterator25 = _createForOfIteratorHelper(e),\n        _step25;\n      try {\n        for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n          var _step25$value = _step25.value,\n            s = _step25$value.method,\n            n = _step25$value.start,\n            o = _step25$value.count;\n          var r = s === \"_removeElements\" ? -o : o;\n          Pl(t, n, r);\n        }\n      } catch (err) {\n        _iterator25.e(err);\n      } finally {\n        _iterator25.f();\n      }\n    }\n  }, {\n    key: \"_getUniformDataChanges\",\n    value: function _getUniformDataChanges() {\n      var t = this._dataChanges;\n      if (!t || !t.length) return;\n      this._dataChanges = [];\n      var e = this.data.datasets.length,\n        s = function s(o) {\n          return new Set(t.filter(function (r) {\n            return r[0] === o;\n          }).map(function (r, a) {\n            return a + \",\" + r.splice(1).join(\",\");\n          }));\n        },\n        n = s(0);\n      for (var o = 1; o < e; o++) if (!Ui(n, s(o))) return;\n      return Array.from(n).map(function (o) {\n        return o.split(\",\");\n      }).map(function (o) {\n        return {\n          method: o[1],\n          start: +o[2],\n          count: +o[3]\n        };\n      });\n    }\n  }, {\n    key: \"_updateLayout\",\n    value: function _updateLayout(t) {\n      var _this17 = this;\n      if (this.notifyPlugins(\"beforeLayout\", {\n        cancelable: !0\n      }) === !1) return;\n      X.update(this, this.width, this.height, t);\n      var e = this.chartArea,\n        s = e.width <= 0 || e.height <= 0;\n      this._layers = [], E(this.boxes, function (n) {\n        var _this17$_layers;\n        s && n.position === \"chartArea\" || (n.configure && n.configure(), (_this17$_layers = _this17._layers).push.apply(_this17$_layers, _toConsumableArray(n._layers())));\n      }, this), this._layers.forEach(function (n, o) {\n        n._idx = o;\n      }), this.notifyPlugins(\"afterLayout\");\n    }\n  }, {\n    key: \"_updateDatasets\",\n    value: function _updateDatasets(t) {\n      if (this.notifyPlugins(\"beforeDatasetsUpdate\", {\n        mode: t,\n        cancelable: !0\n      }) !== !1) {\n        for (var e = 0, s = this.data.datasets.length; e < s; ++e) this.getDatasetMeta(e).controller.configure();\n        for (var _e2 = 0, _s3 = this.data.datasets.length; _e2 < _s3; ++_e2) this._updateDataset(_e2, yt(t) ? t({\n          datasetIndex: _e2\n        }) : t);\n        this.notifyPlugins(\"afterDatasetsUpdate\", {\n          mode: t\n        });\n      }\n    }\n  }, {\n    key: \"_updateDataset\",\n    value: function _updateDataset(t, e) {\n      var s = this.getDatasetMeta(t),\n        n = {\n          meta: s,\n          index: t,\n          mode: e,\n          cancelable: !0\n        };\n      this.notifyPlugins(\"beforeDatasetUpdate\", n) !== !1 && (s.controller._update(e), n.cancelable = !1, this.notifyPlugins(\"afterDatasetUpdate\", n));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.notifyPlugins(\"beforeRender\", {\n        cancelable: !0\n      }) !== !1 && (at.has(this) ? this.attached && !at.running(this) && at.start(this) : (this.draw(), zs({\n        chart: this\n      })));\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var t;\n      if (this._resizeBeforeDraw) {\n        var _this$_resizeBeforeDr = this._resizeBeforeDraw,\n          s = _this$_resizeBeforeDr.width,\n          n = _this$_resizeBeforeDr.height;\n        this._resize(s, n), this._resizeBeforeDraw = null;\n      }\n      if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins(\"beforeDraw\", {\n        cancelable: !0\n      }) === !1) return;\n      var e = this._layers;\n      for (t = 0; t < e.length && e[t].z <= 0; ++t) e[t].draw(this.chartArea);\n      for (this._drawDatasets(); t < e.length; ++t) e[t].draw(this.chartArea);\n      this.notifyPlugins(\"afterDraw\");\n    }\n  }, {\n    key: \"_getSortedDatasetMetas\",\n    value: function _getSortedDatasetMetas(t) {\n      var e = this._sortedMetasets,\n        s = [];\n      var n, o;\n      for (n = 0, o = e.length; n < o; ++n) {\n        var r = e[n];\n        (!t || r.visible) && s.push(r);\n      }\n      return s;\n    }\n  }, {\n    key: \"getSortedVisibleDatasetMetas\",\n    value: function getSortedVisibleDatasetMetas() {\n      return this._getSortedDatasetMetas(!0);\n    }\n  }, {\n    key: \"_drawDatasets\",\n    value: function _drawDatasets() {\n      if (this.notifyPlugins(\"beforeDatasetsDraw\", {\n        cancelable: !0\n      }) === !1) return;\n      var t = this.getSortedVisibleDatasetMetas();\n      for (var e = t.length - 1; e >= 0; --e) this._drawDataset(t[e]);\n      this.notifyPlugins(\"afterDatasetsDraw\");\n    }\n  }, {\n    key: \"_drawDataset\",\n    value: function _drawDataset(t) {\n      var e = this.ctx,\n        s = t._clip,\n        n = !s.disabled,\n        o = this.chartArea,\n        r = {\n          meta: t,\n          index: t.index,\n          cancelable: !0\n        };\n      this.notifyPlugins(\"beforeDatasetDraw\", r) !== !1 && (n && Xe(e, {\n        left: s.left === !1 ? 0 : o.left - s.left,\n        right: s.right === !1 ? this.width : o.right + s.right,\n        top: s.top === !1 ? 0 : o.top - s.top,\n        bottom: s.bottom === !1 ? this.height : o.bottom + s.bottom\n      }), t.controller.draw(), n && Ue(e), r.cancelable = !1, this.notifyPlugins(\"afterDatasetDraw\", r));\n    }\n  }, {\n    key: \"isPointInArea\",\n    value: function isPointInArea(t) {\n      return re(t, this.chartArea, this._minPadding);\n    }\n  }, {\n    key: \"getElementsAtEventForMode\",\n    value: function getElementsAtEventForMode(t, e, s, n) {\n      var o = Hn.modes[e];\n      return typeof o == \"function\" ? o(this, t, s, n) : [];\n    }\n  }, {\n    key: \"getDatasetMeta\",\n    value: function getDatasetMeta(t) {\n      var e = this.data.datasets[t],\n        s = this._metasets;\n      var n = s.filter(function (o) {\n        return o && o._dataset === e;\n      }).pop();\n      return n || (n = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\n        xAxisID: null,\n        yAxisID: null,\n        order: e && e.order || 0,\n        index: t,\n        _dataset: e,\n        _parsed: [],\n        _sorted: !1\n      }, s.push(n)), n;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.$context || (this.$context = vt(null, {\n        chart: this,\n        type: \"chart\"\n      }));\n    }\n  }, {\n    key: \"getVisibleDatasetCount\",\n    value: function getVisibleDatasetCount() {\n      return this.getSortedVisibleDatasetMetas().length;\n    }\n  }, {\n    key: \"isDatasetVisible\",\n    value: function isDatasetVisible(t) {\n      var e = this.data.datasets[t];\n      if (!e) return !1;\n      var s = this.getDatasetMeta(t);\n      return typeof s.hidden == \"boolean\" ? !s.hidden : !e.hidden;\n    }\n  }, {\n    key: \"setDatasetVisibility\",\n    value: function setDatasetVisibility(t, e) {\n      var s = this.getDatasetMeta(t);\n      s.hidden = !e;\n    }\n  }, {\n    key: \"toggleDataVisibility\",\n    value: function toggleDataVisibility(t) {\n      this._hiddenIndices[t] = !this._hiddenIndices[t];\n    }\n  }, {\n    key: \"getDataVisibility\",\n    value: function getDataVisibility(t) {\n      return !this._hiddenIndices[t];\n    }\n  }, {\n    key: \"_updateVisibility\",\n    value: function _updateVisibility(t, e, s) {\n      var n = s ? \"show\" : \"hide\",\n        o = this.getDatasetMeta(t),\n        r = o.controller._resolveAnimations(void 0, n);\n      et(e) ? (o.data[e].hidden = !s, this.update()) : (this.setDatasetVisibility(t, s), r.update(o, {\n        visible: s\n      }), this.update(function (a) {\n        return a.datasetIndex === t ? n : void 0;\n      }));\n    }\n  }, {\n    key: \"hide\",\n    value: function hide(t, e) {\n      this._updateVisibility(t, e, !1);\n    }\n  }, {\n    key: \"show\",\n    value: function show(t, e) {\n      this._updateVisibility(t, e, !0);\n    }\n  }, {\n    key: \"_destroyDatasetMeta\",\n    value: function _destroyDatasetMeta(t) {\n      var e = this._metasets[t];\n      e && e.controller && e.controller._destroy(), delete this._metasets[t];\n    }\n  }, {\n    key: \"_stop\",\n    value: function _stop() {\n      var t, e;\n      for (this.stop(), at.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t) this._destroyDatasetMeta(t);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.notifyPlugins(\"beforeDestroy\");\n      var t = this.canvas,\n        e = this.ctx;\n      this._stop(), this.config.clearCache(), t && (this.unbindEvents(), os(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), this.notifyPlugins(\"destroy\"), delete $e[this.id], this.notifyPlugins(\"afterDestroy\");\n    }\n  }, {\n    key: \"toBase64Image\",\n    value: function toBase64Image() {\n      var _this$canvas;\n      return (_this$canvas = this.canvas).toDataURL.apply(_this$canvas, arguments);\n    }\n  }, {\n    key: \"bindEvents\",\n    value: function bindEvents() {\n      this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;\n    }\n  }, {\n    key: \"bindUserEvents\",\n    value: function bindUserEvents() {\n      var _this18 = this;\n      var t = this._listeners,\n        e = this.platform,\n        s = function s(o, r) {\n          e.addEventListener(_this18, o, r), t[o] = r;\n        },\n        n = function n(o, r, a) {\n          o.offsetX = r, o.offsetY = a, _this18._eventHandler(o);\n        };\n      E(this.options.events, function (o) {\n        return s(o, n);\n      });\n    }\n  }, {\n    key: \"bindResponsiveEvents\",\n    value: function bindResponsiveEvents() {\n      var _this19 = this;\n      this._responsiveListeners || (this._responsiveListeners = {});\n      var t = this._responsiveListeners,\n        e = this.platform,\n        s = function s(l, c) {\n          e.addEventListener(_this19, l, c), t[l] = c;\n        },\n        n = function n(l, c) {\n          t[l] && (e.removeEventListener(_this19, l, c), delete t[l]);\n        },\n        o = function o(l, c) {\n          _this19.canvas && _this19.resize(l, c);\n        };\n      var r;\n      var a = function a() {\n        n(\"attach\", a), _this19.attached = !0, _this19.resize(), s(\"resize\", o), s(\"detach\", r);\n      };\n      r = function r() {\n        _this19.attached = !1, n(\"resize\", o), _this19._stop(), _this19._resize(0, 0), s(\"attach\", a);\n      }, e.isAttached(this.canvas) ? a() : r();\n    }\n  }, {\n    key: \"unbindEvents\",\n    value: function unbindEvents() {\n      var _this20 = this;\n      E(this._listeners, function (t, e) {\n        _this20.platform.removeEventListener(_this20, e, t);\n      }), this._listeners = {}, E(this._responsiveListeners, function (t, e) {\n        _this20.platform.removeEventListener(_this20, e, t);\n      }), this._responsiveListeners = void 0;\n    }\n  }, {\n    key: \"updateHoverStyle\",\n    value: function updateHoverStyle(t, e, s) {\n      var n = s ? \"set\" : \"remove\";\n      var o, r, a, l;\n      for (e === \"dataset\" && (o = this.getDatasetMeta(t[0].datasetIndex), o.controller[\"_\" + n + \"DatasetHoverStyle\"]()), a = 0, l = t.length; a < l; ++a) {\n        r = t[a];\n        var c = r && this.getDatasetMeta(r.datasetIndex).controller;\n        c && c[n + \"HoverStyle\"](r.element, r.datasetIndex, r.index);\n      }\n    }\n  }, {\n    key: \"getActiveElements\",\n    value: function getActiveElements() {\n      return this._active || [];\n    }\n  }, {\n    key: \"setActiveElements\",\n    value: function setActiveElements(t) {\n      var _this21 = this;\n      var e = this._active || [],\n        s = t.map(function (_ref5) {\n          var o = _ref5.datasetIndex,\n            r = _ref5.index;\n          var a = _this21.getDatasetMeta(o);\n          if (!a) throw new Error(\"No dataset found at index \" + o);\n          return {\n            datasetIndex: o,\n            element: a.data[r],\n            index: r\n          };\n        });\n      !ze(s, e) && (this._active = s, this._lastEvent = null, this._updateHoverStyles(s, e));\n    }\n  }, {\n    key: \"notifyPlugins\",\n    value: function notifyPlugins(t, e, s) {\n      return this._plugins.notify(this, t, e, s);\n    }\n  }, {\n    key: \"_updateHoverStyles\",\n    value: function _updateHoverStyles(t, e, s) {\n      var n = this.options.hover,\n        o = function o(l, c) {\n          return l.filter(function (h) {\n            return !c.some(function (d) {\n              return h.datasetIndex === d.datasetIndex && h.index === d.index;\n            });\n          });\n        },\n        r = o(e, t),\n        a = s ? t : o(t, e);\n      r.length && this.updateHoverStyle(r, n.mode, !1), a.length && n.mode && this.updateHoverStyle(a, n.mode, !0);\n    }\n  }, {\n    key: \"_eventHandler\",\n    value: function _eventHandler(t, e) {\n      var _this22 = this;\n      var s = {\n          event: t,\n          replay: e,\n          cancelable: !0,\n          inChartArea: this.isPointInArea(t)\n        },\n        n = function n(r) {\n          return (r.options.events || _this22.options.events).includes(t.native.type);\n        };\n      if (this.notifyPlugins(\"beforeEvent\", s, n) === !1) return;\n      var o = this._handleEvent(t, e, s.inChartArea);\n      return s.cancelable = !1, this.notifyPlugins(\"afterEvent\", s, n), (o || s.changed) && this.render(), this;\n    }\n  }, {\n    key: \"_handleEvent\",\n    value: function _handleEvent(t, e, s) {\n      var _this$_active = this._active,\n        n = _this$_active === void 0 ? [] : _this$_active,\n        o = this.options,\n        r = e,\n        a = this._getActiveElements(t, n, s, r),\n        l = So(t),\n        c = Cl(t, this._lastEvent, s, l);\n      s && (this._lastEvent = null, I(o.onHover, [t, a, this], this), l && I(o.onClick, [t, a, this], this));\n      var h = !ze(a, n);\n      return (h || e) && (this._active = a, this._updateHoverStyles(a, n, e)), this._lastEvent = c, h;\n    }\n  }, {\n    key: \"_getActiveElements\",\n    value: function _getActiveElements(t, e, s, n) {\n      if (t.type === \"mouseout\") return [];\n      if (!s) return e;\n      var o = this.options.hover;\n      return this.getElementsAtEventForMode(t, o.mode, o, n);\n    }\n  }]);\n  return ji;\n}();\nvar Bs = function Bs() {\n    return E(ji.instances, function (i) {\n      return i._plugins.invalidate();\n    });\n  },\n  pt = !0;\nObject.defineProperties(ji, {\n  defaults: {\n    enumerable: pt,\n    value: O\n  },\n  instances: {\n    enumerable: pt,\n    value: $e\n  },\n  overrides: {\n    enumerable: pt,\n    value: At\n  },\n  registry: {\n    enumerable: pt,\n    value: ot\n  },\n  version: {\n    enumerable: pt,\n    value: kl\n  },\n  getChart: {\n    enumerable: pt,\n    value: to\n  },\n  register: {\n    enumerable: pt,\n    value: function value() {\n      ot.add.apply(ot, arguments), Bs();\n    }\n  },\n  unregister: {\n    enumerable: pt,\n    value: function value() {\n      ot.remove.apply(ot, arguments), Bs();\n    }\n  }\n});\nfunction eo(i, t, e) {\n  var s = t.startAngle,\n    n = t.pixelMargin,\n    o = t.x,\n    r = t.y,\n    a = t.outerRadius,\n    l = t.innerRadius;\n  var c = n / a;\n  i.beginPath(), i.arc(o, r, a, s - c, e + c), l > n ? (c = n / l, i.arc(o, r, l, e + c, s - c, !0)) : i.arc(o, r, n, e + V, s - V), i.closePath(), i.clip();\n}\nfunction Dl(i) {\n  return Ii(i, [\"outerStart\", \"outerEnd\", \"innerStart\", \"innerEnd\"]);\n}\nfunction Ol(i, t, e, s) {\n  var n = Dl(i.options.borderRadius),\n    o = (e - t) / 2,\n    r = Math.min(o, s * t / 2),\n    a = function a(l) {\n      var c = (e - Math.min(o, l)) * s / 2;\n      return Y(l, 0, Math.min(o, c));\n    };\n  return {\n    outerStart: a(n.outerStart),\n    outerEnd: a(n.outerEnd),\n    innerStart: Y(n.innerStart, 0, r),\n    innerEnd: Y(n.innerEnd, 0, r)\n  };\n}\nfunction It(i, t, e, s) {\n  return {\n    x: e + i * Math.cos(t),\n    y: s + i * Math.sin(t)\n  };\n}\nfunction wi(i, t, e, s, n, o) {\n  var r = t.x,\n    a = t.y,\n    l = t.startAngle,\n    c = t.pixelMargin,\n    h = t.innerRadius,\n    d = Math.max(t.outerRadius + s + e - c, 0),\n    u = h > 0 ? h + s + e + c : 0;\n  var f = 0;\n  var g = n - l;\n  if (s) {\n    var P = h > 0 ? h - s : 0,\n      j = d > 0 ? d - s : 0,\n      W = (P + j) / 2,\n      kt = W !== 0 ? g * W / (W + s) : g;\n    f = (g - kt) / 2;\n  }\n  var p = Math.max(1e-3, g * d - e / B) / d,\n    m = (g - p) / 2,\n    b = l + m + f,\n    x = n - m - f,\n    _Ol = Ol(t, u, d, x - b),\n    v = _Ol.outerStart,\n    y = _Ol.outerEnd,\n    _ = _Ol.innerStart,\n    M = _Ol.innerEnd,\n    k = d - v,\n    S = d - y,\n    w = b + v / k,\n    L = x - y / S,\n    R = u + _,\n    A = u + M,\n    H = b + _ / R,\n    q = x - M / A;\n  if (i.beginPath(), o) {\n    if (i.arc(r, a, d, w, L), y > 0) {\n      var _W = It(S, L, r, a);\n      i.arc(_W.x, _W.y, y, L, x + V);\n    }\n    var _P7 = It(A, x, r, a);\n    if (i.lineTo(_P7.x, _P7.y), M > 0) {\n      var _W2 = It(A, q, r, a);\n      i.arc(_W2.x, _W2.y, M, x + V, q + Math.PI);\n    }\n    if (i.arc(r, a, u, x - M / u, b + _ / u, !0), _ > 0) {\n      var _W3 = It(R, H, r, a);\n      i.arc(_W3.x, _W3.y, _, H + Math.PI, b - V);\n    }\n    var _j5 = It(k, b, r, a);\n    if (i.lineTo(_j5.x, _j5.y), v > 0) {\n      var _W4 = It(k, w, r, a);\n      i.arc(_W4.x, _W4.y, v, b - V, w);\n    }\n  } else {\n    i.moveTo(r, a);\n    var _P8 = Math.cos(w) * d + r,\n      _j6 = Math.sin(w) * d + a;\n    i.lineTo(_P8, _j6);\n    var _W5 = Math.cos(L) * d + r,\n      _kt = Math.sin(L) * d + a;\n    i.lineTo(_W5, _kt);\n  }\n  i.closePath();\n}\nfunction Al(i, t, e, s, n) {\n  var o = t.fullCircles,\n    r = t.startAngle,\n    a = t.circumference;\n  var l = t.endAngle;\n  if (o) {\n    wi(i, t, e, s, r + F, n);\n    for (var c = 0; c < o; ++c) i.fill();\n    isNaN(a) || (l = r + a % F, a % F === 0 && (l += F));\n  }\n  return wi(i, t, e, s, l, n), i.fill(), l;\n}\nfunction Tl(i, t, e) {\n  var s = t.x,\n    n = t.y,\n    o = t.startAngle,\n    r = t.pixelMargin,\n    a = t.fullCircles,\n    l = Math.max(t.outerRadius - r, 0),\n    c = t.innerRadius + r;\n  var h;\n  for (e && eo(i, t, o + F), i.beginPath(), i.arc(s, n, c, o + F, o, !0), h = 0; h < a; ++h) i.stroke();\n  for (i.beginPath(), i.arc(s, n, l, o, o + F), h = 0; h < a; ++h) i.stroke();\n}\nfunction Ll(i, t, e, s, n, o) {\n  var r = t.options,\n    a = r.borderWidth,\n    l = r.borderJoinStyle,\n    c = r.borderAlign === \"inner\";\n  a && (c ? (i.lineWidth = a * 2, i.lineJoin = l || \"round\") : (i.lineWidth = a, i.lineJoin = l || \"bevel\"), t.fullCircles && Tl(i, t, c), c && eo(i, t, n), wi(i, t, e, s, n, o), i.stroke());\n}\nvar ye = /*#__PURE__*/function (_st2) {\n  _inherits(ye, _st2);\n  var _super12 = _createSuper(ye);\n  function ye(t) {\n    var _this23;\n    _classCallCheck(this, ye);\n    _this23 = _super12.call(this), _this23.options = void 0, _this23.circumference = void 0, _this23.startAngle = void 0, _this23.endAngle = void 0, _this23.innerRadius = void 0, _this23.outerRadius = void 0, _this23.pixelMargin = 0, _this23.fullCircles = 0, t && Object.assign(_assertThisInitialized(_this23), t);\n    return _this23;\n  }\n  _createClass(ye, [{\n    key: \"inRange\",\n    value: function inRange(t, e, s) {\n      var n = this.getProps([\"x\", \"y\"], s),\n        _hn2 = hn(n, {\n          x: t,\n          y: e\n        }),\n        o = _hn2.angle,\n        r = _hn2.distance,\n        _this$getProps2 = this.getProps([\"startAngle\", \"endAngle\", \"innerRadius\", \"outerRadius\", \"circumference\"], s),\n        a = _this$getProps2.startAngle,\n        l = _this$getProps2.endAngle,\n        c = _this$getProps2.innerRadius,\n        h = _this$getProps2.outerRadius,\n        d = _this$getProps2.circumference,\n        u = this.options.spacing / 2,\n        g = C(d, l - a) >= F || oe(o, a, l),\n        p = ut(r, c + u, h + u);\n      return g && p;\n    }\n  }, {\n    key: \"getCenterPoint\",\n    value: function getCenterPoint(t) {\n      var _this$getProps3 = this.getProps([\"x\", \"y\", \"startAngle\", \"endAngle\", \"innerRadius\", \"outerRadius\", \"circumference\"], t),\n        e = _this$getProps3.x,\n        s = _this$getProps3.y,\n        n = _this$getProps3.startAngle,\n        o = _this$getProps3.endAngle,\n        r = _this$getProps3.innerRadius,\n        a = _this$getProps3.outerRadius,\n        _this$options12 = this.options,\n        l = _this$options12.offset,\n        c = _this$options12.spacing,\n        h = (n + o) / 2,\n        d = (r + a + c + l) / 2;\n      return {\n        x: e + Math.cos(h) * d,\n        y: s + Math.sin(h) * d\n      };\n    }\n  }, {\n    key: \"tooltipPosition\",\n    value: function tooltipPosition(t) {\n      return this.getCenterPoint(t);\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(t) {\n      var e = this.options,\n        s = this.circumference,\n        n = (e.offset || 0) / 2,\n        o = (e.spacing || 0) / 2,\n        r = e.circular;\n      if (this.pixelMargin = e.borderAlign === \"inner\" ? 0.33 : 0, this.fullCircles = s > F ? Math.floor(s / F) : 0, s === 0 || this.innerRadius < 0 || this.outerRadius < 0) return;\n      t.save();\n      var a = 0;\n      if (n) {\n        a = n / 2;\n        var c = (this.startAngle + this.endAngle) / 2;\n        t.translate(Math.cos(c) * a, Math.sin(c) * a), this.circumference >= B && (a = n);\n      }\n      t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor;\n      var l = Al(t, this, a, o, r);\n      Ll(t, this, a, o, l, r), t.restore();\n    }\n  }]);\n  return ye;\n}(st);\nye.id = \"arc\";\nye.defaults = {\n  borderAlign: \"center\",\n  borderColor: \"#fff\",\n  borderJoinStyle: void 0,\n  borderRadius: 0,\n  borderWidth: 2,\n  offset: 0,\n  spacing: 0,\n  angle: void 0,\n  circular: !0\n};\nye.defaultRoutes = {\n  backgroundColor: \"backgroundColor\"\n};\nfunction io(i, t) {\n  var e = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : t;\n  i.lineCap = C(e.borderCapStyle, t.borderCapStyle), i.setLineDash(C(e.borderDash, t.borderDash)), i.lineDashOffset = C(e.borderDashOffset, t.borderDashOffset), i.lineJoin = C(e.borderJoinStyle, t.borderJoinStyle), i.lineWidth = C(e.borderWidth, t.borderWidth), i.strokeStyle = C(e.borderColor, t.borderColor);\n}\nfunction Rl(i, t, e) {\n  i.lineTo(e.x, e.y);\n}\nfunction El(i) {\n  return i.stepped ? lr : i.tension || i.cubicInterpolationMode === \"monotone\" ? cr : Rl;\n}\nfunction so(i, t) {\n  var e = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var s = i.length,\n    _e$start = e.start,\n    n = _e$start === void 0 ? 0 : _e$start,\n    _e$end = e.end,\n    o = _e$end === void 0 ? s - 1 : _e$end,\n    r = t.start,\n    a = t.end,\n    l = Math.max(n, r),\n    c = Math.min(o, a),\n    h = n < r && o < r || n > a && o > a;\n  return {\n    count: s,\n    start: l,\n    loop: t.loop,\n    ilen: c < l && !h ? s + c - l : c - l\n  };\n}\nfunction Fl(i, t, e, s) {\n  var n = t.points,\n    o = t.options,\n    _so = so(n, e, s),\n    r = _so.count,\n    a = _so.start,\n    l = _so.loop,\n    c = _so.ilen,\n    h = El(o);\n  var _ref6 = s || {},\n    _ref6$move = _ref6.move,\n    d = _ref6$move === void 0 ? !0 : _ref6$move,\n    u = _ref6.reverse,\n    f,\n    g,\n    p;\n  for (f = 0; f <= c; ++f) g = n[(a + (u ? c - f : f)) % r], !g.skip && (d ? (i.moveTo(g.x, g.y), d = !1) : h(i, p, g, u, o.stepped), p = g);\n  return l && (g = n[(a + (u ? c : 0)) % r], h(i, p, g, u, o.stepped)), !!l;\n}\nfunction Il(i, t, e, s) {\n  var n = t.points,\n    _so2 = so(n, e, s),\n    o = _so2.count,\n    r = _so2.start,\n    a = _so2.ilen,\n    _ref7 = s || {},\n    _ref7$move = _ref7.move,\n    l = _ref7$move === void 0 ? !0 : _ref7$move,\n    c = _ref7.reverse;\n  var h = 0,\n    d = 0,\n    u,\n    f,\n    g,\n    p,\n    m,\n    b;\n  var x = function x(y) {\n      return (r + (c ? a - y : y)) % o;\n    },\n    v = function v() {\n      p !== m && (i.lineTo(h, m), i.lineTo(h, p), i.lineTo(h, b));\n    };\n  for (l && (f = n[x(0)], i.moveTo(f.x, f.y)), u = 0; u <= a; ++u) {\n    if (f = n[x(u)], f.skip) continue;\n    var y = f.x,\n      _ = f.y,\n      M = y | 0;\n    M === g ? (_ < p ? p = _ : _ > m && (m = _), h = (d * h + y) / ++d) : (v(), i.lineTo(y, _), g = M, d = 0, p = m = _), b = _;\n  }\n  v();\n}\nfunction Si(i) {\n  var t = i.options,\n    e = t.borderDash && t.borderDash.length;\n  return !i._decimated && !i._loop && !t.tension && t.cubicInterpolationMode !== \"monotone\" && !t.stepped && !e ? Il : Fl;\n}\nfunction zl(i) {\n  return i.stepped ? Wr : i.tension || i.cubicInterpolationMode === \"monotone\" ? Nr : Ct;\n}\nfunction Bl(i, t, e, s) {\n  var n = t._path;\n  n || (n = t._path = new Path2D(), t.path(n, e, s) && n.closePath()), io(i, t.options), i.stroke(n);\n}\nfunction Vl(i, t, e, s) {\n  var n = t.segments,\n    o = t.options,\n    r = Si(t);\n  var _iterator26 = _createForOfIteratorHelper(n),\n    _step26;\n  try {\n    for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n      var a = _step26.value;\n      io(i, o, a.style), i.beginPath(), r(i, t, a, {\n        start: e,\n        end: e + s - 1\n      }) && i.closePath(), i.stroke();\n    }\n  } catch (err) {\n    _iterator26.e(err);\n  } finally {\n    _iterator26.f();\n  }\n}\nvar Wl = typeof Path2D == \"function\";\nfunction Nl(i, t, e, s) {\n  Wl && !t.options.segment ? Bl(i, t, e, s) : Vl(i, t, e, s);\n}\nvar gt = /*#__PURE__*/function (_st3) {\n  _inherits(gt, _st3);\n  var _super13 = _createSuper(gt);\n  function gt(t) {\n    var _this24;\n    _classCallCheck(this, gt);\n    _this24 = _super13.call(this), _this24.animated = !0, _this24.options = void 0, _this24._chart = void 0, _this24._loop = void 0, _this24._fullLoop = void 0, _this24._path = void 0, _this24._points = void 0, _this24._segments = void 0, _this24._decimated = !1, _this24._pointsUpdated = !1, _this24._datasetIndex = void 0, t && Object.assign(_assertThisInitialized(_this24), t);\n    return _this24;\n  }\n  _createClass(gt, [{\n    key: \"updateControlPoints\",\n    value: function updateControlPoints(t, e) {\n      var s = this.options;\n      if ((s.tension || s.cubicInterpolationMode === \"monotone\") && !s.stepped && !this._pointsUpdated) {\n        var n = s.spanGaps ? this._loop : this._fullLoop;\n        Lr(this._points, s, t, n, e), this._pointsUpdated = !0;\n      }\n    }\n  }, {\n    key: \"points\",\n    get: function get() {\n      return this._points;\n    },\n    set: function set(t) {\n      this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;\n    }\n  }, {\n    key: \"segments\",\n    get: function get() {\n      return this._segments || (this._segments = Kr(this, this.options.segment));\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      var t = this.segments,\n        e = this.points;\n      return t.length && e[t[0].start];\n    }\n  }, {\n    key: \"last\",\n    value: function last() {\n      var t = this.segments,\n        e = this.points,\n        s = t.length;\n      return s && e[t[s - 1].end];\n    }\n  }, {\n    key: \"interpolate\",\n    value: function interpolate(t, e) {\n      var s = this.options,\n        n = t[e],\n        o = this.points,\n        r = Fn(this, {\n          property: e,\n          start: n,\n          end: n\n        });\n      if (!r.length) return;\n      var a = [],\n        l = zl(s);\n      var c, h;\n      for (c = 0, h = r.length; c < h; ++c) {\n        var _r$c = r[c],\n          d = _r$c.start,\n          u = _r$c.end,\n          f = o[d],\n          g = o[u];\n        if (f === g) {\n          a.push(f);\n          continue;\n        }\n        var p = Math.abs((n - f[e]) / (g[e] - f[e])),\n          m = l(f, g, p, s.stepped);\n        m[e] = t[e], a.push(m);\n      }\n      return a.length === 1 ? a[0] : a;\n    }\n  }, {\n    key: \"pathSegment\",\n    value: function pathSegment(t, e, s) {\n      return Si(this)(t, this, e, s);\n    }\n  }, {\n    key: \"path\",\n    value: function path(t, e, s) {\n      var n = this.segments,\n        o = Si(this);\n      var r = this._loop;\n      e = e || 0, s = s || this.points.length - e;\n      var _iterator27 = _createForOfIteratorHelper(n),\n        _step27;\n      try {\n        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n          var a = _step27.value;\n          r &= o(t, this, a, {\n            start: e,\n            end: e + s - 1\n          });\n        }\n      } catch (err) {\n        _iterator27.e(err);\n      } finally {\n        _iterator27.f();\n      }\n      return !!r;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(t, e, s, n) {\n      var o = this.options || {};\n      (this.points || []).length && o.borderWidth && (t.save(), Nl(t, this, s, n), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);\n    }\n  }]);\n  return gt;\n}(st);\ngt.id = \"line\";\ngt.defaults = {\n  borderCapStyle: \"butt\",\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: \"miter\",\n  borderWidth: 3,\n  capBezierPoints: !0,\n  cubicInterpolationMode: \"default\",\n  fill: !1,\n  spanGaps: !1,\n  stepped: !1,\n  tension: 0\n};\ngt.defaultRoutes = {\n  backgroundColor: \"backgroundColor\",\n  borderColor: \"borderColor\"\n};\ngt.descriptors = {\n  _scriptable: !0,\n  _indexable: function _indexable(i) {\n    return i !== \"borderDash\" && i !== \"fill\";\n  }\n};\nfunction Vs(i, t, e, s) {\n  var n = i.options,\n    _i$getProps = i.getProps([e], s),\n    o = _i$getProps[e];\n  return Math.abs(t - o) < n.radius + n.hitRadius;\n}\nvar ve = /*#__PURE__*/function (_st4) {\n  _inherits(ve, _st4);\n  var _super14 = _createSuper(ve);\n  function ve(t) {\n    var _this25;\n    _classCallCheck(this, ve);\n    _this25 = _super14.call(this), _this25.options = void 0, _this25.parsed = void 0, _this25.skip = void 0, _this25.stop = void 0, t && Object.assign(_assertThisInitialized(_this25), t);\n    return _this25;\n  }\n  _createClass(ve, [{\n    key: \"inRange\",\n    value: function inRange(t, e, s) {\n      var n = this.options,\n        _this$getProps4 = this.getProps([\"x\", \"y\"], s),\n        o = _this$getProps4.x,\n        r = _this$getProps4.y;\n      return Math.pow(t - o, 2) + Math.pow(e - r, 2) < Math.pow(n.hitRadius + n.radius, 2);\n    }\n  }, {\n    key: \"inXRange\",\n    value: function inXRange(t, e) {\n      return Vs(this, t, \"x\", e);\n    }\n  }, {\n    key: \"inYRange\",\n    value: function inYRange(t, e) {\n      return Vs(this, t, \"y\", e);\n    }\n  }, {\n    key: \"getCenterPoint\",\n    value: function getCenterPoint(t) {\n      var _this$getProps5 = this.getProps([\"x\", \"y\"], t),\n        e = _this$getProps5.x,\n        s = _this$getProps5.y;\n      return {\n        x: e,\n        y: s\n      };\n    }\n  }, {\n    key: \"size\",\n    value: function size(t) {\n      t = t || this.options || {};\n      var e = t.radius || 0;\n      e = Math.max(e, e && t.hoverRadius || 0);\n      var s = e && t.borderWidth || 0;\n      return (e + s) * 2;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(t, e) {\n      var s = this.options;\n      this.skip || s.radius < 0.1 || !re(this, e, this.size(s) / 2) || (t.strokeStyle = s.borderColor, t.lineWidth = s.borderWidth, t.fillStyle = s.backgroundColor, yi(t, s, this.x, this.y));\n    }\n  }, {\n    key: \"getRange\",\n    value: function getRange() {\n      var t = this.options || {};\n      return t.radius + t.hitRadius;\n    }\n  }]);\n  return ve;\n}(st);\nve.id = \"point\";\nve.defaults = {\n  borderWidth: 1,\n  hitRadius: 1,\n  hoverBorderWidth: 1,\n  hoverRadius: 4,\n  pointStyle: \"circle\",\n  radius: 3,\n  rotation: 0\n};\nve.defaultRoutes = {\n  backgroundColor: \"backgroundColor\",\n  borderColor: \"borderColor\"\n};\nfunction no(i, t) {\n  var _i$getProps2 = i.getProps([\"x\", \"y\", \"base\", \"width\", \"height\"], t),\n    e = _i$getProps2.x,\n    s = _i$getProps2.y,\n    n = _i$getProps2.base,\n    o = _i$getProps2.width,\n    r = _i$getProps2.height;\n  var a, l, c, h, d;\n  return i.horizontal ? (d = r / 2, a = Math.min(e, n), l = Math.max(e, n), c = s - d, h = s + d) : (d = o / 2, a = e - d, l = e + d, c = Math.min(s, n), h = Math.max(s, n)), {\n    left: a,\n    top: c,\n    right: l,\n    bottom: h\n  };\n}\nfunction bt(i, t, e, s) {\n  return i ? 0 : Y(t, e, s);\n}\nfunction Hl(i, t, e) {\n  var s = i.options.borderWidth,\n    n = i.borderSkipped,\n    o = kn(s);\n  return {\n    t: bt(n.top, o.top, 0, e),\n    r: bt(n.right, o.right, 0, t),\n    b: bt(n.bottom, o.bottom, 0, e),\n    l: bt(n.left, o.left, 0, t)\n  };\n}\nfunction jl(i, t, e) {\n  var _i$getProps3 = i.getProps([\"enableBorderRadius\"]),\n    s = _i$getProps3.enableBorderRadius,\n    n = i.options.borderRadius,\n    o = Dt(n),\n    r = Math.min(t, e),\n    a = i.borderSkipped,\n    l = s || D(n);\n  return {\n    topLeft: bt(!l || a.top || a.left, o.topLeft, 0, r),\n    topRight: bt(!l || a.top || a.right, o.topRight, 0, r),\n    bottomLeft: bt(!l || a.bottom || a.left, o.bottomLeft, 0, r),\n    bottomRight: bt(!l || a.bottom || a.right, o.bottomRight, 0, r)\n  };\n}\nfunction $l(i) {\n  var t = no(i),\n    e = t.right - t.left,\n    s = t.bottom - t.top,\n    n = Hl(i, e / 2, s / 2),\n    o = jl(i, e / 2, s / 2);\n  return {\n    outer: {\n      x: t.left,\n      y: t.top,\n      w: e,\n      h: s,\n      radius: o\n    },\n    inner: {\n      x: t.left + n.l,\n      y: t.top + n.t,\n      w: e - n.l - n.r,\n      h: s - n.t - n.b,\n      radius: {\n        topLeft: Math.max(0, o.topLeft - Math.max(n.t, n.l)),\n        topRight: Math.max(0, o.topRight - Math.max(n.t, n.r)),\n        bottomLeft: Math.max(0, o.bottomLeft - Math.max(n.b, n.l)),\n        bottomRight: Math.max(0, o.bottomRight - Math.max(n.b, n.r))\n      }\n    }\n  };\n}\nfunction gi(i, t, e, s) {\n  var n = t === null,\n    o = e === null,\n    a = i && !(n && o) && no(i, s);\n  return a && (n || ut(t, a.left, a.right)) && (o || ut(e, a.top, a.bottom));\n}\nfunction Yl(i) {\n  return i.topLeft || i.topRight || i.bottomLeft || i.bottomRight;\n}\nfunction Xl(i, t) {\n  i.rect(t.x, t.y, t.w, t.h);\n}\nfunction pi(i, t) {\n  var e = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var s = i.x !== e.x ? -t : 0,\n    n = i.y !== e.y ? -t : 0,\n    o = (i.x + i.w !== e.x + e.w ? t : 0) - s,\n    r = (i.y + i.h !== e.y + e.h ? t : 0) - n;\n  return {\n    x: i.x + s,\n    y: i.y + n,\n    w: i.w + o,\n    h: i.h + r,\n    radius: i.radius\n  };\n}\nvar Me = /*#__PURE__*/function (_st5) {\n  _inherits(Me, _st5);\n  var _super15 = _createSuper(Me);\n  function Me(t) {\n    var _this26;\n    _classCallCheck(this, Me);\n    _this26 = _super15.call(this), _this26.options = void 0, _this26.horizontal = void 0, _this26.base = void 0, _this26.width = void 0, _this26.height = void 0, _this26.inflateAmount = void 0, t && Object.assign(_assertThisInitialized(_this26), t);\n    return _this26;\n  }\n  _createClass(Me, [{\n    key: \"draw\",\n    value: function draw(t) {\n      var e = this.inflateAmount,\n        _this$options13 = this.options,\n        s = _this$options13.borderColor,\n        n = _this$options13.backgroundColor,\n        _$l = $l(this),\n        o = _$l.inner,\n        r = _$l.outer,\n        a = Yl(r.radius) ? ae : Xl;\n      t.save(), (r.w !== o.w || r.h !== o.h) && (t.beginPath(), a(t, pi(r, e, o)), t.clip(), a(t, pi(o, -e, r)), t.fillStyle = s, t.fill(\"evenodd\")), t.beginPath(), a(t, pi(o, e)), t.fillStyle = n, t.fill(), t.restore();\n    }\n  }, {\n    key: \"inRange\",\n    value: function inRange(t, e, s) {\n      return gi(this, t, e, s);\n    }\n  }, {\n    key: \"inXRange\",\n    value: function inXRange(t, e) {\n      return gi(this, t, null, e);\n    }\n  }, {\n    key: \"inYRange\",\n    value: function inYRange(t, e) {\n      return gi(this, null, t, e);\n    }\n  }, {\n    key: \"getCenterPoint\",\n    value: function getCenterPoint(t) {\n      var _this$getProps6 = this.getProps([\"x\", \"y\", \"base\", \"horizontal\"], t),\n        e = _this$getProps6.x,\n        s = _this$getProps6.y,\n        n = _this$getProps6.base,\n        o = _this$getProps6.horizontal;\n      return {\n        x: o ? (e + n) / 2 : e,\n        y: o ? s : (s + n) / 2\n      };\n    }\n  }, {\n    key: \"getRange\",\n    value: function getRange(t) {\n      return t === \"x\" ? this.width / 2 : this.height / 2;\n    }\n  }]);\n  return Me;\n}(st);\nMe.id = \"bar\";\nMe.defaults = {\n  borderSkipped: \"start\",\n  borderWidth: 0,\n  borderRadius: 0,\n  inflateAmount: \"auto\",\n  pointStyle: void 0\n};\nMe.defaultRoutes = {\n  backgroundColor: \"backgroundColor\",\n  borderColor: \"borderColor\"\n};\nvar oo = /* @__PURE__ */Object.freeze({\n  __proto__: null,\n  ArcElement: ye,\n  LineElement: gt,\n  PointElement: ve,\n  BarElement: Me\n});\nfunction Ul(i, t, e, s, n) {\n  var o = n.samples || s;\n  if (o >= e) return i.slice(t, t + e);\n  var r = [],\n    a = (e - 2) / (o - 2);\n  var l = 0;\n  var c = t + e - 1;\n  var h = t,\n    d,\n    u,\n    f,\n    g,\n    p;\n  for (r[l++] = i[h], d = 0; d < o - 2; d++) {\n    var m = 0,\n      b = 0,\n      x = void 0;\n    var v = Math.floor((d + 1) * a) + 1 + t,\n      y = Math.min(Math.floor((d + 2) * a) + 1, e) + t,\n      _ = y - v;\n    for (x = v; x < y; x++) m += i[x].x, b += i[x].y;\n    m /= _, b /= _;\n    var M = Math.floor(d * a) + 1 + t,\n      k = Math.min(Math.floor((d + 1) * a) + 1, e) + t,\n      _i$h = i[h],\n      S = _i$h.x,\n      w = _i$h.y;\n    for (f = g = -1, x = M; x < k; x++) g = 0.5 * Math.abs((S - m) * (i[x].y - w) - (S - i[x].x) * (b - w)), g > f && (f = g, u = i[x], p = x);\n    r[l++] = u, h = p;\n  }\n  return r[l++] = i[c], r;\n}\nfunction Kl(i, t, e, s) {\n  var n = 0,\n    o = 0,\n    r,\n    a,\n    l,\n    c,\n    h,\n    d,\n    u,\n    f,\n    g,\n    p;\n  var m = [],\n    b = t + e - 1,\n    x = i[t].x,\n    y = i[b].x - x;\n  for (r = t; r < t + e; ++r) {\n    a = i[r], l = (a.x - x) / y * s, c = a.y;\n    var _ = l | 0;\n    if (_ === h) c < g ? (g = c, d = r) : c > p && (p = c, u = r), n = (o * n + a.x) / ++o;else {\n      var M = r - 1;\n      if (!T(d) && !T(u)) {\n        var k = Math.min(d, u),\n          S = Math.max(d, u);\n        k !== f && k !== M && m.push(_objectSpread(_objectSpread({}, i[k]), {}, {\n          x: n\n        })), S !== f && S !== M && m.push(_objectSpread(_objectSpread({}, i[S]), {}, {\n          x: n\n        }));\n      }\n      r > 0 && M !== f && m.push(i[M]), m.push(a), h = _, o = 0, g = p = c, d = u = f = r;\n    }\n  }\n  return m;\n}\nfunction ro(i) {\n  if (i._decimated) {\n    var t = i._data;\n    delete i._decimated, delete i._data, Object.defineProperty(i, \"data\", {\n      value: t\n    });\n  }\n}\nfunction Ws(i) {\n  i.data.datasets.forEach(function (t) {\n    ro(t);\n  });\n}\nfunction ql(i, t) {\n  var e = t.length;\n  var s = 0,\n    n;\n  var o = i.iScale,\n    _o$getUserBounds = o.getUserBounds(),\n    r = _o$getUserBounds.min,\n    a = _o$getUserBounds.max,\n    l = _o$getUserBounds.minDefined,\n    c = _o$getUserBounds.maxDefined;\n  return l && (s = Y(ft(t, o.axis, r).lo, 0, e - 1)), c ? n = Y(ft(t, o.axis, a).hi + 1, s, e) - s : n = e - s, {\n    start: s,\n    count: n\n  };\n}\nvar ao = {\n  id: \"decimation\",\n  defaults: {\n    algorithm: \"min-max\",\n    enabled: !1\n  },\n  beforeElementsUpdate: function beforeElementsUpdate(i, t, e) {\n    if (!e.enabled) {\n      Ws(i);\n      return;\n    }\n    var s = i.width;\n    i.data.datasets.forEach(function (n, o) {\n      var r = n._data,\n        a = n.indexAxis,\n        l = i.getDatasetMeta(o),\n        c = r || n.data;\n      if (Zt([a, i.options.indexAxis]) === \"y\" || !l.controller.supportsDecimation) return;\n      var h = i.scales[l.xAxisID];\n      if (h.type !== \"linear\" && h.type !== \"time\" || i.options.parsing) return;\n      var _ql = ql(l, c),\n        d = _ql.start,\n        u = _ql.count;\n      var f = e.threshold || 4 * s;\n      if (u <= f) {\n        ro(n);\n        return;\n      }\n      T(r) && (n._data = c, delete n.data, Object.defineProperty(n, \"data\", {\n        configurable: !0,\n        enumerable: !0,\n        get: function get() {\n          return this._decimated;\n        },\n        set: function set(p) {\n          this._data = p;\n        }\n      }));\n      var g;\n      switch (e.algorithm) {\n        case \"lttb\":\n          g = Ul(c, d, u, s, e);\n          break;\n        case \"min-max\":\n          g = Kl(c, d, u, s);\n          break;\n        default:\n          throw new Error(\"Unsupported decimation algorithm '\".concat(e.algorithm, \"'\"));\n      }\n      n._decimated = g;\n    });\n  },\n  destroy: function destroy(i) {\n    Ws(i);\n  }\n};\nfunction Gl(i, t, e) {\n  var s = i.segments,\n    n = i.points,\n    o = t.points,\n    r = [];\n  var _iterator28 = _createForOfIteratorHelper(s),\n    _step28;\n  try {\n    for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n      var a = _step28.value;\n      var l = a.start,\n        c = a.end;\n      c = $i(l, c, n);\n      var h = Pi(e, n[l], n[c], a.loop);\n      if (!t.segments) {\n        r.push({\n          source: a,\n          target: h,\n          start: n[l],\n          end: n[c]\n        });\n        continue;\n      }\n      var d = Fn(t, h);\n      var _iterator29 = _createForOfIteratorHelper(d),\n        _step29;\n      try {\n        for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n          var u = _step29.value;\n          var f = Pi(e, o[u.start], o[u.end], u.loop),\n            g = En(a, n, f);\n          var _iterator30 = _createForOfIteratorHelper(g),\n            _step30;\n          try {\n            for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n              var p = _step30.value;\n              r.push({\n                source: p,\n                target: u,\n                start: _defineProperty({}, e, Ns(h, f, \"start\", Math.max)),\n                end: _defineProperty({}, e, Ns(h, f, \"end\", Math.min))\n              });\n            }\n          } catch (err) {\n            _iterator30.e(err);\n          } finally {\n            _iterator30.f();\n          }\n        }\n      } catch (err) {\n        _iterator29.e(err);\n      } finally {\n        _iterator29.f();\n      }\n    }\n  } catch (err) {\n    _iterator28.e(err);\n  } finally {\n    _iterator28.f();\n  }\n  return r;\n}\nfunction Pi(i, t, e, s) {\n  if (s) return;\n  var n = t[i],\n    o = e[i];\n  return i === \"angle\" && (n = Z(n), o = Z(o)), {\n    property: i,\n    start: n,\n    end: o\n  };\n}\nfunction Zl(i, t) {\n  var _ref8 = i || {},\n    _ref8$x = _ref8.x,\n    e = _ref8$x === void 0 ? null : _ref8$x,\n    _ref8$y = _ref8.y,\n    s = _ref8$y === void 0 ? null : _ref8$y,\n    n = t.points,\n    o = [];\n  return t.segments.forEach(function (_ref9) {\n    var r = _ref9.start,\n      a = _ref9.end;\n    a = $i(r, a, n);\n    var l = n[r],\n      c = n[a];\n    s !== null ? (o.push({\n      x: l.x,\n      y: s\n    }), o.push({\n      x: c.x,\n      y: s\n    })) : e !== null && (o.push({\n      x: e,\n      y: l.y\n    }), o.push({\n      x: e,\n      y: c.y\n    }));\n  }), o;\n}\nfunction $i(i, t, e) {\n  for (; t > i; t--) {\n    var s = e[t];\n    if (!isNaN(s.x) && !isNaN(s.y)) break;\n  }\n  return t;\n}\nfunction Ns(i, t, e, s) {\n  return i && t ? s(i[e], t[e]) : i ? i[e] : t ? t[e] : 0;\n}\nfunction lo(i, t) {\n  var e = [],\n    s = !1;\n  return z(i) ? (s = !0, e = i) : e = Zl(i, t), e.length ? new gt({\n    points: e,\n    options: {\n      tension: 0\n    },\n    _loop: s,\n    _fullLoop: s\n  }) : null;\n}\nfunction Hs(i) {\n  return i && i.fill !== !1;\n}\nfunction Jl(i, t, e) {\n  var n = i[t].fill;\n  var o = [t];\n  var r;\n  if (!e) return n;\n  for (; n !== !1 && o.indexOf(n) === -1;) {\n    if (!N(n)) return n;\n    if (r = i[n], !r) return !1;\n    if (r.visible) return n;\n    o.push(n), n = r.fill;\n  }\n  return !1;\n}\nfunction Ql(i, t, e) {\n  var s = sc(i);\n  if (D(s)) return isNaN(s.value) ? !1 : s;\n  var n = parseFloat(s);\n  return N(n) && Math.floor(n) === n ? tc(s[0], t, n, e) : [\"origin\", \"start\", \"end\", \"stack\", \"shape\"].indexOf(s) >= 0 && s;\n}\nfunction tc(i, t, e, s) {\n  return (i === \"-\" || i === \"+\") && (e = t + e), e === t || e < 0 || e >= s ? !1 : e;\n}\nfunction ec(i, t) {\n  var e = null;\n  return i === \"start\" ? e = t.bottom : i === \"end\" ? e = t.top : D(i) ? e = t.getPixelForValue(i.value) : t.getBasePixel && (e = t.getBasePixel()), e;\n}\nfunction ic(i, t, e) {\n  var s;\n  return i === \"start\" ? s = e : i === \"end\" ? s = t.options.reverse ? t.min : t.max : D(i) ? s = i.value : s = t.getBaseValue(), s;\n}\nfunction sc(i) {\n  var t = i.options,\n    e = t.fill;\n  var s = C(e && e.target, e);\n  return s === void 0 && (s = !!t.backgroundColor), s === !1 || s === null ? !1 : s === !0 ? \"origin\" : s;\n}\nfunction nc(i) {\n  var t = i.scale,\n    e = i.index,\n    s = i.line,\n    n = [],\n    o = s.segments,\n    r = s.points,\n    a = oc(t, e);\n  a.push(lo({\n    x: null,\n    y: t.bottom\n  }, s));\n  for (var l = 0; l < o.length; l++) {\n    var c = o[l];\n    for (var h = c.start; h <= c.end; h++) rc(n, r[h], a);\n  }\n  return new gt({\n    points: n,\n    options: {}\n  });\n}\nfunction oc(i, t) {\n  var e = [],\n    s = i.getMatchingVisibleMetas(\"line\");\n  for (var n = 0; n < s.length; n++) {\n    var o = s[n];\n    if (o.index === t) break;\n    o.hidden || e.unshift(o.dataset);\n  }\n  return e;\n}\nfunction rc(i, t, e) {\n  var s = [];\n  for (var n = 0; n < e.length; n++) {\n    var o = e[n],\n      _ac = ac(o, t, \"x\"),\n      r = _ac.first,\n      a = _ac.last,\n      l = _ac.point;\n    if (!(!l || r && a)) {\n      if (r) s.unshift(l);else if (i.push(l), !a) break;\n    }\n  }\n  i.push.apply(i, s);\n}\nfunction ac(i, t, e) {\n  var s = i.interpolate(t, e);\n  if (!s) return {};\n  var n = s[e],\n    o = i.segments,\n    r = i.points;\n  var a = !1,\n    l = !1;\n  for (var c = 0; c < o.length; c++) {\n    var h = o[c],\n      d = r[h.start][e],\n      u = r[h.end][e];\n    if (ut(n, d, u)) {\n      a = n === d, l = n === u;\n      break;\n    }\n  }\n  return {\n    first: a,\n    last: l,\n    point: s\n  };\n}\nvar co = /*#__PURE__*/function () {\n  function co(t) {\n    _classCallCheck(this, co);\n    this.x = t.x, this.y = t.y, this.radius = t.radius;\n  }\n  _createClass(co, [{\n    key: \"pathSegment\",\n    value: function pathSegment(t, e, s) {\n      var n = this.x,\n        o = this.y,\n        r = this.radius;\n      return e = e || {\n        start: 0,\n        end: F\n      }, t.arc(n, o, r, e.end, e.start, !0), !s.bounds;\n    }\n  }, {\n    key: \"interpolate\",\n    value: function interpolate(t) {\n      var e = this.x,\n        s = this.y,\n        n = this.radius,\n        o = t.angle;\n      return {\n        x: e + Math.cos(o) * n,\n        y: s + Math.sin(o) * n,\n        angle: o\n      };\n    }\n  }]);\n  return co;\n}();\nfunction lc(i) {\n  var t = i.chart,\n    e = i.fill,\n    s = i.line;\n  if (N(e)) return cc(t, e);\n  if (e === \"stack\") return nc(i);\n  if (e === \"shape\") return !0;\n  var n = hc(i);\n  return n instanceof co ? n : lo(n, s);\n}\nfunction cc(i, t) {\n  var e = i.getDatasetMeta(t);\n  return e && i.isDatasetVisible(t) ? e.dataset : null;\n}\nfunction hc(i) {\n  return (i.scale || {}).getPointPositionForValue ? uc(i) : dc(i);\n}\nfunction dc(i) {\n  var _i$scale = i.scale,\n    t = _i$scale === void 0 ? {} : _i$scale,\n    e = i.fill,\n    s = ec(e, t);\n  if (N(s)) {\n    var n = t.isHorizontal();\n    return {\n      x: n ? s : null,\n      y: n ? null : s\n    };\n  }\n  return null;\n}\nfunction uc(i) {\n  var t = i.scale,\n    e = i.fill,\n    s = t.options,\n    n = t.getLabels().length,\n    o = s.reverse ? t.max : t.min,\n    r = ic(e, t, o),\n    a = [];\n  if (s.grid.circular) {\n    var l = t.getPointPositionForValue(0, o);\n    return new co({\n      x: l.x,\n      y: l.y,\n      radius: t.getDistanceFromCenterForValue(r)\n    });\n  }\n  for (var _l2 = 0; _l2 < n; ++_l2) a.push(t.getPointPositionForValue(_l2, r));\n  return a;\n}\nfunction mi(i, t, e) {\n  var s = lc(t),\n    n = t.line,\n    o = t.scale,\n    r = t.axis,\n    a = n.options,\n    l = a.fill,\n    c = a.backgroundColor,\n    _ref10 = l || {},\n    _ref10$above = _ref10.above,\n    h = _ref10$above === void 0 ? c : _ref10$above,\n    _ref10$below = _ref10.below,\n    d = _ref10$below === void 0 ? c : _ref10$below;\n  s && n.points.length && (Xe(i, e), fc(i, {\n    line: n,\n    target: s,\n    above: h,\n    below: d,\n    area: e,\n    scale: o,\n    axis: r\n  }), Ue(i));\n}\nfunction fc(i, t) {\n  var e = t.line,\n    s = t.target,\n    n = t.above,\n    o = t.below,\n    r = t.area,\n    a = t.scale,\n    l = e._loop ? \"angle\" : t.axis;\n  i.save(), l === \"x\" && o !== n && (js(i, s, r.top), $s(i, {\n    line: e,\n    target: s,\n    color: n,\n    scale: a,\n    property: l\n  }), i.restore(), i.save(), js(i, s, r.bottom)), $s(i, {\n    line: e,\n    target: s,\n    color: o,\n    scale: a,\n    property: l\n  }), i.restore();\n}\nfunction js(i, t, e) {\n  var s = t.segments,\n    n = t.points;\n  var o = !0,\n    r = !1;\n  i.beginPath();\n  var _iterator31 = _createForOfIteratorHelper(s),\n    _step31;\n  try {\n    for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n      var a = _step31.value;\n      var l = a.start,\n        c = a.end,\n        h = n[l],\n        d = n[$i(l, c, n)];\n      o ? (i.moveTo(h.x, h.y), o = !1) : (i.lineTo(h.x, e), i.lineTo(h.x, h.y)), r = !!t.pathSegment(i, a, {\n        move: r\n      }), r ? i.closePath() : i.lineTo(d.x, e);\n    }\n  } catch (err) {\n    _iterator31.e(err);\n  } finally {\n    _iterator31.f();\n  }\n  i.lineTo(t.first().x, e), i.closePath(), i.clip();\n}\nfunction $s(i, t) {\n  var e = t.line,\n    s = t.target,\n    n = t.property,\n    o = t.color,\n    r = t.scale,\n    a = Gl(e, s, n);\n  var _iterator32 = _createForOfIteratorHelper(a),\n    _step32;\n  try {\n    for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n      var _step32$value = _step32.value,\n        l = _step32$value.source,\n        c = _step32$value.target,\n        h = _step32$value.start,\n        d = _step32$value.end;\n      var _l$style = l.style,\n        _l$style2 = _l$style === void 0 ? {} : _l$style,\n        _l$style2$backgroundC = _l$style2.backgroundColor,\n        u = _l$style2$backgroundC === void 0 ? o : _l$style2$backgroundC,\n        f = s !== !0;\n      i.save(), i.fillStyle = u, gc(i, r, f && Pi(n, h, d)), i.beginPath();\n      var g = !!e.pathSegment(i, l);\n      var p = void 0;\n      if (f) {\n        g ? i.closePath() : Ys(i, s, d, n);\n        var m = !!s.pathSegment(i, c, {\n          move: g,\n          reverse: !0\n        });\n        p = g && m, p || Ys(i, s, h, n);\n      }\n      i.closePath(), i.fill(p ? \"evenodd\" : \"nonzero\"), i.restore();\n    }\n  } catch (err) {\n    _iterator32.e(err);\n  } finally {\n    _iterator32.f();\n  }\n}\nfunction gc(i, t, e) {\n  var _t$chart$chartArea = t.chart.chartArea,\n    s = _t$chart$chartArea.top,\n    n = _t$chart$chartArea.bottom,\n    _ref11 = e || {},\n    o = _ref11.property,\n    r = _ref11.start,\n    a = _ref11.end;\n  o === \"x\" && (i.beginPath(), i.rect(r, s, a - r, n - s), i.clip());\n}\nfunction Ys(i, t, e, s) {\n  var n = t.interpolate(e, s);\n  n && i.lineTo(n.x, n.y);\n}\nvar ho = {\n  id: \"filler\",\n  afterDatasetsUpdate: function afterDatasetsUpdate(i, t, e) {\n    var s = (i.data.datasets || []).length,\n      n = [];\n    var o, r, a, l;\n    for (r = 0; r < s; ++r) o = i.getDatasetMeta(r), a = o.dataset, l = null, a && a.options && a instanceof gt && (l = {\n      visible: i.isDatasetVisible(r),\n      index: r,\n      fill: Ql(a, r, s),\n      chart: i,\n      axis: o.controller.options.indexAxis,\n      scale: o.vScale,\n      line: a\n    }), o.$filler = l, n.push(l);\n    for (r = 0; r < s; ++r) l = n[r], !(!l || l.fill === !1) && (l.fill = Jl(n, r, e.propagate));\n  },\n  beforeDraw: function beforeDraw(i, t, e) {\n    var s = e.drawTime === \"beforeDraw\",\n      n = i.getSortedVisibleDatasetMetas(),\n      o = i.chartArea;\n    for (var r = n.length - 1; r >= 0; --r) {\n      var a = n[r].$filler;\n      a && (a.line.updateControlPoints(o, a.axis), s && a.fill && mi(i.ctx, a, o));\n    }\n  },\n  beforeDatasetsDraw: function beforeDatasetsDraw(i, t, e) {\n    if (e.drawTime !== \"beforeDatasetsDraw\") return;\n    var s = i.getSortedVisibleDatasetMetas();\n    for (var n = s.length - 1; n >= 0; --n) {\n      var o = s[n].$filler;\n      Hs(o) && mi(i.ctx, o, i.chartArea);\n    }\n  },\n  beforeDatasetDraw: function beforeDatasetDraw(i, t, e) {\n    var s = t.meta.$filler;\n    !Hs(s) || e.drawTime !== \"beforeDatasetDraw\" || mi(i.ctx, s, i.chartArea);\n  },\n  defaults: {\n    propagate: !0,\n    drawTime: \"beforeDatasetDraw\"\n  }\n};\nvar Xs = function Xs(i, t) {\n    var _i$boxHeight = i.boxHeight,\n      e = _i$boxHeight === void 0 ? t : _i$boxHeight,\n      _i$boxWidth = i.boxWidth,\n      s = _i$boxWidth === void 0 ? t : _i$boxWidth;\n    return i.usePointStyle && (e = Math.min(e, t), s = i.pointStyleWidth || Math.min(s, t)), {\n      boxWidth: s,\n      boxHeight: e,\n      itemHeight: Math.max(t, e)\n    };\n  },\n  pc = function pc(i, t) {\n    return i !== null && t !== null && i.datasetIndex === t.datasetIndex && i.index === t.index;\n  };\nvar Us = /*#__PURE__*/function (_st6) {\n  _inherits(Us, _st6);\n  var _super16 = _createSuper(Us);\n  function Us(t) {\n    var _this27;\n    _classCallCheck(this, Us);\n    _this27 = _super16.call(this), _this27._added = !1, _this27.legendHitBoxes = [], _this27._hoveredItem = null, _this27.doughnutMode = !1, _this27.chart = t.chart, _this27.options = t.options, _this27.ctx = t.ctx, _this27.legendItems = void 0, _this27.columnSizes = void 0, _this27.lineWidths = void 0, _this27.maxHeight = void 0, _this27.maxWidth = void 0, _this27.top = void 0, _this27.bottom = void 0, _this27.left = void 0, _this27.right = void 0, _this27.height = void 0, _this27.width = void 0, _this27._margins = void 0, _this27.position = void 0, _this27.weight = void 0, _this27.fullSize = void 0;\n    return _this27;\n  }\n  _createClass(Us, [{\n    key: \"update\",\n    value: function update(t, e, s) {\n      this.maxWidth = t, this.maxHeight = e, this._margins = s, this.setDimensions(), this.buildLabels(), this.fit();\n    }\n  }, {\n    key: \"setDimensions\",\n    value: function setDimensions() {\n      this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);\n    }\n  }, {\n    key: \"buildLabels\",\n    value: function buildLabels() {\n      var _this28 = this;\n      var t = this.options.labels || {};\n      var e = I(t.generateLabels, [this.chart], this) || [];\n      t.filter && (e = e.filter(function (s) {\n        return t.filter(s, _this28.chart.data);\n      })), t.sort && (e = e.sort(function (s, n) {\n        return t.sort(s, n, _this28.chart.data);\n      })), this.options.reverse && e.reverse(), this.legendItems = e;\n    }\n  }, {\n    key: \"fit\",\n    value: function fit() {\n      var t = this.options,\n        e = this.ctx;\n      if (!t.display) {\n        this.width = this.height = 0;\n        return;\n      }\n      var s = t.labels,\n        n = $(s.font),\n        o = n.size,\n        r = this._computeTitleHeight(),\n        _Xs = Xs(s, o),\n        a = _Xs.boxWidth,\n        l = _Xs.itemHeight;\n      var c, h;\n      e.font = n.string, this.isHorizontal() ? (c = this.maxWidth, h = this._fitRows(r, o, a, l) + 10) : (h = this.maxHeight, c = this._fitCols(r, o, a, l) + 10), this.width = Math.min(c, t.maxWidth || this.maxWidth), this.height = Math.min(h, t.maxHeight || this.maxHeight);\n    }\n  }, {\n    key: \"_fitRows\",\n    value: function _fitRows(t, e, s, n) {\n      var o = this.ctx,\n        r = this.maxWidth,\n        a = this.options.labels.padding,\n        l = this.legendHitBoxes = [],\n        c = this.lineWidths = [0],\n        h = n + a;\n      var d = t;\n      o.textAlign = \"left\", o.textBaseline = \"middle\";\n      var u = -1,\n        f = -h;\n      return this.legendItems.forEach(function (g, p) {\n        var m = s + e / 2 + o.measureText(g.text).width;\n        (p === 0 || c[c.length - 1] + m + 2 * a > r) && (d += h, c[c.length - (p > 0 ? 0 : 1)] = 0, f += h, u++), l[p] = {\n          left: 0,\n          top: f,\n          row: u,\n          width: m,\n          height: n\n        }, c[c.length - 1] += m + a;\n      }), d;\n    }\n  }, {\n    key: \"_fitCols\",\n    value: function _fitCols(t, e, s, n) {\n      var o = this.ctx,\n        r = this.maxHeight,\n        a = this.options.labels.padding,\n        l = this.legendHitBoxes = [],\n        c = this.columnSizes = [],\n        h = r - t;\n      var d = a,\n        u = 0,\n        f = 0,\n        g = 0,\n        p = 0;\n      return this.legendItems.forEach(function (m, b) {\n        var x = s + e / 2 + o.measureText(m.text).width;\n        b > 0 && f + n + 2 * a > h && (d += u + a, c.push({\n          width: u,\n          height: f\n        }), g += u + a, p++, u = f = 0), l[b] = {\n          left: g,\n          top: f,\n          col: p,\n          width: x,\n          height: n\n        }, u = Math.max(u, x), f += n + a;\n      }), d += u, c.push({\n        width: u,\n        height: f\n      }), d;\n    }\n  }, {\n    key: \"adjustHitBoxes\",\n    value: function adjustHitBoxes() {\n      if (!this.options.display) return;\n      var t = this._computeTitleHeight(),\n        e = this.legendHitBoxes,\n        _this$options14 = this.options,\n        s = _this$options14.align,\n        n = _this$options14.labels.padding,\n        o = _this$options14.rtl,\n        r = zt(o, this.left, this.width);\n      if (this.isHorizontal()) {\n        var a = 0,\n          l = U(s, this.left + n, this.right - this.lineWidths[a]);\n        var _iterator33 = _createForOfIteratorHelper(e),\n          _step33;\n        try {\n          for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n            var c = _step33.value;\n            a !== c.row && (a = c.row, l = U(s, this.left + n, this.right - this.lineWidths[a])), c.top += this.top + t + n, c.left = r.leftForLtr(r.x(l), c.width), l += c.width + n;\n          }\n        } catch (err) {\n          _iterator33.e(err);\n        } finally {\n          _iterator33.f();\n        }\n      } else {\n        var _a3 = 0,\n          _l3 = U(s, this.top + t + n, this.bottom - this.columnSizes[_a3].height);\n        var _iterator34 = _createForOfIteratorHelper(e),\n          _step34;\n        try {\n          for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n            var _c3 = _step34.value;\n            _c3.col !== _a3 && (_a3 = _c3.col, _l3 = U(s, this.top + t + n, this.bottom - this.columnSizes[_a3].height)), _c3.top = _l3, _c3.left += this.left + n, _c3.left = r.leftForLtr(r.x(_c3.left), _c3.width), _l3 += _c3.height + n;\n          }\n        } catch (err) {\n          _iterator34.e(err);\n        } finally {\n          _iterator34.f();\n        }\n      }\n    }\n  }, {\n    key: \"isHorizontal\",\n    value: function isHorizontal() {\n      return this.options.position === \"top\" || this.options.position === \"bottom\";\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      if (this.options.display) {\n        var t = this.ctx;\n        Xe(t, this), this._draw(), Ue(t);\n      }\n    }\n  }, {\n    key: \"_draw\",\n    value: function _draw() {\n      var _this29 = this;\n      var t = this.options,\n        e = this.columnSizes,\n        s = this.lineWidths,\n        n = this.ctx,\n        o = t.align,\n        r = t.labels,\n        a = O.color,\n        l = zt(t.rtl, this.left, this.width),\n        c = $(r.font),\n        h = r.color,\n        d = r.padding,\n        u = c.size,\n        f = u / 2;\n      var g;\n      this.drawTitle(), n.textAlign = l.textAlign(\"left\"), n.textBaseline = \"middle\", n.lineWidth = 0.5, n.font = c.string;\n      var _Xs2 = Xs(r, u),\n        p = _Xs2.boxWidth,\n        m = _Xs2.boxHeight,\n        b = _Xs2.itemHeight,\n        x = function x(k, S, w) {\n          if (isNaN(p) || p <= 0 || isNaN(m) || m < 0) return;\n          n.save();\n          var L = C(w.lineWidth, 1);\n          if (n.fillStyle = C(w.fillStyle, a), n.lineCap = C(w.lineCap, \"butt\"), n.lineDashOffset = C(w.lineDashOffset, 0), n.lineJoin = C(w.lineJoin, \"miter\"), n.lineWidth = L, n.strokeStyle = C(w.strokeStyle, a), n.setLineDash(C(w.lineDash, [])), r.usePointStyle) {\n            var R = {\n                radius: m * Math.SQRT2 / 2,\n                pointStyle: w.pointStyle,\n                rotation: w.rotation,\n                borderWidth: L\n              },\n              A = l.xPlus(k, p / 2),\n              H = S + f;\n            Mn(n, R, A, H, r.pointStyleWidth && p);\n          } else {\n            var _R = S + Math.max((u - m) / 2, 0),\n              _A = l.leftForLtr(k, p),\n              _H = Dt(w.borderRadius);\n            n.beginPath(), Object.values(_H).some(function (q) {\n              return q !== 0;\n            }) ? ae(n, {\n              x: _A,\n              y: _R,\n              w: p,\n              h: m,\n              radius: _H\n            }) : n.rect(_A, _R, p, m), n.fill(), L !== 0 && n.stroke();\n          }\n          n.restore();\n        },\n        v = function v(k, S, w) {\n          Tt(n, w.text, k, S + b / 2, c, {\n            strikethrough: w.hidden,\n            textAlign: l.textAlign(w.textAlign)\n          });\n        },\n        y = this.isHorizontal(),\n        _ = this._computeTitleHeight();\n      y ? g = {\n        x: U(o, this.left + d, this.right - s[0]),\n        y: this.top + d + _,\n        line: 0\n      } : g = {\n        x: this.left + d,\n        y: U(o, this.top + _ + d, this.bottom - e[0].height),\n        line: 0\n      }, Tn(this.ctx, t.textDirection);\n      var M = b + d;\n      this.legendItems.forEach(function (k, S) {\n        n.strokeStyle = k.fontColor || h, n.fillStyle = k.fontColor || h;\n        var w = n.measureText(k.text).width,\n          L = l.textAlign(k.textAlign || (k.textAlign = r.textAlign)),\n          R = p + f + w;\n        var A = g.x,\n          H = g.y;\n        l.setWidth(_this29.width), y ? S > 0 && A + R + d > _this29.right && (H = g.y += M, g.line++, A = g.x = U(o, _this29.left + d, _this29.right - s[g.line])) : S > 0 && H + M > _this29.bottom && (A = g.x = A + e[g.line].width + d, g.line++, H = g.y = U(o, _this29.top + _ + d, _this29.bottom - e[g.line].height));\n        var q = l.x(A);\n        x(q, H, k), A = Io(L, A + p + f, y ? A + R : _this29.right, t.rtl), v(l.x(A), H, k), y ? g.x += R + d : g.y += M;\n      }), Ln(this.ctx, t.textDirection);\n    }\n  }, {\n    key: \"drawTitle\",\n    value: function drawTitle() {\n      var t = this.options,\n        e = t.title,\n        s = $(e.font),\n        n = K(e.padding);\n      if (!e.display) return;\n      var o = zt(t.rtl, this.left, this.width),\n        r = this.ctx,\n        a = e.position,\n        l = s.size / 2,\n        c = n.top + l;\n      var h,\n        d = this.left,\n        u = this.width;\n      if (this.isHorizontal()) u = Math.max.apply(Math, _toConsumableArray(this.lineWidths)), h = this.top + c, d = U(t.align, d, this.right - u);else {\n        var g = this.columnSizes.reduce(function (p, m) {\n          return Math.max(p, m.height);\n        }, 0);\n        h = c + U(t.align, this.top, this.bottom - g - t.labels.padding - this._computeTitleHeight());\n      }\n      var f = U(a, d, d + u);\n      r.textAlign = o.textAlign(Li(a)), r.textBaseline = \"middle\", r.strokeStyle = e.color, r.fillStyle = e.color, r.font = s.string, Tt(r, e.text, f, h, s);\n    }\n  }, {\n    key: \"_computeTitleHeight\",\n    value: function _computeTitleHeight() {\n      var t = this.options.title,\n        e = $(t.font),\n        s = K(t.padding);\n      return t.display ? e.lineHeight + s.height : 0;\n    }\n  }, {\n    key: \"_getLegendItemAt\",\n    value: function _getLegendItemAt(t, e) {\n      var s, n, o;\n      if (ut(t, this.left, this.right) && ut(e, this.top, this.bottom)) {\n        for (o = this.legendHitBoxes, s = 0; s < o.length; ++s) if (n = o[s], ut(t, n.left, n.left + n.width) && ut(e, n.top, n.top + n.height)) return this.legendItems[s];\n      }\n      return null;\n    }\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(t) {\n      var e = this.options;\n      if (!mc(t.type, e)) return;\n      var s = this._getLegendItemAt(t.x, t.y);\n      if (t.type === \"mousemove\" || t.type === \"mouseout\") {\n        var n = this._hoveredItem,\n          o = pc(n, s);\n        n && !o && I(e.onLeave, [t, n, this], this), this._hoveredItem = s, s && !o && I(e.onHover, [t, s, this], this);\n      } else s && I(e.onClick, [t, s, this], this);\n    }\n  }]);\n  return Us;\n}(st);\nfunction mc(i, t) {\n  return !!((i === \"mousemove\" || i === \"mouseout\") && (t.onHover || t.onLeave) || t.onClick && (i === \"click\" || i === \"mouseup\"));\n}\nvar uo = {\n  id: \"legend\",\n  _element: Us,\n  start: function start(i, t, e) {\n    var s = i.legend = new Us({\n      ctx: i.ctx,\n      options: e,\n      chart: i\n    });\n    X.configure(i, s, e), X.addBox(i, s);\n  },\n  stop: function stop(i) {\n    X.removeBox(i, i.legend), delete i.legend;\n  },\n  beforeUpdate: function beforeUpdate(i, t, e) {\n    var s = i.legend;\n    X.configure(i, s, e), s.options = e;\n  },\n  afterUpdate: function afterUpdate(i) {\n    var t = i.legend;\n    t.buildLabels(), t.adjustHitBoxes();\n  },\n  afterEvent: function afterEvent(i, t) {\n    t.replay || i.legend.handleEvent(t.event);\n  },\n  defaults: {\n    display: !0,\n    position: \"top\",\n    align: \"center\",\n    fullSize: !0,\n    reverse: !1,\n    weight: 1e3,\n    onClick: function onClick(i, t, e) {\n      var s = t.datasetIndex,\n        n = e.chart;\n      n.isDatasetVisible(s) ? (n.hide(s), t.hidden = !0) : (n.show(s), t.hidden = !1);\n    },\n    onHover: null,\n    onLeave: null,\n    labels: {\n      color: function color(i) {\n        return i.chart.options.color;\n      },\n      boxWidth: 40,\n      padding: 10,\n      generateLabels: function generateLabels(i) {\n        var t = i.data.datasets,\n          _i$legend$options$lab = i.legend.options.labels,\n          e = _i$legend$options$lab.usePointStyle,\n          s = _i$legend$options$lab.pointStyle,\n          n = _i$legend$options$lab.textAlign,\n          o = _i$legend$options$lab.color;\n        return i._getSortedDatasetMetas().map(function (r) {\n          var a = r.controller.getStyle(e ? 0 : void 0),\n            l = K(a.borderWidth);\n          return {\n            text: t[r.index].label,\n            fillStyle: a.backgroundColor,\n            fontColor: o,\n            hidden: !r.visible,\n            lineCap: a.borderCapStyle,\n            lineDash: a.borderDash,\n            lineDashOffset: a.borderDashOffset,\n            lineJoin: a.borderJoinStyle,\n            lineWidth: (l.width + l.height) / 4,\n            strokeStyle: a.borderColor,\n            pointStyle: s || a.pointStyle,\n            rotation: a.rotation,\n            textAlign: n || a.textAlign,\n            borderRadius: 0,\n            datasetIndex: r.index\n          };\n        }, this);\n      }\n    },\n    title: {\n      color: function color(i) {\n        return i.chart.options.color;\n      },\n      display: !1,\n      position: \"center\",\n      text: \"\"\n    }\n  },\n  descriptors: {\n    _scriptable: function _scriptable(i) {\n      return !i.startsWith(\"on\");\n    },\n    labels: {\n      _scriptable: function _scriptable(i) {\n        return ![\"generateLabels\", \"filter\", \"sort\"].includes(i);\n      }\n    }\n  }\n};\nvar Yi = /*#__PURE__*/function (_st7) {\n  _inherits(Yi, _st7);\n  var _super17 = _createSuper(Yi);\n  function Yi(t) {\n    var _this30;\n    _classCallCheck(this, Yi);\n    _this30 = _super17.call(this), _this30.chart = t.chart, _this30.options = t.options, _this30.ctx = t.ctx, _this30._padding = void 0, _this30.top = void 0, _this30.bottom = void 0, _this30.left = void 0, _this30.right = void 0, _this30.width = void 0, _this30.height = void 0, _this30.position = void 0, _this30.weight = void 0, _this30.fullSize = void 0;\n    return _this30;\n  }\n  _createClass(Yi, [{\n    key: \"update\",\n    value: function update(t, e) {\n      var s = this.options;\n      if (this.left = 0, this.top = 0, !s.display) {\n        this.width = this.height = this.right = this.bottom = 0;\n        return;\n      }\n      this.width = this.right = t, this.height = this.bottom = e;\n      var n = z(s.text) ? s.text.length : 1;\n      this._padding = K(s.padding);\n      var o = n * $(s.font).lineHeight + this._padding.height;\n      this.isHorizontal() ? this.height = o : this.width = o;\n    }\n  }, {\n    key: \"isHorizontal\",\n    value: function isHorizontal() {\n      var t = this.options.position;\n      return t === \"top\" || t === \"bottom\";\n    }\n  }, {\n    key: \"_drawArgs\",\n    value: function _drawArgs(t) {\n      var e = this.top,\n        s = this.left,\n        n = this.bottom,\n        o = this.right,\n        r = this.options,\n        a = r.align;\n      var l = 0,\n        c,\n        h,\n        d;\n      return this.isHorizontal() ? (h = U(a, s, o), d = e + t, c = o - s) : (r.position === \"left\" ? (h = s + t, d = U(a, n, e), l = B * -0.5) : (h = o - t, d = U(a, e, n), l = B * 0.5), c = n - e), {\n        titleX: h,\n        titleY: d,\n        maxWidth: c,\n        rotation: l\n      };\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var t = this.ctx,\n        e = this.options;\n      if (!e.display) return;\n      var s = $(e.font),\n        o = s.lineHeight / 2 + this._padding.top,\n        _this$_drawArgs = this._drawArgs(o),\n        r = _this$_drawArgs.titleX,\n        a = _this$_drawArgs.titleY,\n        l = _this$_drawArgs.maxWidth,\n        c = _this$_drawArgs.rotation;\n      Tt(t, e.text, 0, 0, s, {\n        color: e.color,\n        maxWidth: l,\n        rotation: c,\n        textAlign: Li(e.align),\n        textBaseline: \"middle\",\n        translation: [r, a]\n      });\n    }\n  }]);\n  return Yi;\n}(st);\nfunction bc(i, t) {\n  var e = new Yi({\n    ctx: i.ctx,\n    options: t,\n    chart: i\n  });\n  X.configure(i, e, t), X.addBox(i, e), i.titleBlock = e;\n}\nvar fo = {\n  id: \"title\",\n  _element: Yi,\n  start: function start(i, t, e) {\n    bc(i, e);\n  },\n  stop: function stop(i) {\n    var t = i.titleBlock;\n    X.removeBox(i, t), delete i.titleBlock;\n  },\n  beforeUpdate: function beforeUpdate(i, t, e) {\n    var s = i.titleBlock;\n    X.configure(i, s, e), s.options = e;\n  },\n  defaults: {\n    align: \"center\",\n    display: !1,\n    font: {\n      weight: \"bold\"\n    },\n    fullSize: !0,\n    padding: 10,\n    position: \"top\",\n    text: \"\",\n    weight: 2e3\n  },\n  defaultRoutes: {\n    color: \"color\"\n  },\n  descriptors: {\n    _scriptable: !0,\n    _indexable: !1\n  }\n};\nvar Re = /* @__PURE__ */new WeakMap();\nvar go = {\n  id: \"subtitle\",\n  start: function start(i, t, e) {\n    var s = new Yi({\n      ctx: i.ctx,\n      options: e,\n      chart: i\n    });\n    X.configure(i, s, e), X.addBox(i, s), Re.set(i, s);\n  },\n  stop: function stop(i) {\n    X.removeBox(i, Re.get(i)), Re.delete(i);\n  },\n  beforeUpdate: function beforeUpdate(i, t, e) {\n    var s = Re.get(i);\n    X.configure(i, s, e), s.options = e;\n  },\n  defaults: {\n    align: \"center\",\n    display: !1,\n    font: {\n      weight: \"normal\"\n    },\n    fullSize: !0,\n    padding: 0,\n    position: \"top\",\n    text: \"\",\n    weight: 1500\n  },\n  defaultRoutes: {\n    color: \"color\"\n  },\n  descriptors: {\n    _scriptable: !0,\n    _indexable: !1\n  }\n};\nvar se = {\n  average: function average(i) {\n    if (!i.length) return !1;\n    var t,\n      e,\n      s = 0,\n      n = 0,\n      o = 0;\n    for (t = 0, e = i.length; t < e; ++t) {\n      var r = i[t].element;\n      if (r && r.hasValue()) {\n        var a = r.tooltipPosition();\n        s += a.x, n += a.y, ++o;\n      }\n    }\n    return {\n      x: s / o,\n      y: n / o\n    };\n  },\n  nearest: function nearest(i, t) {\n    if (!i.length) return !1;\n    var e = t.x,\n      s = t.y,\n      n = Number.POSITIVE_INFINITY,\n      o,\n      r,\n      a;\n    for (o = 0, r = i.length; o < r; ++o) {\n      var l = i[o].element;\n      if (l && l.hasValue()) {\n        var c = l.getCenterPoint(),\n          h = bi(t, c);\n        h < n && (n = h, a = l);\n      }\n    }\n    if (a) {\n      var _l4 = a.tooltipPosition();\n      e = _l4.x, s = _l4.y;\n    }\n    return {\n      x: e,\n      y: s\n    };\n  }\n};\nfunction rt(i, t) {\n  return t && (z(t) ? Array.prototype.push.apply(i, t) : i.push(t)), i;\n}\nfunction ht(i) {\n  return (typeof i == \"string\" || i instanceof String) && i.indexOf(\"\\n\") > -1 ? i.split(\"\\n\") : i;\n}\nfunction xc(i, t) {\n  var e = t.element,\n    s = t.datasetIndex,\n    n = t.index,\n    o = i.getDatasetMeta(s).controller,\n    _o$getLabelAndValue = o.getLabelAndValue(n),\n    r = _o$getLabelAndValue.label,\n    a = _o$getLabelAndValue.value;\n  return {\n    chart: i,\n    label: r,\n    parsed: o.getParsed(n),\n    raw: i.data.datasets[s].data[n],\n    formattedValue: a,\n    dataset: o.getDataset(),\n    dataIndex: n,\n    datasetIndex: s,\n    element: e\n  };\n}\nfunction Ks(i, t) {\n  var e = i.chart.ctx,\n    s = i.body,\n    n = i.footer,\n    o = i.title,\n    r = t.boxWidth,\n    a = t.boxHeight,\n    l = $(t.bodyFont),\n    c = $(t.titleFont),\n    h = $(t.footerFont),\n    d = o.length,\n    u = n.length,\n    f = s.length,\n    g = K(t.padding);\n  var p = g.height,\n    m = 0,\n    b = s.reduce(function (y, _) {\n      return y + _.before.length + _.lines.length + _.after.length;\n    }, 0);\n  if (b += i.beforeBody.length + i.afterBody.length, d && (p += d * c.lineHeight + (d - 1) * t.titleSpacing + t.titleMarginBottom), b) {\n    var y = t.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight;\n    p += f * y + (b - f) * l.lineHeight + (b - 1) * t.bodySpacing;\n  }\n  u && (p += t.footerMarginTop + u * h.lineHeight + (u - 1) * t.footerSpacing);\n  var x = 0;\n  var v = function v(y) {\n    m = Math.max(m, e.measureText(y).width + x);\n  };\n  return e.save(), e.font = c.string, E(i.title, v), e.font = l.string, E(i.beforeBody.concat(i.afterBody), v), x = t.displayColors ? r + 2 + t.boxPadding : 0, E(s, function (y) {\n    E(y.before, v), E(y.lines, v), E(y.after, v);\n  }), x = 0, e.font = h.string, E(i.footer, v), e.restore(), m += g.width, {\n    width: m,\n    height: p\n  };\n}\nfunction _c(i, t) {\n  var e = t.y,\n    s = t.height;\n  return e < s / 2 ? \"top\" : e > i.height - s / 2 ? \"bottom\" : \"center\";\n}\nfunction yc(i, t, e, s) {\n  var n = s.x,\n    o = s.width,\n    r = e.caretSize + e.caretPadding;\n  if (i === \"left\" && n + o + r > t.width || i === \"right\" && n - o - r < 0) return !0;\n}\nfunction vc(i, t, e, s) {\n  var n = e.x,\n    o = e.width,\n    r = i.width,\n    _i$chartArea = i.chartArea,\n    a = _i$chartArea.left,\n    l = _i$chartArea.right;\n  var c = \"center\";\n  return s === \"center\" ? c = n <= (a + l) / 2 ? \"left\" : \"right\" : n <= o / 2 ? c = \"left\" : n >= r - o / 2 && (c = \"right\"), yc(c, i, t, e) && (c = \"center\"), c;\n}\nfunction qs(i, t, e) {\n  var s = e.yAlign || t.yAlign || _c(i, e);\n  return {\n    xAlign: e.xAlign || t.xAlign || vc(i, t, e, s),\n    yAlign: s\n  };\n}\nfunction Mc(i, t) {\n  var e = i.x,\n    s = i.width;\n  return t === \"right\" ? e -= s : t === \"center\" && (e -= s / 2), e;\n}\nfunction kc(i, t, e) {\n  var s = i.y,\n    n = i.height;\n  return t === \"top\" ? s += e : t === \"bottom\" ? s -= n + e : s -= n / 2, s;\n}\nfunction Gs(i, t, e, s) {\n  var n = i.caretSize,\n    o = i.caretPadding,\n    r = i.cornerRadius,\n    a = e.xAlign,\n    l = e.yAlign,\n    c = n + o,\n    _Dt = Dt(r),\n    h = _Dt.topLeft,\n    d = _Dt.topRight,\n    u = _Dt.bottomLeft,\n    f = _Dt.bottomRight;\n  var g = Mc(t, a);\n  var p = kc(t, l, c);\n  return l === \"center\" ? a === \"left\" ? g += c : a === \"right\" && (g -= c) : a === \"left\" ? g -= Math.max(h, u) + n : a === \"right\" && (g += Math.max(d, f) + n), {\n    x: Y(g, 0, s.width - t.width),\n    y: Y(p, 0, s.height - t.height)\n  };\n}\nfunction Ee(i, t, e) {\n  var s = K(e.padding);\n  return t === \"center\" ? i.x + i.width / 2 : t === \"right\" ? i.x + i.width - s.right : i.x + s.left;\n}\nfunction Zs(i) {\n  return rt([], ht(i));\n}\nfunction wc(i, t, e) {\n  return vt(i, {\n    tooltip: t,\n    tooltipItems: e,\n    type: \"tooltip\"\n  });\n}\nfunction Js(i, t) {\n  var e = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;\n  return e ? i.override(e) : i;\n}\nvar Ci = /*#__PURE__*/function (_st8) {\n  _inherits(Ci, _st8);\n  var _super18 = _createSuper(Ci);\n  function Ci(t) {\n    var _this31;\n    _classCallCheck(this, Ci);\n    _this31 = _super18.call(this), _this31.opacity = 0, _this31._active = [], _this31._eventPosition = void 0, _this31._size = void 0, _this31._cachedAnimations = void 0, _this31._tooltipItems = [], _this31.$animations = void 0, _this31.$context = void 0, _this31.chart = t.chart || t._chart, _this31._chart = _this31.chart, _this31.options = t.options, _this31.dataPoints = void 0, _this31.title = void 0, _this31.beforeBody = void 0, _this31.body = void 0, _this31.afterBody = void 0, _this31.footer = void 0, _this31.xAlign = void 0, _this31.yAlign = void 0, _this31.x = void 0, _this31.y = void 0, _this31.height = void 0, _this31.width = void 0, _this31.caretX = void 0, _this31.caretY = void 0, _this31.labelColors = void 0, _this31.labelPointStyles = void 0, _this31.labelTextColors = void 0;\n    return _this31;\n  }\n  _createClass(Ci, [{\n    key: \"initialize\",\n    value: function initialize(t) {\n      this.options = t, this._cachedAnimations = void 0, this.$context = void 0;\n    }\n  }, {\n    key: \"_resolveAnimations\",\n    value: function _resolveAnimations() {\n      var t = this._cachedAnimations;\n      if (t) return t;\n      var e = this.chart,\n        s = this.options.setContext(this.getContext()),\n        n = s.enabled && e.options.animation && s.animations,\n        o = new Ni(this.chart, n);\n      return n._cacheable && (this._cachedAnimations = Object.freeze(o)), o;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.$context || (this.$context = wc(this.chart.getContext(), this, this._tooltipItems));\n    }\n  }, {\n    key: \"getTitle\",\n    value: function getTitle(t, e) {\n      var s = e.callbacks,\n        n = s.beforeTitle.apply(this, [t]),\n        o = s.title.apply(this, [t]),\n        r = s.afterTitle.apply(this, [t]);\n      var a = [];\n      return a = rt(a, ht(n)), a = rt(a, ht(o)), a = rt(a, ht(r)), a;\n    }\n  }, {\n    key: \"getBeforeBody\",\n    value: function getBeforeBody(t, e) {\n      return Zs(e.callbacks.beforeBody.apply(this, [t]));\n    }\n  }, {\n    key: \"getBody\",\n    value: function getBody(t, e) {\n      var _this32 = this;\n      var s = e.callbacks,\n        n = [];\n      return E(t, function (o) {\n        var r = {\n            before: [],\n            lines: [],\n            after: []\n          },\n          a = Js(s, o);\n        rt(r.before, ht(a.beforeLabel.call(_this32, o))), rt(r.lines, a.label.call(_this32, o)), rt(r.after, ht(a.afterLabel.call(_this32, o))), n.push(r);\n      }), n;\n    }\n  }, {\n    key: \"getAfterBody\",\n    value: function getAfterBody(t, e) {\n      return Zs(e.callbacks.afterBody.apply(this, [t]));\n    }\n  }, {\n    key: \"getFooter\",\n    value: function getFooter(t, e) {\n      var s = e.callbacks,\n        n = s.beforeFooter.apply(this, [t]),\n        o = s.footer.apply(this, [t]),\n        r = s.afterFooter.apply(this, [t]);\n      var a = [];\n      return a = rt(a, ht(n)), a = rt(a, ht(o)), a = rt(a, ht(r)), a;\n    }\n  }, {\n    key: \"_createItems\",\n    value: function _createItems(t) {\n      var _this33 = this;\n      var e = this._active,\n        s = this.chart.data,\n        n = [],\n        o = [],\n        r = [];\n      var a = [],\n        l,\n        c;\n      for (l = 0, c = e.length; l < c; ++l) a.push(xc(this.chart, e[l]));\n      return t.filter && (a = a.filter(function (h, d, u) {\n        return t.filter(h, d, u, s);\n      })), t.itemSort && (a = a.sort(function (h, d) {\n        return t.itemSort(h, d, s);\n      })), E(a, function (h) {\n        var d = Js(t.callbacks, h);\n        n.push(d.labelColor.call(_this33, h)), o.push(d.labelPointStyle.call(_this33, h)), r.push(d.labelTextColor.call(_this33, h));\n      }), this.labelColors = n, this.labelPointStyles = o, this.labelTextColors = r, this.dataPoints = a, a;\n    }\n  }, {\n    key: \"update\",\n    value: function update(t, e) {\n      var s = this.options.setContext(this.getContext()),\n        n = this._active;\n      var o,\n        r = [];\n      if (!n.length) this.opacity !== 0 && (o = {\n        opacity: 0\n      });else {\n        var a = se[s.position].call(this, n, this._eventPosition);\n        r = this._createItems(s), this.title = this.getTitle(r, s), this.beforeBody = this.getBeforeBody(r, s), this.body = this.getBody(r, s), this.afterBody = this.getAfterBody(r, s), this.footer = this.getFooter(r, s);\n        var l = this._size = Ks(this, s),\n          c = Object.assign({}, a, l),\n          h = qs(this.chart, s, c),\n          d = Gs(s, c, h, this.chart);\n        this.xAlign = h.xAlign, this.yAlign = h.yAlign, o = {\n          opacity: 1,\n          x: d.x,\n          y: d.y,\n          width: l.width,\n          height: l.height,\n          caretX: a.x,\n          caretY: a.y\n        };\n      }\n      this._tooltipItems = r, this.$context = void 0, o && this._resolveAnimations().update(this, o), t && s.external && s.external.call(this, {\n        chart: this.chart,\n        tooltip: this,\n        replay: e\n      });\n    }\n  }, {\n    key: \"drawCaret\",\n    value: function drawCaret(t, e, s, n) {\n      var o = this.getCaretPosition(t, s, n);\n      e.lineTo(o.x1, o.y1), e.lineTo(o.x2, o.y2), e.lineTo(o.x3, o.y3);\n    }\n  }, {\n    key: \"getCaretPosition\",\n    value: function getCaretPosition(t, e, s) {\n      var n = this.xAlign,\n        o = this.yAlign,\n        r = s.caretSize,\n        a = s.cornerRadius,\n        _Dt2 = Dt(a),\n        l = _Dt2.topLeft,\n        c = _Dt2.topRight,\n        h = _Dt2.bottomLeft,\n        d = _Dt2.bottomRight,\n        u = t.x,\n        f = t.y,\n        g = e.width,\n        p = e.height;\n      var m, b, x, v, y, _;\n      return o === \"center\" ? (y = f + p / 2, n === \"left\" ? (m = u, b = m - r, v = y + r, _ = y - r) : (m = u + g, b = m + r, v = y - r, _ = y + r), x = m) : (n === \"left\" ? b = u + Math.max(l, h) + r : n === \"right\" ? b = u + g - Math.max(c, d) - r : b = this.caretX, o === \"top\" ? (v = f, y = v - r, m = b - r, x = b + r) : (v = f + p, y = v + r, m = b + r, x = b - r), _ = v), {\n        x1: m,\n        x2: b,\n        x3: x,\n        y1: v,\n        y2: y,\n        y3: _\n      };\n    }\n  }, {\n    key: \"drawTitle\",\n    value: function drawTitle(t, e, s) {\n      var n = this.title,\n        o = n.length;\n      var r, a, l;\n      if (o) {\n        var c = zt(s.rtl, this.x, this.width);\n        for (t.x = Ee(this, s.titleAlign, s), e.textAlign = c.textAlign(s.titleAlign), e.textBaseline = \"middle\", r = $(s.titleFont), a = s.titleSpacing, e.fillStyle = s.titleColor, e.font = r.string, l = 0; l < o; ++l) e.fillText(n[l], c.x(t.x), t.y + r.lineHeight / 2), t.y += r.lineHeight + a, l + 1 === o && (t.y += s.titleMarginBottom - a);\n      }\n    }\n  }, {\n    key: \"_drawColorBox\",\n    value: function _drawColorBox(t, e, s, n, o) {\n      var r = this.labelColors[s],\n        a = this.labelPointStyles[s],\n        l = o.boxHeight,\n        c = o.boxWidth,\n        h = o.boxPadding,\n        d = $(o.bodyFont),\n        u = Ee(this, \"left\", o),\n        f = n.x(u),\n        g = l < d.lineHeight ? (d.lineHeight - l) / 2 : 0,\n        p = e.y + g;\n      if (o.usePointStyle) {\n        var m = {\n            radius: Math.min(c, l) / 2,\n            pointStyle: a.pointStyle,\n            rotation: a.rotation,\n            borderWidth: 1\n          },\n          b = n.leftForLtr(f, c) + c / 2,\n          x = p + l / 2;\n        t.strokeStyle = o.multiKeyBackground, t.fillStyle = o.multiKeyBackground, yi(t, m, b, x), t.strokeStyle = r.borderColor, t.fillStyle = r.backgroundColor, yi(t, m, b, x);\n      } else {\n        t.lineWidth = D(r.borderWidth) ? Math.max.apply(Math, _toConsumableArray(Object.values(r.borderWidth))) : r.borderWidth || 1, t.strokeStyle = r.borderColor, t.setLineDash(r.borderDash || []), t.lineDashOffset = r.borderDashOffset || 0;\n        var _m = n.leftForLtr(f, c - h),\n          _b4 = n.leftForLtr(n.xPlus(f, 1), c - h - 2),\n          _x2 = Dt(r.borderRadius);\n        Object.values(_x2).some(function (v) {\n          return v !== 0;\n        }) ? (t.beginPath(), t.fillStyle = o.multiKeyBackground, ae(t, {\n          x: _m,\n          y: p,\n          w: c,\n          h: l,\n          radius: _x2\n        }), t.fill(), t.stroke(), t.fillStyle = r.backgroundColor, t.beginPath(), ae(t, {\n          x: _b4,\n          y: p + 1,\n          w: c - 2,\n          h: l - 2,\n          radius: _x2\n        }), t.fill()) : (t.fillStyle = o.multiKeyBackground, t.fillRect(_m, p, c, l), t.strokeRect(_m, p, c, l), t.fillStyle = r.backgroundColor, t.fillRect(_b4, p + 1, c - 2, l - 2));\n      }\n      t.fillStyle = this.labelTextColors[s];\n    }\n  }, {\n    key: \"drawBody\",\n    value: function drawBody(t, e, s) {\n      var n = this.body,\n        o = s.bodySpacing,\n        r = s.bodyAlign,\n        a = s.displayColors,\n        l = s.boxHeight,\n        c = s.boxWidth,\n        h = s.boxPadding,\n        d = $(s.bodyFont);\n      var u = d.lineHeight,\n        f = 0;\n      var g = zt(s.rtl, this.x, this.width),\n        p = function p(S) {\n          e.fillText(S, g.x(t.x + f), t.y + u / 2), t.y += u + o;\n        },\n        m = g.textAlign(r);\n      var b, x, v, y, _, M, k;\n      for (e.textAlign = r, e.textBaseline = \"middle\", e.font = d.string, t.x = Ee(this, m, s), e.fillStyle = s.bodyColor, E(this.beforeBody, p), f = a && m !== \"right\" ? r === \"center\" ? c / 2 + h : c + 2 + h : 0, y = 0, M = n.length; y < M; ++y) {\n        for (b = n[y], x = this.labelTextColors[y], e.fillStyle = x, E(b.before, p), v = b.lines, a && v.length && (this._drawColorBox(e, t, y, g, s), u = Math.max(d.lineHeight, l)), _ = 0, k = v.length; _ < k; ++_) p(v[_]), u = d.lineHeight;\n        E(b.after, p);\n      }\n      f = 0, u = d.lineHeight, E(this.afterBody, p), t.y -= o;\n    }\n  }, {\n    key: \"drawFooter\",\n    value: function drawFooter(t, e, s) {\n      var n = this.footer,\n        o = n.length;\n      var r, a;\n      if (o) {\n        var l = zt(s.rtl, this.x, this.width);\n        for (t.x = Ee(this, s.footerAlign, s), t.y += s.footerMarginTop, e.textAlign = l.textAlign(s.footerAlign), e.textBaseline = \"middle\", r = $(s.footerFont), e.fillStyle = s.footerColor, e.font = r.string, a = 0; a < o; ++a) e.fillText(n[a], l.x(t.x), t.y + r.lineHeight / 2), t.y += r.lineHeight + s.footerSpacing;\n      }\n    }\n  }, {\n    key: \"drawBackground\",\n    value: function drawBackground(t, e, s, n) {\n      var o = this.xAlign,\n        r = this.yAlign,\n        a = t.x,\n        l = t.y,\n        c = s.width,\n        h = s.height,\n        _Dt3 = Dt(n.cornerRadius),\n        d = _Dt3.topLeft,\n        u = _Dt3.topRight,\n        f = _Dt3.bottomLeft,\n        g = _Dt3.bottomRight;\n      e.fillStyle = n.backgroundColor, e.strokeStyle = n.borderColor, e.lineWidth = n.borderWidth, e.beginPath(), e.moveTo(a + d, l), r === \"top\" && this.drawCaret(t, e, s, n), e.lineTo(a + c - u, l), e.quadraticCurveTo(a + c, l, a + c, l + u), r === \"center\" && o === \"right\" && this.drawCaret(t, e, s, n), e.lineTo(a + c, l + h - g), e.quadraticCurveTo(a + c, l + h, a + c - g, l + h), r === \"bottom\" && this.drawCaret(t, e, s, n), e.lineTo(a + f, l + h), e.quadraticCurveTo(a, l + h, a, l + h - f), r === \"center\" && o === \"left\" && this.drawCaret(t, e, s, n), e.lineTo(a, l + d), e.quadraticCurveTo(a, l, a + d, l), e.closePath(), e.fill(), n.borderWidth > 0 && e.stroke();\n    }\n  }, {\n    key: \"_updateAnimationTarget\",\n    value: function _updateAnimationTarget(t) {\n      var e = this.chart,\n        s = this.$animations,\n        n = s && s.x,\n        o = s && s.y;\n      if (n || o) {\n        var r = se[t.position].call(this, this._active, this._eventPosition);\n        if (!r) return;\n        var a = this._size = Ks(this, t),\n          l = Object.assign({}, r, this._size),\n          c = qs(e, t, l),\n          h = Gs(t, l, c, e);\n        (n._to !== h.x || o._to !== h.y) && (this.xAlign = c.xAlign, this.yAlign = c.yAlign, this.width = a.width, this.height = a.height, this.caretX = r.x, this.caretY = r.y, this._resolveAnimations().update(this, h));\n      }\n    }\n  }, {\n    key: \"_willRender\",\n    value: function _willRender() {\n      return !!this.opacity;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(t) {\n      var e = this.options.setContext(this.getContext());\n      var s = this.opacity;\n      if (!s) return;\n      this._updateAnimationTarget(e);\n      var n = {\n          width: this.width,\n          height: this.height\n        },\n        o = {\n          x: this.x,\n          y: this.y\n        };\n      s = Math.abs(s) < 1e-3 ? 0 : s;\n      var r = K(e.padding),\n        a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n      e.enabled && a && (t.save(), t.globalAlpha = s, this.drawBackground(o, t, n, e), Tn(t, e.textDirection), o.y += r.top, this.drawTitle(o, t, e), this.drawBody(o, t, e), this.drawFooter(o, t, e), Ln(t, e.textDirection), t.restore());\n    }\n  }, {\n    key: \"getActiveElements\",\n    value: function getActiveElements() {\n      return this._active || [];\n    }\n  }, {\n    key: \"setActiveElements\",\n    value: function setActiveElements(t, e) {\n      var _this34 = this;\n      var s = this._active,\n        n = t.map(function (_ref12) {\n          var a = _ref12.datasetIndex,\n            l = _ref12.index;\n          var c = _this34.chart.getDatasetMeta(a);\n          if (!c) throw new Error(\"Cannot find a dataset at index \" + a);\n          return {\n            datasetIndex: a,\n            element: c.data[l],\n            index: l\n          };\n        }),\n        o = !ze(s, n),\n        r = this._positionChanged(n, e);\n      (o || r) && (this._active = n, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0));\n    }\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(t, e) {\n      var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;\n      if (e && this._ignoreReplayEvents) return !1;\n      this._ignoreReplayEvents = !1;\n      var n = this.options,\n        o = this._active || [],\n        r = this._getActiveElements(t, o, e, s),\n        a = this._positionChanged(r, t),\n        l = e || !ze(r, o) || a;\n      return l && (this._active = r, (n.enabled || n.external) && (this._eventPosition = {\n        x: t.x,\n        y: t.y\n      }, this.update(!0, e))), l;\n    }\n  }, {\n    key: \"_getActiveElements\",\n    value: function _getActiveElements(t, e, s, n) {\n      var o = this.options;\n      if (t.type === \"mouseout\") return [];\n      if (!n) return e;\n      var r = this.chart.getElementsAtEventForMode(t, o.mode, o, s);\n      return o.reverse && r.reverse(), r;\n    }\n  }, {\n    key: \"_positionChanged\",\n    value: function _positionChanged(t, e) {\n      var s = this.caretX,\n        n = this.caretY,\n        o = this.options,\n        r = se[o.position].call(this, t, e);\n      return r !== !1 && (s !== r.x || n !== r.y);\n    }\n  }]);\n  return Ci;\n}(st);\nCi.positioners = se;\nvar po = {\n    id: \"tooltip\",\n    _element: Ci,\n    positioners: se,\n    afterInit: function afterInit(i, t, e) {\n      e && (i.tooltip = new Ci({\n        chart: i,\n        options: e\n      }));\n    },\n    beforeUpdate: function beforeUpdate(i, t, e) {\n      i.tooltip && i.tooltip.initialize(e);\n    },\n    reset: function reset(i, t, e) {\n      i.tooltip && i.tooltip.initialize(e);\n    },\n    afterDraw: function afterDraw(i) {\n      var t = i.tooltip;\n      if (t && t._willRender()) {\n        var e = {\n          tooltip: t\n        };\n        if (i.notifyPlugins(\"beforeTooltipDraw\", e) === !1) return;\n        t.draw(i.ctx), i.notifyPlugins(\"afterTooltipDraw\", e);\n      }\n    },\n    afterEvent: function afterEvent(i, t) {\n      if (i.tooltip) {\n        var e = t.replay;\n        i.tooltip.handleEvent(t.event, e, t.inChartArea) && (t.changed = !0);\n      }\n    },\n    defaults: {\n      enabled: !0,\n      external: null,\n      position: \"average\",\n      backgroundColor: \"rgba(0,0,0,0.8)\",\n      titleColor: \"#fff\",\n      titleFont: {\n        weight: \"bold\"\n      },\n      titleSpacing: 2,\n      titleMarginBottom: 6,\n      titleAlign: \"left\",\n      bodyColor: \"#fff\",\n      bodySpacing: 2,\n      bodyFont: {},\n      bodyAlign: \"left\",\n      footerColor: \"#fff\",\n      footerSpacing: 2,\n      footerMarginTop: 6,\n      footerFont: {\n        weight: \"bold\"\n      },\n      footerAlign: \"left\",\n      padding: 6,\n      caretPadding: 2,\n      caretSize: 5,\n      cornerRadius: 6,\n      boxHeight: function boxHeight(i, t) {\n        return t.bodyFont.size;\n      },\n      boxWidth: function boxWidth(i, t) {\n        return t.bodyFont.size;\n      },\n      multiKeyBackground: \"#fff\",\n      displayColors: !0,\n      boxPadding: 0,\n      borderColor: \"rgba(0,0,0,0)\",\n      borderWidth: 0,\n      animation: {\n        duration: 400,\n        easing: \"easeOutQuart\"\n      },\n      animations: {\n        numbers: {\n          type: \"number\",\n          properties: [\"x\", \"y\", \"width\", \"height\", \"caretX\", \"caretY\"]\n        },\n        opacity: {\n          easing: \"linear\",\n          duration: 200\n        }\n      },\n      callbacks: {\n        beforeTitle: ct,\n        title: function title(i) {\n          if (i.length > 0) {\n            var t = i[0],\n              e = t.chart.data.labels,\n              s = e ? e.length : 0;\n            if (this && this.options && this.options.mode === \"dataset\") return t.dataset.label || \"\";\n            if (t.label) return t.label;\n            if (s > 0 && t.dataIndex < s) return e[t.dataIndex];\n          }\n          return \"\";\n        },\n        afterTitle: ct,\n        beforeBody: ct,\n        beforeLabel: ct,\n        label: function label(i) {\n          if (this && this.options && this.options.mode === \"dataset\") return i.label + \": \" + i.formattedValue || i.formattedValue;\n          var t = i.dataset.label || \"\";\n          t && (t += \": \");\n          var e = i.formattedValue;\n          return T(e) || (t += e), t;\n        },\n        labelColor: function labelColor(i) {\n          var e = i.chart.getDatasetMeta(i.datasetIndex).controller.getStyle(i.dataIndex);\n          return {\n            borderColor: e.borderColor,\n            backgroundColor: e.backgroundColor,\n            borderWidth: e.borderWidth,\n            borderDash: e.borderDash,\n            borderDashOffset: e.borderDashOffset,\n            borderRadius: 0\n          };\n        },\n        labelTextColor: function labelTextColor() {\n          return this.options.bodyColor;\n        },\n        labelPointStyle: function labelPointStyle(i) {\n          var e = i.chart.getDatasetMeta(i.datasetIndex).controller.getStyle(i.dataIndex);\n          return {\n            pointStyle: e.pointStyle,\n            rotation: e.rotation\n          };\n        },\n        afterLabel: ct,\n        afterBody: ct,\n        beforeFooter: ct,\n        footer: ct,\n        afterFooter: ct\n      }\n    },\n    defaultRoutes: {\n      bodyFont: \"font\",\n      footerFont: \"font\",\n      titleFont: \"font\"\n    },\n    descriptors: {\n      _scriptable: function _scriptable(i) {\n        return i !== \"filter\" && i !== \"itemSort\" && i !== \"external\";\n      },\n      _indexable: !1,\n      callbacks: {\n        _scriptable: !1,\n        _indexable: !1\n      },\n      animation: {\n        _fallback: !1\n      },\n      animations: {\n        _fallback: \"animation\"\n      }\n    },\n    additionalOptionScopes: [\"interaction\"]\n  },\n  mo = /* @__PURE__ */Object.freeze({\n    __proto__: null,\n    Decimation: ao,\n    Filler: ho,\n    Legend: uo,\n    SubTitle: go,\n    Title: fo,\n    Tooltip: po\n  });\nvar Sc = function Sc(i, t, e, s) {\n  return typeof t == \"string\" ? (e = i.push(t) - 1, s.unshift({\n    index: e,\n    label: t\n  })) : isNaN(t) && (e = null), e;\n};\nfunction Pc(i, t, e, s) {\n  var n = i.indexOf(t);\n  if (n === -1) return Sc(i, t, e, s);\n  var o = i.lastIndexOf(t);\n  return n !== o ? e : n;\n}\nvar Cc = function Cc(i, t) {\n  return i === null ? null : Y(Math.round(i), 0, t);\n};\nvar ce = /*#__PURE__*/function (_Mt) {\n  _inherits(ce, _Mt);\n  var _super19 = _createSuper(ce);\n  function ce(t) {\n    var _this35;\n    _classCallCheck(this, ce);\n    _this35 = _super19.call(this, t), _this35._startValue = void 0, _this35._valueRange = 0, _this35._addedLabels = [];\n    return _this35;\n  }\n  _createClass(ce, [{\n    key: \"init\",\n    value: function init(t) {\n      var e = this._addedLabels;\n      if (e.length) {\n        var s = this.getLabels();\n        var _iterator35 = _createForOfIteratorHelper(e),\n          _step35;\n        try {\n          for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n            var _step35$value = _step35.value,\n              n = _step35$value.index,\n              o = _step35$value.label;\n            s[n] === o && s.splice(n, 1);\n          }\n        } catch (err) {\n          _iterator35.e(err);\n        } finally {\n          _iterator35.f();\n        }\n        this._addedLabels = [];\n      }\n      _get(_getPrototypeOf(ce.prototype), \"init\", this).call(this, t);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(t, e) {\n      if (T(t)) return null;\n      var s = this.getLabels();\n      return e = isFinite(e) && s[e] === t ? e : Pc(s, t, C(e, t), this._addedLabels), Cc(e, s.length - 1);\n    }\n  }, {\n    key: \"determineDataLimits\",\n    value: function determineDataLimits() {\n      var _this$getUserBounds2 = this.getUserBounds(),\n        t = _this$getUserBounds2.minDefined,\n        e = _this$getUserBounds2.maxDefined;\n      var _this$getMinMax = this.getMinMax(!0),\n        s = _this$getMinMax.min,\n        n = _this$getMinMax.max;\n      this.options.bounds === \"ticks\" && (t || (s = 0), e || (n = this.getLabels().length - 1)), this.min = s, this.max = n;\n    }\n  }, {\n    key: \"buildTicks\",\n    value: function buildTicks() {\n      var t = this.min,\n        e = this.max,\n        s = this.options.offset,\n        n = [];\n      var o = this.getLabels();\n      o = t === 0 && e === o.length - 1 ? o : o.slice(t, e + 1), this._valueRange = Math.max(o.length - (s ? 0 : 1), 1), this._startValue = this.min - (s ? 0.5 : 0);\n      for (var r = t; r <= e; r++) n.push({\n        value: r\n      });\n      return n;\n    }\n  }, {\n    key: \"getLabelForValue\",\n    value: function getLabelForValue(t) {\n      var e = this.getLabels();\n      return t >= 0 && t < e.length ? e[t] : t;\n    }\n  }, {\n    key: \"configure\",\n    value: function configure() {\n      _get(_getPrototypeOf(ce.prototype), \"configure\", this).call(this), this.isHorizontal() || (this._reversePixels = !this._reversePixels);\n    }\n  }, {\n    key: \"getPixelForValue\",\n    value: function getPixelForValue(t) {\n      return typeof t != \"number\" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);\n    }\n  }, {\n    key: \"getPixelForTick\",\n    value: function getPixelForTick(t) {\n      var e = this.ticks;\n      return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);\n    }\n  }, {\n    key: \"getValueForPixel\",\n    value: function getValueForPixel(t) {\n      return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);\n    }\n  }, {\n    key: \"getBasePixel\",\n    value: function getBasePixel() {\n      return this.bottom;\n    }\n  }]);\n  return ce;\n}(Mt);\nce.id = \"category\";\nce.defaults = {\n  ticks: {\n    callback: ce.prototype.getLabelForValue\n  }\n};\nfunction Dc(i, t) {\n  var e = [],\n    n = i.bounds,\n    o = i.step,\n    r = i.min,\n    a = i.max,\n    l = i.precision,\n    c = i.count,\n    h = i.maxTicks,\n    d = i.maxDigits,\n    u = i.includeBounds,\n    f = o || 1,\n    g = h - 1,\n    p = t.min,\n    m = t.max,\n    b = !T(r),\n    x = !T(a),\n    v = !T(c),\n    y = (m - p) / (d + 1);\n  var _ = qi((m - p) / g / f) * f,\n    M,\n    k,\n    S,\n    w;\n  if (_ < 1e-14 && !b && !x) return [{\n    value: p\n  }, {\n    value: m\n  }];\n  w = Math.ceil(m / _) - Math.floor(p / _), w > g && (_ = qi(w * _ / g / f) * f), T(l) || (M = Math.pow(10, l), _ = Math.ceil(_ * M) / M), n === \"ticks\" ? (k = Math.floor(p / _) * _, S = Math.ceil(m / _) * _) : (k = p, S = m), b && x && o && Oo((a - r) / o, _ / 1e3) ? (w = Math.round(Math.min((a - r) / _, h)), _ = (a - r) / w, k = r, S = a) : v ? (k = b ? r : k, S = x ? a : S, w = c - 1, _ = (S - k) / w) : (w = (S - k) / _, te(w, Math.round(w), _ / 1e3) ? w = Math.round(w) : w = Math.ceil(w));\n  var L = Math.max(Gi(_), Gi(k));\n  M = Math.pow(10, T(l) ? L : l), k = Math.round(k * M) / M, S = Math.round(S * M) / M;\n  var R = 0;\n  for (b && (u && k !== r ? (e.push({\n    value: r\n  }), k < r && R++, te(Math.round((k + R * _) * M) / M, r, Qs(r, y, i)) && R++) : k < r && R++); R < w; ++R) e.push({\n    value: Math.round((k + R * _) * M) / M\n  });\n  return x && u && S !== a ? e.length && te(e[e.length - 1].value, a, Qs(a, y, i)) ? e[e.length - 1].value = a : e.push({\n    value: a\n  }) : (!x || S === a) && e.push({\n    value: S\n  }), e;\n}\nfunction Qs(i, t, _ref13) {\n  var e = _ref13.horizontal,\n    s = _ref13.minRotation;\n  var n = nt(s),\n    o = (e ? Math.sin(n) : Math.cos(n)) || 1e-3,\n    r = 0.75 * t * (\"\" + i).length;\n  return Math.min(t / o, r);\n}\nvar Ye = /*#__PURE__*/function (_Mt2) {\n  _inherits(Ye, _Mt2);\n  var _super20 = _createSuper(Ye);\n  function Ye(t) {\n    var _this36;\n    _classCallCheck(this, Ye);\n    _this36 = _super20.call(this, t), _this36.start = void 0, _this36.end = void 0, _this36._startValue = void 0, _this36._endValue = void 0, _this36._valueRange = 0;\n    return _this36;\n  }\n  _createClass(Ye, [{\n    key: \"parse\",\n    value: function parse(t, e) {\n      return T(t) || (typeof t == \"number\" || t instanceof Number) && !isFinite(+t) ? null : +t;\n    }\n  }, {\n    key: \"handleTickRangeOptions\",\n    value: function handleTickRangeOptions() {\n      var t = this.options.beginAtZero,\n        _this$getUserBounds3 = this.getUserBounds(),\n        e = _this$getUserBounds3.minDefined,\n        s = _this$getUserBounds3.maxDefined;\n      var n = this.min,\n        o = this.max;\n      var r = function r(l) {\n          return n = e ? n : l;\n        },\n        a = function a(l) {\n          return o = s ? o : l;\n        };\n      if (t) {\n        var l = lt(n),\n          c = lt(o);\n        l < 0 && c < 0 ? a(0) : l > 0 && c > 0 && r(0);\n      }\n      if (n === o) {\n        var _l5 = 1;\n        (o >= Number.MAX_SAFE_INTEGER || n <= Number.MIN_SAFE_INTEGER) && (_l5 = Math.abs(o * 0.05)), a(o + _l5), t || r(n - _l5);\n      }\n      this.min = n, this.max = o;\n    }\n  }, {\n    key: \"getTickLimit\",\n    value: function getTickLimit() {\n      var t = this.options.ticks;\n      var e = t.maxTicksLimit,\n        s = t.stepSize,\n        n;\n      return s ? (n = Math.ceil(this.max / s) - Math.floor(this.min / s) + 1, n > 1e3 && (console.warn(\"scales.\".concat(this.id, \".ticks.stepSize: \").concat(s, \" would result generating up to \").concat(n, \" ticks. Limiting to 1000.\")), n = 1e3)) : (n = this.computeTickLimit(), e = e || 11), e && (n = Math.min(e, n)), n;\n    }\n  }, {\n    key: \"computeTickLimit\",\n    value: function computeTickLimit() {\n      return Number.POSITIVE_INFINITY;\n    }\n  }, {\n    key: \"buildTicks\",\n    value: function buildTicks() {\n      var t = this.options,\n        e = t.ticks;\n      var s = this.getTickLimit();\n      s = Math.max(2, s);\n      var n = {\n          maxTicks: s,\n          bounds: t.bounds,\n          min: t.min,\n          max: t.max,\n          precision: e.precision,\n          step: e.stepSize,\n          count: e.count,\n          maxDigits: this._maxDigits(),\n          horizontal: this.isHorizontal(),\n          minRotation: e.minRotation || 0,\n          includeBounds: e.includeBounds !== !1\n        },\n        o = this._range || this,\n        r = Dc(n, o);\n      return t.bounds === \"ticks\" && cn(r, this, \"value\"), t.reverse ? (r.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), r;\n    }\n  }, {\n    key: \"configure\",\n    value: function configure() {\n      var t = this.ticks;\n      var e = this.min,\n        s = this.max;\n      if (_get(_getPrototypeOf(Ye.prototype), \"configure\", this).call(this), this.options.offset && t.length) {\n        var n = (s - e) / Math.max(t.length - 1, 1) / 2;\n        e -= n, s += n;\n      }\n      this._startValue = e, this._endValue = s, this._valueRange = s - e;\n    }\n  }, {\n    key: \"getLabelForValue\",\n    value: function getLabelForValue(t) {\n      return de(t, this.chart.options.locale, this.options.ticks.format);\n    }\n  }]);\n  return Ye;\n}(Mt);\nvar Ge = /*#__PURE__*/function (_Ye) {\n  _inherits(Ge, _Ye);\n  var _super21 = _createSuper(Ge);\n  function Ge() {\n    _classCallCheck(this, Ge);\n    return _super21.apply(this, arguments);\n  }\n  _createClass(Ge, [{\n    key: \"determineDataLimits\",\n    value: function determineDataLimits() {\n      var _this$getMinMax2 = this.getMinMax(!0),\n        t = _this$getMinMax2.min,\n        e = _this$getMinMax2.max;\n      this.min = N(t) ? t : 0, this.max = N(e) ? e : 1, this.handleTickRangeOptions();\n    }\n  }, {\n    key: \"computeTickLimit\",\n    value: function computeTickLimit() {\n      var t = this.isHorizontal(),\n        e = t ? this.width : this.height,\n        s = nt(this.options.ticks.minRotation),\n        n = (t ? Math.sin(s) : Math.cos(s)) || 1e-3,\n        o = this._resolveTickFontOptions(0);\n      return Math.ceil(e / Math.min(40, o.lineHeight / n));\n    }\n  }, {\n    key: \"getPixelForValue\",\n    value: function getPixelForValue(t) {\n      return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);\n    }\n  }, {\n    key: \"getValueForPixel\",\n    value: function getValueForPixel(t) {\n      return this._startValue + this.getDecimalForPixel(t) * this._valueRange;\n    }\n  }]);\n  return Ge;\n}(Ye);\nGe.id = \"linear\";\nGe.defaults = {\n  ticks: {\n    callback: be.formatters.numeric\n  }\n};\nfunction tn(i) {\n  return i / Math.pow(10, Math.floor(tt(i))) === 1;\n}\nfunction Oc(i, t) {\n  var e = Math.floor(tt(t.max)),\n    s = Math.ceil(t.max / Math.pow(10, e)),\n    n = [];\n  var o = Q(i.min, Math.pow(10, Math.floor(tt(t.min)))),\n    r = Math.floor(tt(o)),\n    a = Math.floor(o / Math.pow(10, r)),\n    l = r < 0 ? Math.pow(10, Math.abs(r)) : 1;\n  do n.push({\n    value: o,\n    major: tn(o)\n  }), ++a, a === 10 && (a = 1, ++r, l = r >= 0 ? 1 : l), o = Math.round(a * Math.pow(10, r) * l) / l; while (r < e || r === e && a < s);\n  var c = Q(i.max, o);\n  return n.push({\n    value: c,\n    major: tn(o)\n  }), n;\n}\nvar Ze = /*#__PURE__*/function (_Mt3) {\n  _inherits(Ze, _Mt3);\n  var _super22 = _createSuper(Ze);\n  function Ze(t) {\n    var _this37;\n    _classCallCheck(this, Ze);\n    _this37 = _super22.call(this, t), _this37.start = void 0, _this37.end = void 0, _this37._startValue = void 0, _this37._valueRange = 0;\n    return _this37;\n  }\n  _createClass(Ze, [{\n    key: \"parse\",\n    value: function parse(t, e) {\n      var s = Ye.prototype.parse.apply(this, [t, e]);\n      if (s === 0) {\n        this._zero = !0;\n        return;\n      }\n      return N(s) && s > 0 ? s : null;\n    }\n  }, {\n    key: \"determineDataLimits\",\n    value: function determineDataLimits() {\n      var _this$getMinMax3 = this.getMinMax(!0),\n        t = _this$getMinMax3.min,\n        e = _this$getMinMax3.max;\n      this.min = N(t) ? Math.max(0, t) : null, this.max = N(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = !0), this.handleTickRangeOptions();\n    }\n  }, {\n    key: \"handleTickRangeOptions\",\n    value: function handleTickRangeOptions() {\n      var _this$getUserBounds4 = this.getUserBounds(),\n        t = _this$getUserBounds4.minDefined,\n        e = _this$getUserBounds4.maxDefined;\n      var s = this.min,\n        n = this.max;\n      var o = function o(l) {\n          return s = t ? s : l;\n        },\n        r = function r(l) {\n          return n = e ? n : l;\n        },\n        a = function a(l, c) {\n          return Math.pow(10, Math.floor(tt(l)) + c);\n        };\n      s === n && (s <= 0 ? (o(1), r(10)) : (o(a(s, -1)), r(a(n, 1)))), s <= 0 && o(a(n, -1)), n <= 0 && r(a(s, 1)), this._zero && this.min !== this._suggestedMin && s === a(this.min, 0) && o(a(s, -1)), this.min = s, this.max = n;\n    }\n  }, {\n    key: \"buildTicks\",\n    value: function buildTicks() {\n      var t = this.options,\n        e = {\n          min: this._userMin,\n          max: this._userMax\n        },\n        s = Oc(e, this);\n      return t.bounds === \"ticks\" && cn(s, this, \"value\"), t.reverse ? (s.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), s;\n    }\n  }, {\n    key: \"getLabelForValue\",\n    value: function getLabelForValue(t) {\n      return t === void 0 ? \"0\" : de(t, this.chart.options.locale, this.options.ticks.format);\n    }\n  }, {\n    key: \"configure\",\n    value: function configure() {\n      var t = this.min;\n      _get(_getPrototypeOf(Ze.prototype), \"configure\", this).call(this), this._startValue = tt(t), this._valueRange = tt(this.max) - tt(t);\n    }\n  }, {\n    key: \"getPixelForValue\",\n    value: function getPixelForValue(t) {\n      return (t === void 0 || t === 0) && (t = this.min), t === null || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (tt(t) - this._startValue) / this._valueRange);\n    }\n  }, {\n    key: \"getValueForPixel\",\n    value: function getValueForPixel(t) {\n      var e = this.getDecimalForPixel(t);\n      return Math.pow(10, this._startValue + e * this._valueRange);\n    }\n  }]);\n  return Ze;\n}(Mt);\nZe.id = \"logarithmic\";\nZe.defaults = {\n  ticks: {\n    callback: be.formatters.logarithmic,\n    major: {\n      enabled: !0\n    }\n  }\n};\nfunction Di(i) {\n  var t = i.ticks;\n  if (t.display && i.display) {\n    var e = K(t.backdropPadding);\n    return C(t.font && t.font.size, O.font.size) + e.height;\n  }\n  return 0;\n}\nfunction Ac(i, t, e) {\n  return e = z(e) ? e : [e], {\n    w: ar(i, t.string, e),\n    h: e.length * t.lineHeight\n  };\n}\nfunction en(i, t, e, s, n) {\n  return i === s || i === n ? {\n    start: t - e / 2,\n    end: t + e / 2\n  } : i < s || i > n ? {\n    start: t - e,\n    end: t\n  } : {\n    start: t,\n    end: t + e\n  };\n}\nfunction Tc(i) {\n  var t = {\n      l: i.left + i._padding.left,\n      r: i.right - i._padding.right,\n      t: i.top + i._padding.top,\n      b: i.bottom - i._padding.bottom\n    },\n    e = Object.assign({}, t),\n    s = [],\n    n = [],\n    o = i._pointLabels.length,\n    r = i.options.pointLabels,\n    a = r.centerPointLabels ? B / o : 0;\n  for (var l = 0; l < o; l++) {\n    var c = r.setContext(i.getPointLabelContext(l));\n    n[l] = c.padding;\n    var h = i.getPointPosition(l, i.drawingArea + n[l], a),\n      d = $(c.font),\n      u = Ac(i.ctx, d, i._pointLabels[l]);\n    s[l] = u;\n    var f = Z(i.getIndexAngle(l) + a),\n      g = Math.round(Ai(f)),\n      p = en(g, h.x, u.w, 0, 180),\n      m = en(g, h.y, u.h, 90, 270);\n    Lc(e, t, f, p, m);\n  }\n  i.setCenterPoint(t.l - e.l, e.r - t.r, t.t - e.t, e.b - t.b), i._pointLabelItems = Rc(i, s, n);\n}\nfunction Lc(i, t, e, s, n) {\n  var o = Math.abs(Math.sin(e)),\n    r = Math.abs(Math.cos(e));\n  var a = 0,\n    l = 0;\n  s.start < t.l ? (a = (t.l - s.start) / o, i.l = Math.min(i.l, t.l - a)) : s.end > t.r && (a = (s.end - t.r) / o, i.r = Math.max(i.r, t.r + a)), n.start < t.t ? (l = (t.t - n.start) / r, i.t = Math.min(i.t, t.t - l)) : n.end > t.b && (l = (n.end - t.b) / r, i.b = Math.max(i.b, t.b + l));\n}\nfunction Rc(i, t, e) {\n  var s = [],\n    n = i._pointLabels.length,\n    o = i.options,\n    r = Di(o) / 2,\n    a = i.drawingArea,\n    l = o.pointLabels.centerPointLabels ? B / n : 0;\n  for (var c = 0; c < n; c++) {\n    var h = i.getPointPosition(c, a + r + e[c], l),\n      d = Math.round(Ai(Z(h.angle + V))),\n      u = t[c],\n      f = Ic(h.y, u.h, d),\n      g = Ec(d),\n      p = Fc(h.x, u.w, g);\n    s.push({\n      x: h.x,\n      y: f,\n      textAlign: g,\n      left: p,\n      top: f,\n      right: p + u.w,\n      bottom: f + u.h\n    });\n  }\n  return s;\n}\nfunction Ec(i) {\n  return i === 0 || i === 180 ? \"center\" : i < 180 ? \"left\" : \"right\";\n}\nfunction Fc(i, t, e) {\n  return e === \"right\" ? i -= t : e === \"center\" && (i -= t / 2), i;\n}\nfunction Ic(i, t, e) {\n  return e === 90 || e === 270 ? i -= t / 2 : (e > 270 || e < 90) && (i -= t), i;\n}\nfunction zc(i, t) {\n  var e = i.ctx,\n    s = i.options.pointLabels;\n  for (var n = t - 1; n >= 0; n--) {\n    var o = s.setContext(i.getPointLabelContext(n)),\n      r = $(o.font),\n      _i$_pointLabelItems$n = i._pointLabelItems[n],\n      a = _i$_pointLabelItems$n.x,\n      l = _i$_pointLabelItems$n.y,\n      c = _i$_pointLabelItems$n.textAlign,\n      h = _i$_pointLabelItems$n.left,\n      d = _i$_pointLabelItems$n.top,\n      u = _i$_pointLabelItems$n.right,\n      f = _i$_pointLabelItems$n.bottom,\n      g = o.backdropColor;\n    if (!T(g)) {\n      var p = Dt(o.borderRadius),\n        m = K(o.backdropPadding);\n      e.fillStyle = g;\n      var b = h - m.left,\n        x = d - m.top,\n        v = u - h + m.width,\n        y = f - d + m.height;\n      Object.values(p).some(function (_) {\n        return _ !== 0;\n      }) ? (e.beginPath(), ae(e, {\n        x: b,\n        y: x,\n        w: v,\n        h: y,\n        radius: p\n      }), e.fill()) : e.fillRect(b, x, v, y);\n    }\n    Tt(e, i._pointLabels[n], a, l + r.lineHeight / 2, r, {\n      color: o.color,\n      textAlign: c,\n      textBaseline: \"middle\"\n    });\n  }\n}\nfunction bo(i, t, e, s) {\n  var n = i.ctx;\n  if (e) n.arc(i.xCenter, i.yCenter, t, 0, F);else {\n    var o = i.getPointPosition(0, t);\n    n.moveTo(o.x, o.y);\n    for (var r = 1; r < s; r++) o = i.getPointPosition(r, t), n.lineTo(o.x, o.y);\n  }\n}\nfunction Bc(i, t, e, s) {\n  var n = i.ctx,\n    o = t.circular,\n    r = t.color,\n    a = t.lineWidth;\n  !o && !s || !r || !a || e < 0 || (n.save(), n.strokeStyle = r, n.lineWidth = a, n.setLineDash(t.borderDash), n.lineDashOffset = t.borderDashOffset, n.beginPath(), bo(i, e, o, s), n.closePath(), n.stroke(), n.restore());\n}\nfunction Vc(i, t, e) {\n  return vt(i, {\n    label: e,\n    index: t,\n    type: \"pointLabel\"\n  });\n}\nvar Nt = /*#__PURE__*/function (_Ye2) {\n  _inherits(Nt, _Ye2);\n  var _super23 = _createSuper(Nt);\n  function Nt(t) {\n    var _this38;\n    _classCallCheck(this, Nt);\n    _this38 = _super23.call(this, t), _this38.xCenter = void 0, _this38.yCenter = void 0, _this38.drawingArea = void 0, _this38._pointLabels = [], _this38._pointLabelItems = [];\n    return _this38;\n  }\n  _createClass(Nt, [{\n    key: \"setDimensions\",\n    value: function setDimensions() {\n      var t = this._padding = K(Di(this.options) / 2),\n        e = this.width = this.maxWidth - t.width,\n        s = this.height = this.maxHeight - t.height;\n      this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + s / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, s) / 2);\n    }\n  }, {\n    key: \"determineDataLimits\",\n    value: function determineDataLimits() {\n      var _this$getMinMax4 = this.getMinMax(!1),\n        t = _this$getMinMax4.min,\n        e = _this$getMinMax4.max;\n      this.min = N(t) && !isNaN(t) ? t : 0, this.max = N(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions();\n    }\n  }, {\n    key: \"computeTickLimit\",\n    value: function computeTickLimit() {\n      return Math.ceil(this.drawingArea / Di(this.options));\n    }\n  }, {\n    key: \"generateTickLabels\",\n    value: function generateTickLabels(t) {\n      var _this39 = this;\n      Ye.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map(function (e, s) {\n        var n = I(_this39.options.pointLabels.callback, [e, s], _this39);\n        return n || n === 0 ? n : \"\";\n      }).filter(function (e, s) {\n        return _this39.chart.getDataVisibility(s);\n      });\n    }\n  }, {\n    key: \"fit\",\n    value: function fit() {\n      var t = this.options;\n      t.display && t.pointLabels.display ? Tc(this) : this.setCenterPoint(0, 0, 0, 0);\n    }\n  }, {\n    key: \"setCenterPoint\",\n    value: function setCenterPoint(t, e, s, n) {\n      this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((s - n) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, s, n));\n    }\n  }, {\n    key: \"getIndexAngle\",\n    value: function getIndexAngle(t) {\n      var e = F / (this._pointLabels.length || 1),\n        s = this.options.startAngle || 0;\n      return Z(t * e + nt(s));\n    }\n  }, {\n    key: \"getDistanceFromCenterForValue\",\n    value: function getDistanceFromCenterForValue(t) {\n      if (T(t)) return NaN;\n      var e = this.drawingArea / (this.max - this.min);\n      return this.options.reverse ? (this.max - t) * e : (t - this.min) * e;\n    }\n  }, {\n    key: \"getValueForDistanceFromCenter\",\n    value: function getValueForDistanceFromCenter(t) {\n      if (T(t)) return NaN;\n      var e = t / (this.drawingArea / (this.max - this.min));\n      return this.options.reverse ? this.max - e : this.min + e;\n    }\n  }, {\n    key: \"getPointLabelContext\",\n    value: function getPointLabelContext(t) {\n      var e = this._pointLabels || [];\n      if (t >= 0 && t < e.length) {\n        var s = e[t];\n        return Vc(this.getContext(), t, s);\n      }\n    }\n  }, {\n    key: \"getPointPosition\",\n    value: function getPointPosition(t, e) {\n      var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var n = this.getIndexAngle(t) - V + s;\n      return {\n        x: Math.cos(n) * e + this.xCenter,\n        y: Math.sin(n) * e + this.yCenter,\n        angle: n\n      };\n    }\n  }, {\n    key: \"getPointPositionForValue\",\n    value: function getPointPositionForValue(t, e) {\n      return this.getPointPosition(t, this.getDistanceFromCenterForValue(e));\n    }\n  }, {\n    key: \"getBasePosition\",\n    value: function getBasePosition(t) {\n      return this.getPointPositionForValue(t || 0, this.getBaseValue());\n    }\n  }, {\n    key: \"getPointLabelPosition\",\n    value: function getPointLabelPosition(t) {\n      var _this$_pointLabelItem = this._pointLabelItems[t],\n        e = _this$_pointLabelItem.left,\n        s = _this$_pointLabelItem.top,\n        n = _this$_pointLabelItem.right,\n        o = _this$_pointLabelItem.bottom;\n      return {\n        left: e,\n        top: s,\n        right: n,\n        bottom: o\n      };\n    }\n  }, {\n    key: \"drawBackground\",\n    value: function drawBackground() {\n      var _this$options15 = this.options,\n        t = _this$options15.backgroundColor,\n        e = _this$options15.grid.circular;\n      if (t) {\n        var s = this.ctx;\n        s.save(), s.beginPath(), bo(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), s.closePath(), s.fillStyle = t, s.fill(), s.restore();\n      }\n    }\n  }, {\n    key: \"drawGrid\",\n    value: function drawGrid() {\n      var _this40 = this;\n      var t = this.ctx,\n        e = this.options,\n        s = e.angleLines,\n        n = e.grid,\n        o = this._pointLabels.length;\n      var r, a, l;\n      if (e.pointLabels.display && zc(this, o), n.display && this.ticks.forEach(function (c, h) {\n        if (h !== 0) {\n          a = _this40.getDistanceFromCenterForValue(c.value);\n          var d = n.setContext(_this40.getContext(h - 1));\n          Bc(_this40, d, a, o);\n        }\n      }), s.display) {\n        for (t.save(), r = o - 1; r >= 0; r--) {\n          var c = s.setContext(this.getPointLabelContext(r)),\n            h = c.color,\n            d = c.lineWidth;\n          !d || !h || (t.lineWidth = d, t.strokeStyle = h, t.setLineDash(c.borderDash), t.lineDashOffset = c.borderDashOffset, a = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max), l = this.getPointPosition(r, a), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(l.x, l.y), t.stroke());\n        }\n        t.restore();\n      }\n    }\n  }, {\n    key: \"drawBorder\",\n    value: function drawBorder() {}\n  }, {\n    key: \"drawLabels\",\n    value: function drawLabels() {\n      var _this41 = this;\n      var t = this.ctx,\n        e = this.options,\n        s = e.ticks;\n      if (!s.display) return;\n      var n = this.getIndexAngle(0);\n      var o, r;\n      t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(n), t.textAlign = \"center\", t.textBaseline = \"middle\", this.ticks.forEach(function (a, l) {\n        if (l === 0 && !e.reverse) return;\n        var c = s.setContext(_this41.getContext(l)),\n          h = $(c.font);\n        if (o = _this41.getDistanceFromCenterForValue(_this41.ticks[l].value), c.showLabelBackdrop) {\n          t.font = h.string, r = t.measureText(a.label).width, t.fillStyle = c.backdropColor;\n          var d = K(c.backdropPadding);\n          t.fillRect(-r / 2 - d.left, -o - h.size / 2 - d.top, r + d.width, h.size + d.height);\n        }\n        Tt(t, a.label, 0, -o, h, {\n          color: c.color\n        });\n      }), t.restore();\n    }\n  }, {\n    key: \"drawTitle\",\n    value: function drawTitle() {}\n  }]);\n  return Nt;\n}(Ye);\nNt.id = \"radialLinear\";\nNt.defaults = {\n  display: !0,\n  animate: !0,\n  position: \"chartArea\",\n  angleLines: {\n    display: !0,\n    lineWidth: 1,\n    borderDash: [],\n    borderDashOffset: 0\n  },\n  grid: {\n    circular: !1\n  },\n  startAngle: 0,\n  ticks: {\n    showLabelBackdrop: !0,\n    callback: be.formatters.numeric\n  },\n  pointLabels: {\n    backdropColor: void 0,\n    backdropPadding: 2,\n    display: !0,\n    font: {\n      size: 10\n    },\n    callback: function callback(i) {\n      return i;\n    },\n    padding: 5,\n    centerPointLabels: !1\n  }\n};\nNt.defaultRoutes = {\n  \"angleLines.color\": \"borderColor\",\n  \"pointLabels.color\": \"color\",\n  \"ticks.color\": \"color\"\n};\nNt.descriptors = {\n  angleLines: {\n    _fallback: \"grid\"\n  }\n};\nvar Je = {\n    millisecond: {\n      common: !0,\n      size: 1,\n      steps: 1e3\n    },\n    second: {\n      common: !0,\n      size: 1e3,\n      steps: 60\n    },\n    minute: {\n      common: !0,\n      size: 6e4,\n      steps: 60\n    },\n    hour: {\n      common: !0,\n      size: 36e5,\n      steps: 24\n    },\n    day: {\n      common: !0,\n      size: 864e5,\n      steps: 30\n    },\n    week: {\n      common: !1,\n      size: 6048e5,\n      steps: 4\n    },\n    month: {\n      common: !0,\n      size: 2628e6,\n      steps: 12\n    },\n    quarter: {\n      common: !1,\n      size: 7884e6,\n      steps: 4\n    },\n    year: {\n      common: !0,\n      size: 3154e7\n    }\n  },\n  G = Object.keys(Je);\nfunction Wc(i, t) {\n  return i - t;\n}\nfunction sn(i, t) {\n  if (T(t)) return null;\n  var e = i._adapter,\n    _i$_parseOpts = i._parseOpts,\n    s = _i$_parseOpts.parser,\n    n = _i$_parseOpts.round,\n    o = _i$_parseOpts.isoWeekday;\n  var r = t;\n  return typeof s == \"function\" && (r = s(r)), N(r) || (r = typeof s == \"string\" ? e.parse(r, s) : e.parse(r)), r === null ? null : (n && (r = n === \"week\" && (Bt(o) || o === !0) ? e.startOf(r, \"isoWeek\", o) : e.startOf(r, n)), +r);\n}\nfunction nn(i, t, e, s) {\n  var n = G.length;\n  for (var o = G.indexOf(i); o < n - 1; ++o) {\n    var r = Je[G[o]],\n      a = r.steps ? r.steps : Number.MAX_SAFE_INTEGER;\n    if (r.common && Math.ceil((e - t) / (a * r.size)) <= s) return G[o];\n  }\n  return G[n - 1];\n}\nfunction Nc(i, t, e, s, n) {\n  for (var o = G.length - 1; o >= G.indexOf(e); o--) {\n    var r = G[o];\n    if (Je[r].common && i._adapter.diff(n, s, r) >= t - 1) return r;\n  }\n  return G[e ? G.indexOf(e) : 0];\n}\nfunction Hc(i) {\n  for (var t = G.indexOf(i) + 1, e = G.length; t < e; ++t) if (Je[G[t]].common) return G[t];\n}\nfunction on(i, t, e) {\n  if (!e) i[t] = !0;else if (e.length) {\n    var _Ti = Ti(e, t),\n      s = _Ti.lo,\n      n = _Ti.hi,\n      o = e[s] >= t ? e[s] : e[n];\n    i[o] = !0;\n  }\n}\nfunction jc(i, t, e, s) {\n  var n = i._adapter,\n    o = +n.startOf(t[0].value, s),\n    r = t[t.length - 1].value;\n  var a, l;\n  for (a = o; a <= r; a = +n.add(a, 1, s)) l = e[a], l >= 0 && (t[l].major = !0);\n  return t;\n}\nfunction rn(i, t, e) {\n  var s = [],\n    n = {},\n    o = t.length;\n  var r, a;\n  for (r = 0; r < o; ++r) a = t[r], n[a] = r, s.push({\n    value: a,\n    major: !1\n  });\n  return o === 0 || !e ? s : jc(i, s, n, e);\n}\nvar Ht = /*#__PURE__*/function (_Mt4) {\n  _inherits(Ht, _Mt4);\n  var _super24 = _createSuper(Ht);\n  function Ht(t) {\n    var _this42;\n    _classCallCheck(this, Ht);\n    _this42 = _super24.call(this, t), _this42._cache = {\n      data: [],\n      labels: [],\n      all: []\n    }, _this42._unit = \"day\", _this42._majorUnit = void 0, _this42._offsets = {}, _this42._normalized = !1, _this42._parseOpts = void 0;\n    return _this42;\n  }\n  _createClass(Ht, [{\n    key: \"init\",\n    value: function init(t, e) {\n      var s = t.time || (t.time = {}),\n        n = this._adapter = new Nn._date(t.adapters.date);\n      n.init(e), Qt(s.displayFormats, n.formats()), this._parseOpts = {\n        parser: s.parser,\n        round: s.round,\n        isoWeekday: s.isoWeekday\n      }, _get(_getPrototypeOf(Ht.prototype), \"init\", this).call(this, t), this._normalized = e.normalized;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(t, e) {\n      return t === void 0 ? null : sn(this, t);\n    }\n  }, {\n    key: \"beforeLayout\",\n    value: function beforeLayout() {\n      _get(_getPrototypeOf(Ht.prototype), \"beforeLayout\", this).call(this), this._cache = {\n        data: [],\n        labels: [],\n        all: []\n      };\n    }\n  }, {\n    key: \"determineDataLimits\",\n    value: function determineDataLimits() {\n      var t = this.options,\n        e = this._adapter,\n        s = t.time.unit || \"day\";\n      var _this$getUserBounds5 = this.getUserBounds(),\n        n = _this$getUserBounds5.min,\n        o = _this$getUserBounds5.max,\n        r = _this$getUserBounds5.minDefined,\n        a = _this$getUserBounds5.maxDefined;\n      function l(c) {\n        !r && !isNaN(c.min) && (n = Math.min(n, c.min)), !a && !isNaN(c.max) && (o = Math.max(o, c.max));\n      }\n      (!r || !a) && (l(this._getLabelBounds()), (t.bounds !== \"ticks\" || t.ticks.source !== \"labels\") && l(this.getMinMax(!1))), n = N(n) && !isNaN(n) ? n : +e.startOf(Date.now(), s), o = N(o) && !isNaN(o) ? o : +e.endOf(Date.now(), s) + 1, this.min = Math.min(n, o - 1), this.max = Math.max(n + 1, o);\n    }\n  }, {\n    key: \"_getLabelBounds\",\n    value: function _getLabelBounds() {\n      var t = this.getLabelTimestamps();\n      var e = Number.POSITIVE_INFINITY,\n        s = Number.NEGATIVE_INFINITY;\n      return t.length && (e = t[0], s = t[t.length - 1]), {\n        min: e,\n        max: s\n      };\n    }\n  }, {\n    key: \"buildTicks\",\n    value: function buildTicks() {\n      var t = this.options,\n        e = t.time,\n        s = t.ticks,\n        n = s.source === \"labels\" ? this.getLabelTimestamps() : this._generate();\n      t.bounds === \"ticks\" && n.length && (this.min = this._userMin || n[0], this.max = this._userMax || n[n.length - 1]);\n      var o = this.min,\n        r = this.max,\n        a = Ro(n, o, r);\n      return this._unit = e.unit || (s.autoSkip ? nn(e.minUnit, this.min, this.max, this._getLabelCapacity(o)) : Nc(this, a.length, e.minUnit, this.min, this.max)), this._majorUnit = !s.major.enabled || this._unit === \"year\" ? void 0 : Hc(this._unit), this.initOffsets(n), t.reverse && a.reverse(), rn(this, a, this._majorUnit);\n    }\n  }, {\n    key: \"afterAutoSkip\",\n    value: function afterAutoSkip() {\n      this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(function (t) {\n        return +t.value;\n      }));\n    }\n  }, {\n    key: \"initOffsets\",\n    value: function initOffsets(t) {\n      var e = 0,\n        s = 0,\n        n,\n        o;\n      this.options.offset && t.length && (n = this.getDecimalForValue(t[0]), t.length === 1 ? e = 1 - n : e = (this.getDecimalForValue(t[1]) - n) / 2, o = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? s = o : s = (o - this.getDecimalForValue(t[t.length - 2])) / 2);\n      var r = t.length < 3 ? 0.5 : 0.25;\n      e = Y(e, 0, r), s = Y(s, 0, r), this._offsets = {\n        start: e,\n        end: s,\n        factor: 1 / (e + 1 + s)\n      };\n    }\n  }, {\n    key: \"_generate\",\n    value: function _generate() {\n      var t = this._adapter,\n        e = this.min,\n        s = this.max,\n        n = this.options,\n        o = n.time,\n        r = o.unit || nn(o.minUnit, e, s, this._getLabelCapacity(e)),\n        a = C(o.stepSize, 1),\n        l = r === \"week\" ? o.isoWeekday : !1,\n        c = Bt(l) || l === !0,\n        h = {};\n      var d = e,\n        u,\n        f;\n      if (c && (d = +t.startOf(d, \"isoWeek\", l)), d = +t.startOf(d, c ? \"day\" : r), t.diff(s, e, r) > 1e5 * a) throw new Error(e + \" and \" + s + \" are too far apart with stepSize of \" + a + \" \" + r);\n      var g = n.ticks.source === \"data\" && this.getDataTimestamps();\n      for (u = d, f = 0; u < s; u = +t.add(u, a, r), f++) on(h, u, g);\n      return (u === s || n.bounds === \"ticks\" || f === 1) && on(h, u, g), Object.keys(h).sort(function (p, m) {\n        return p - m;\n      }).map(function (p) {\n        return +p;\n      });\n    }\n  }, {\n    key: \"getLabelForValue\",\n    value: function getLabelForValue(t) {\n      var e = this._adapter,\n        s = this.options.time;\n      return s.tooltipFormat ? e.format(t, s.tooltipFormat) : e.format(t, s.displayFormats.datetime);\n    }\n  }, {\n    key: \"_tickFormatFunction\",\n    value: function _tickFormatFunction(t, e, s, n) {\n      var o = this.options,\n        r = o.time.displayFormats,\n        a = this._unit,\n        l = this._majorUnit,\n        c = a && r[a],\n        h = l && r[l],\n        d = s[e],\n        u = l && h && d && d.major,\n        f = this._adapter.format(t, n || (u ? h : c)),\n        g = o.ticks.callback;\n      return g ? I(g, [f, e, s], this) : f;\n    }\n  }, {\n    key: \"generateTickLabels\",\n    value: function generateTickLabels(t) {\n      var e, s, n;\n      for (e = 0, s = t.length; e < s; ++e) n = t[e], n.label = this._tickFormatFunction(n.value, e, t);\n    }\n  }, {\n    key: \"getDecimalForValue\",\n    value: function getDecimalForValue(t) {\n      return t === null ? NaN : (t - this.min) / (this.max - this.min);\n    }\n  }, {\n    key: \"getPixelForValue\",\n    value: function getPixelForValue(t) {\n      var e = this._offsets,\n        s = this.getDecimalForValue(t);\n      return this.getPixelForDecimal((e.start + s) * e.factor);\n    }\n  }, {\n    key: \"getValueForPixel\",\n    value: function getValueForPixel(t) {\n      var e = this._offsets,\n        s = this.getDecimalForPixel(t) / e.factor - e.end;\n      return this.min + s * (this.max - this.min);\n    }\n  }, {\n    key: \"_getLabelSize\",\n    value: function _getLabelSize(t) {\n      var e = this.options.ticks,\n        s = this.ctx.measureText(t).width,\n        n = nt(this.isHorizontal() ? e.maxRotation : e.minRotation),\n        o = Math.cos(n),\n        r = Math.sin(n),\n        a = this._resolveTickFontOptions(0).size;\n      return {\n        w: s * o + a * r,\n        h: s * r + a * o\n      };\n    }\n  }, {\n    key: \"_getLabelCapacity\",\n    value: function _getLabelCapacity(t) {\n      var e = this.options.time,\n        s = e.displayFormats,\n        n = s[e.unit] || s.millisecond,\n        o = this._tickFormatFunction(t, 0, rn(this, [t], this._majorUnit), n),\n        r = this._getLabelSize(o),\n        a = Math.floor(this.isHorizontal() ? this.width / r.w : this.height / r.h) - 1;\n      return a > 0 ? a : 1;\n    }\n  }, {\n    key: \"getDataTimestamps\",\n    value: function getDataTimestamps() {\n      var t = this._cache.data || [],\n        e,\n        s;\n      if (t.length) return t;\n      var n = this.getMatchingVisibleMetas();\n      if (this._normalized && n.length) return this._cache.data = n[0].controller.getAllParsedValues(this);\n      for (e = 0, s = n.length; e < s; ++e) t = t.concat(n[e].controller.getAllParsedValues(this));\n      return this._cache.data = this.normalize(t);\n    }\n  }, {\n    key: \"getLabelTimestamps\",\n    value: function getLabelTimestamps() {\n      var t = this._cache.labels || [];\n      var e, s;\n      if (t.length) return t;\n      var n = this.getLabels();\n      for (e = 0, s = n.length; e < s; ++e) t.push(sn(this, n[e]));\n      return this._cache.labels = this._normalized ? t : this.normalize(t);\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize(t) {\n      return un(t.sort(Wc));\n    }\n  }]);\n  return Ht;\n}(Mt);\nHt.id = \"time\";\nHt.defaults = {\n  bounds: \"data\",\n  adapters: {},\n  time: {\n    parser: !1,\n    unit: !1,\n    round: !1,\n    isoWeekday: !1,\n    minUnit: \"millisecond\",\n    displayFormats: {}\n  },\n  ticks: {\n    source: \"auto\",\n    major: {\n      enabled: !1\n    }\n  }\n};\nfunction Fe(i, t, e) {\n  var _ft, _i$s, _i$n, _ft2, _i$s2, _i$n2;\n  var s = 0,\n    n = i.length - 1,\n    o,\n    r,\n    a,\n    l;\n  e ? (t >= i[s].pos && t <= i[n].pos && (_ft = ft(i, \"pos\", t), s = _ft.lo, n = _ft.hi, _ft), (_i$s = i[s], o = _i$s.pos, a = _i$s.time), (_i$n = i[n], r = _i$n.pos, l = _i$n.time)) : (t >= i[s].time && t <= i[n].time && (_ft2 = ft(i, \"time\", t), s = _ft2.lo, n = _ft2.hi, _ft2), (_i$s2 = i[s], o = _i$s2.time, a = _i$s2.pos), (_i$n2 = i[n], r = _i$n2.time, l = _i$n2.pos));\n  var c = r - o;\n  return c ? a + (l - a) * (t - o) / c : a;\n}\nvar Qe = /*#__PURE__*/function (_Ht) {\n  _inherits(Qe, _Ht);\n  var _super25 = _createSuper(Qe);\n  function Qe(t) {\n    var _this43;\n    _classCallCheck(this, Qe);\n    _this43 = _super25.call(this, t), _this43._table = [], _this43._minPos = void 0, _this43._tableRange = void 0;\n    return _this43;\n  }\n  _createClass(Qe, [{\n    key: \"initOffsets\",\n    value: function initOffsets() {\n      var t = this._getTimestampsForTable(),\n        e = this._table = this.buildLookupTable(t);\n      this._minPos = Fe(e, this.min), this._tableRange = Fe(e, this.max) - this._minPos, _get(_getPrototypeOf(Qe.prototype), \"initOffsets\", this).call(this, t);\n    }\n  }, {\n    key: \"buildLookupTable\",\n    value: function buildLookupTable(t) {\n      var e = this.min,\n        s = this.max,\n        n = [],\n        o = [];\n      var r, a, l, c, h;\n      for (r = 0, a = t.length; r < a; ++r) c = t[r], c >= e && c <= s && n.push(c);\n      if (n.length < 2) return [{\n        time: e,\n        pos: 0\n      }, {\n        time: s,\n        pos: 1\n      }];\n      for (r = 0, a = n.length; r < a; ++r) h = n[r + 1], l = n[r - 1], c = n[r], Math.round((h + l) / 2) !== c && o.push({\n        time: c,\n        pos: r / (a - 1)\n      });\n      return o;\n    }\n  }, {\n    key: \"_getTimestampsForTable\",\n    value: function _getTimestampsForTable() {\n      var t = this._cache.all || [];\n      if (t.length) return t;\n      var e = this.getDataTimestamps(),\n        s = this.getLabelTimestamps();\n      return e.length && s.length ? t = this.normalize(e.concat(s)) : t = e.length ? e : s, t = this._cache.all = t, t;\n    }\n  }, {\n    key: \"getDecimalForValue\",\n    value: function getDecimalForValue(t) {\n      return (Fe(this._table, t) - this._minPos) / this._tableRange;\n    }\n  }, {\n    key: \"getValueForPixel\",\n    value: function getValueForPixel(t) {\n      var e = this._offsets,\n        s = this.getDecimalForPixel(t) / e.factor - e.end;\n      return Fe(this._table, s * this._tableRange + this._minPos, !0);\n    }\n  }]);\n  return Qe;\n}(Ht);\nQe.id = \"timeseries\";\nQe.defaults = Ht.defaults;\nvar xo = /* @__PURE__ */Object.freeze({\n  __proto__: null,\n  CategoryScale: ce,\n  LinearScale: Ge,\n  LogarithmicScale: Ze,\n  RadialLinearScale: Nt,\n  TimeScale: Ht,\n  TimeSeriesScale: Qe\n});\nvar $c = [Wn, oo, mo, xo],\n  Yc = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n    __proto__: null,\n    Animation: In,\n    Animations: Ni,\n    ArcElement: ye,\n    BarController: ue,\n    BarElement: Me,\n    BasePlatform: Hi,\n    BasicPlatform: Yn,\n    BubbleController: fe,\n    CategoryScale: ce,\n    Chart: ji,\n    DatasetController: it,\n    Decimation: ao,\n    DomPlatform: Kn,\n    DoughnutController: Lt,\n    Element: st,\n    Filler: ho,\n    Interaction: Hn,\n    Legend: uo,\n    LineController: ge,\n    LineElement: gt,\n    LinearScale: Ge,\n    LogarithmicScale: Ze,\n    PieController: qe,\n    PointElement: ve,\n    PolarAreaController: pe,\n    RadarController: me,\n    RadialLinearScale: Nt,\n    Scale: Mt,\n    ScatterController: xe,\n    SubTitle: go,\n    Ticks: be,\n    TimeScale: Ht,\n    TimeSeriesScale: Qe,\n    Title: fo,\n    Tooltip: po,\n    _adapters: Nn,\n    _detectPlatform: qn,\n    animator: at,\n    controllers: Wn,\n    defaults: O,\n    elements: oo,\n    layouts: X,\n    plugins: mo,\n    registerables: $c,\n    registry: ot,\n    scales: xo\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  }));\nexport { ye as A, Me as B, ve as P, K as a, D as b, I as c, O as d, E as e, Yc as f, T as i, ne as m, Zt as r, $ as t, C as v };","map":{"version":3,"names":["ct","_o","i","T","z","Array","isArray","t","Object","prototype","toString","call","slice","D","N","Number","isFinite","Q","C","yo","endsWith","parseFloat","an","I","e","apply","E","s","n","o","r","length","keys","ze","datasetIndex","index","Be","map","create","ln","indexOf","vo","ne","merger","a","l","c","Qt","Mo","hasOwnProperty","Xi","_","x","y","_t","ko","wo","_iterator","_createForOfIteratorHelper","_step","done","value","err","f","split","_iterator2","_step2","push","Oi","charAt","toUpperCase","et","yt","Ui","size","_iterator3","_step3","has","So","type","B","Math","PI","F","Po","Ve","POSITIVE_INFINITY","Co","V","$t","Ki","tt","log10","lt","sign","qi","round","te","pow","floor","Do","sqrt","sort","pop","Bt","isNaN","abs","Oo","cn","min","max","nt","Ai","Gi","hn","atan2","angle","distance","bi","Ao","Z","oe","h","Y","To","ut","arguments","undefined","Ti","lo","hi","ft","Lo","Ro","dn","Eo","_chartjs","listeners","defineProperty","configurable","enumerable","forEach","_len","_key","Zi","splice","un","Set","add","from","fn","window","requestAnimationFrame","gn","_len2","_key2","Fo","_len3","_key3","clearTimeout","setTimeout","Li","U","Io","pn","_sorted","iScale","_parsed","axis","_r$getUserBounds","getUserBounds","d","minDefined","u","maxDefined","getPixelForValue","start","count","mn","xScale","yScale","_scaleRanges","xmin","xmax","ymin","ymax","assign","we","Ji","sin","Qi","ee","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","cos","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","he","mt","Gt","xt","dt","ts","J","A","b","xi","_toConsumableArray","zo","Bo","Se","Vo","g","Wo","No","Ho","jo","bn","$o","Yo","Xo","Ri","Ei","Fi","Uo","Ko","xn","qo","exec","Go","Zo","concat","es","X","W","S","R","P","O","M","L","K","G","H","is","OiceXe","antiquewEte","aqua","aquamarRe","azuY","beige","bisque","black","blanKedOmond","Xe","XeviTet","bPwn","burlywood","caMtXe","KartYuse","KocTate","cSO","cSnflowerXe","cSnsilk","crimson","cyan","xXe","xcyan","xgTMnPd","xWay","xgYF","xgYy","xkhaki","xmagFta","xTivegYF","xSange","xScEd","xYd","xsOmon","xsHgYF","xUXe","xUWay","xUgYy","xQe","xviTet","dAppRk","dApskyXe","dimWay","dimgYy","dodgerXe","fiYbrick","flSOwEte","foYstWAn","fuKsia","gaRsbSo","ghostwEte","gTd","gTMnPd","Way","gYF","gYFLw","gYy","honeyMw","hotpRk","RdianYd","Rdigo","ivSy","khaki","lavFMr","lavFMrXsh","lawngYF","NmoncEffon","ZXe","ZcSO","Zcyan","ZgTMnPdLw","ZWay","ZgYF","ZgYy","ZpRk","ZsOmon","ZsHgYF","ZskyXe","ZUWay","ZUgYy","ZstAlXe","ZLw","lime","limegYF","lRF","magFta","maPon","VaquamarRe","VXe","VScEd","VpurpN","VsHgYF","VUXe","VsprRggYF","VQe","VviTetYd","midnightXe","mRtcYam","mistyPse","moccasR","navajowEte","navy","Tdlace","Tive","TivedBb","Sange","SangeYd","ScEd","pOegTMnPd","pOegYF","pOeQe","pOeviTetYd","papayawEp","pHKpuff","peru","pRk","plum","powMrXe","purpN","YbeccapurpN","Yd","Psybrown","PyOXe","saddNbPwn","sOmon","sandybPwn","sHgYF","sHshell","siFna","silver","skyXe","UXe","UWay","UgYy","snow","sprRggYF","stAlXe","tan","teO","tEstN","tomato","Qe","viTet","JHt","wEte","wEtesmoke","Lw","LwgYF","Jo","replace","parseInt","Pe","Qo","transparent","toLowerCase","tr","er","ir","ni","Ft","sr","Ce","_n","ss","nr","We","_classCallCheck","_rgb","_valid","_createClass","key","get","set","rgbString","hexString","hslString","mix","rgb","interpolate","clone","alpha","clearer","greyscale","opaquer","negate","lighten","darken","saturate","desaturate","rotate","yn","vn","ns","oi","At","_i","ie","ri","or","animation","backgroundColor","borderColor","color","datasets","devicePixelRatio","chart","platform","getDevicePixelRatio","elements","events","font","family","style","lineHeight","weight","hover","hoverBackgroundColor","hoverBorderColor","hoverColor","indexAxis","interaction","mode","intersect","includeInvisible","maintainAspectRatio","onHover","onClick","parsing","plugins","responsive","scale","scales","showLine","drawActiveElementsOnTop","describe","override","route","_Object$definePropert","defineProperties","_defineProperty","writable","_scriptable","startsWith","_indexable","_fallback","rr","Ne","measureText","width","ar","data","garbageCollect","save","restore","wt","currentDevicePixelRatio","os","getContext","resetTransform","clearRect","height","yi","Mn","pointStyle","rotation","radius","translate","drawImage","beginPath","ellipse","arc","closePath","moveTo","lineTo","SQRT1_2","rect","fill","borderWidth","stroke","re","left","right","top","bottom","clip","Ue","lr","cr","bezierCurveTo","cp1x","cp2x","cp1y","cp2y","Tt","strokeWidth","strokeColor","string","hr","strokeStyle","lineWidth","strokeText","maxWidth","fillText","dr","translation","fillStyle","textAlign","textBaseline","strikethrough","underline","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","decorationWidth","ae","w","topLeft","bottomLeft","bottomRight","topRight","ur","RegExp","fr","gr","match","pr","Ii","_iterator4","_step4","kn","Dt","$","console","warn","Zt","cacheable","mr","vt","zi","_o2","Cn","Symbol","toStringTag","Proxy","deleteProperty","_keys","Sn","wr","getOwnPropertyDescriptor","Reflect","_scopes","getPrototypeOf","as","includes","ownKeys","_storage","Vt","_cacheable","_proxy","_context","_subProxy","_stack","_descriptors","wn","setContext","xr","allKeys","scriptable","indexable","_i$_scriptable","_i$_indexable","_i$_allKeys","_allKeys","isScriptable","isIndexable","br","Bi","constructor","_r","yr","Error","join","delete","Vi","filter","_iterator5","_step5","Pn","vr","Mr","_iterator6","_step6","_rootScopes","rs","kr","_getTarget","_iterator7","_step7","_iterator8","_step8","Sr","_iterator9","_step9","_iterator10","_step10","Dn","_this$_parsing$key","_parsing","parse","Pr","EPSILON","Wt","skip","On","Cr","previous","next","Dr","Or","Ar","De","Tr","Lr","spanGaps","cubicInterpolationMode","tension","capBezierPoints","An","document","Wi","parentNode","host","He","Ke","getComputedStyle","Rr","getPropertyValue","Er","Ot","Fr","shadowRoot","Ir","touches","offsetX","offsetY","target","getBoundingClientRect","clientX","clientY","box","Pt","canvas","boxSizing","_Ir","zr","clientWidth","clientHeight","maxHeight","ai","Br","ls","ctx","setTransform","Vr","passive","addEventListener","removeEventListener","_unused","cs","Ct","Wr","Nr","hs","Map","Hr","JSON","stringify","Intl","NumberFormat","de","format","jr","setWidth","xPlus","leftForLtr","$r","zt","Tn","getPropertyPriority","setProperty","prevTextDirection","Ln","Rn","between","compare","normalize","ds","_ref","end","loop","Yr","property","_Rn","En","_Rn2","_Yr","p","m","v","k","Fn","segments","points","Xr","Ur","stop","Kr","options","_loop","_Xr","us","_fullLoop","qr","_chart","fs","_datasetIndex","_iterator11","_step11","p0","p1","p0DataIndex","p1DataIndex","Gr","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","Zr","_request","_charts","_running","_lastDate","_notify","duration","initial","numSteps","currentStep","_refresh","_this","_update","_this2","Date","now","running","items","_active","_total","tick","draw","_getAnims","complete","progress","listen","_this$_getAnims$items","reduce","_duration","cancel","remove","at","gs","Jr","boolean","valid","number","In","to","_fn","_easing","easing","_start","delay","_target","_prop","_from","_to","_promises","active","update","wait","Promise","res","rej","Qr","ta","ea","colors","properties","numbers","resize","show","animations","visible","hide","Ni","_properties","configure","getOwnPropertyNames","_i2","_ea","_animateOptions","sa","_createAnimations","$shared","ia","$animations","then","all","ps","reverse","na","oa","disabled","zn","_getSortedDatasetMetas","ms","values","ra","bs","stacked","stack","aa","id","la","_i$getUserBounds","NEGATIVE_INFINITY","ca","xs","_iterator12","getMatchingVisibleMetas","_step12","_s","_cachedMeta","_stacks","vScale","_top","_bottom","li","shift","ha","dataset","da","dataIndex","parsed","raw","element","Yt","controller","_iterator13","_step13","ci","ys","ua","hidden","_stacked","it","_ctx","_cachedDataOpts","getMeta","_type","_data","_objectData","_sharedOptions","_drawStart","_drawCount","enableOptionSharing","supportsDecimation","$context","_syncList","initialize","linkScales","addElements","updateIndex","getDataset","xAxisID","yAxisID","rAxisID","iAxisID","vAxisID","getScaleForId","rScale","getDatasetMeta","_getOtherScale","reset","_destroy","_dataCheck","isExtensible","datasetElementType","buildOrUpdateElements","_resyncElements","config","datasetScopeKeys","getOptionScopes","createResolver","parseArrayData","parseObjectData","parsePrimitiveData","getLabels","_d$u","_this$_parsing","_this$_parsing$xAxisK","xAxisKey","_this$_parsing$yAxisK","yAxisKey","getParsed","getDataElement","applyStack","updateRangeFromParsed","NaN","getMinMax","_la","getAllParsedValues","getMaxOverflow","getLabelAndValue","label","getLabelForValue","_clip","chartArea","getStyle","resolveDatasetElementOptions","resolveDataElementOptions","_resolveElementOptions","dataElementType","_this3","datasetElementScopeKeys","resolveNamedOptions","freeze","_resolveAnimations","datasetAnimationScopeKeys","getSharedOptions","includeOptions","_animationsDisabled","_getSharedOptions","updateSharedOptions","sharedOptions","updateElement","_setStyle","removeHoverStyle","setHoverStyle","_removeDatasetHoverStyle","_setDatasetHoverStyle","_iterator14","_step14","_step14$value","_slicedToArray","_insertElements","_removeElements","updateElements","_sync","_t2","_dataChanges","_onDataPush","_onDataPop","_onDataShift","_onDataSplice","_onDataUnshift","defaults","fa","_cache","$bar","ga","_length","ticks","getPixelForTick","pa","barThickness","categoryPercentage","barPercentage","chunk","ratio","pixels","ma","ba","_custom","barStart","barEnd","Bn","vs","xa","isHorizontal","_a","horizontal","base","ya","borderSkipped","_a2","enableBorderRadius","Ms","va","ks","Ma","_ref2","inflateAmount","ue","_it","_inherits","_super","_createSuper","_this$_parsing2","_this$_parsing2$xAxis","_this$_parsing2$yAxis","_get","_getPrototypeOf","getBasePixel","_getRuler","_this$_getSharedOptio","head","_calculateBarValuePixels","_calculateBarIndexPixels","center","_getStacks","grouped","_iterator15","_step15","_getStackCount","_getStackIndex","_startPixel","_endPixel","stackCount","_this$_cachedMeta","_this$options","minBarLength","getDataVisibility","getPixelForDecimal","getLineWidthForValue","skipNull","maxBarThickness","overrides","_index_","offset","grid","_value_","beginAtZero","fe","_it2","_super2","_this$_cachedMeta2","_this$_getSharedOptio2","tooltip","callbacks","title","ka","ratioX","ratioY","Lt","_it3","_super3","_this4","innerRadius","outerRadius","_this$_parsing$key2","_getRotation","_getCircumference","circumference","_getRotationExtents","isDatasetVisible","getMaxBorderWidth","getMaxOffset","spacing","cutout","_getRingWeight","_this$_getRotationExt","_ka","_getVisibleDatasetWeightTotal","total","calculateTotal","_getRingWeightOffset","_circumference","animateRotate","calculateCircumference","animateScale","_this$_getSharedOptio3","startAngle","endAngle","labels","locale","borderAlign","hoverBorderWidth","hoverOffset","descriptors","aspectRatio","legend","generateLabels","text","toggleDataVisibility","formattedValue","ge","_it4","_super4","_e$data","_dataset","_pn","_decimated","segment","animated","_this$_cachedMeta3","_this$_getSharedOptio4","_this$options2","updateControlPoints","pe","_it5","_super5","_this5","bind","_updateRadius","_this6","cutoutPercentage","getVisibleDatasetCount","xCenter","yCenter","getIndexAngle","countVisibleElements","_computeAngle","getDistanceFromCenterForValue","_this7","angleLines","display","circular","pointLabels","qe","_Lt","_super6","me","_it6","_super7","getPointPositionForValue","line","st","tooltipPosition","_this$getProps","getProps","hasValue","_this8","defaultRoutes","Vn","numeric","wa","notation","minimumFractionDigits","maximumFractionDigits","logarithmic","be","formatters","bounds","grace","drawBorder","drawOnChartArea","drawTicks","tickLength","tickWidth","tickColor","padding","minRotation","maxRotation","mirror","textStrokeWidth","textStrokeColor","autoSkip","autoSkipPadding","labelOffset","callback","minor","major","align","crossAlign","showLabelBackdrop","backdropColor","backdropPadding","Sa","maxTicksLimit","Pa","enabled","Da","Oa","Ca","Oe","_tickSize","_maxLength","Aa","ceil","Ta","ws","Ss","La","Ra","gc","Xt","Ps","Ea","Fa","Ia","za","titleX","titleY","Mt","_st","_super8","_this9","_margins","paddingTop","paddingBottom","paddingLeft","paddingRight","labelRotation","_range","_gridLineItems","_labelItems","_labelSizes","_longestTextCache","_reversePixels","_userMax","_userMin","_suggestedMax","_suggestedMin","_ticksLength","_borderValue","_dataLimitsCached","init","suggestedMin","suggestedMax","_this$getUserBounds","getPadding","getTicks","xLabels","yLabels","beforeLayout","beforeUpdate","_this$options3","sampleSize","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","beforeBuildTicks","buildTicks","afterBuildTicks","_convertTicksToLabels","beforeCalculateLabelRotation","calculateLabelRotation","afterCalculateLabelRotation","source","afterAutoSkip","beforeFit","fit","afterFit","afterUpdate","_alignToPixels","alignToPixels","_callHooks","notifyPlugins","beforeTickToLabelConversion","generateTickLabels","afterTickToLabelConversion","_isVisible","_getLabelSizes","widest","highest","asin","_this$options4","_this$_getLabelSizes","first","last","_calculatePadding","_handleMargins","_this$options5","_this$options5$ticks","position","_this$options6","isFullSize","fullSize","_computeLabelSizes","_resolveTickFontOptions","widths","heights","getValueForPixel","getDecimalForPixel","getBaseValue","_computeGridLineItems","j","q","kt","ti","Rt","ke","Et","tickBorderDash","jt","tickBorderDashOffset","tx1","ty1","tx2","ty2","x1","y1","x2","y2","_computeLabelItems","_getXAxisLabelAlignment","_getYAxisLabelAlignment","ei","ii","si","textOffset","backdrop","_this$options7","_this$options8","_this$options8$ticks","_computeLabelArea","drawBackground","fillRect","findIndex","drawGrid","setLineDash","lineDashOffset","drawLabels","drawTitle","_this$options9","_za","_layers","_this10","getSortedVisibleDatasetMetas","_maxDigits","Ae","scope","isForType","isPrototypeOf","register","Wa","Ba","unregister","Va","Na","controllers","_typedRegistries","_len4","_key4","_each","_len5","_key5","addControllers","_len6","_key6","_len7","_key7","addPlugins","_len8","_key8","addScales","_len9","_key9","getController","getElement","getPlugin","getScale","removeControllers","_len10","_key10","removeElements","_len11","_key11","removePlugins","_len12","_key12","removeScales","_len13","_key13","_this11","_getRegistryForType","_exec","ot","xe","_it7","_super9","_e$data2","_pn2","_this$_cachedMeta4","_this$options10","Wn","__proto__","BarController","BubbleController","DoughnutController","LineController","PolarAreaController","PieController","RadarController","ScatterController","St","vi","formats","diff","startOf","endOf","Nn","_date","Ha","getRange","_e","_o$a","_Ha","ja","di","isPointInArea","inRange","$a","_r$getProps","_hn","Ya","getCenterPoint","ui","Cs","Hn","evaluateInteractionItems","modes","point","nearest","jn","Ut","pos","Ds","Kt","Xa","_n2","_n2$options","_n2$options$stackWeig","stackWeight","Ua","_iterator16","_step16","placed","Ka","vBoxMaxWidth","hBoxMaxHeight","availableWidth","availableHeight","qa","leftAndTop","rightAndBottom","vertical","Os","$n","Ga","maxPadding","outerWidth","outerHeight","same","other","Za","Ja","Jt","_Ga","Te","As","_iterator17","_step17","autoPadding","addBox","boxes","removeBox","layout","Hi","acquireContext","releaseContext","getMaximumSize","isAttached","updateConfig","Yn","_Hi","_super10","Ie","Qa","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","Ts","tl","getAttribute","Xn","el","il","sl","_Pt","native","je","_iterator18","_step18","contains","nl","MutationObserver","_iterator19","_step19","addedNodes","removedNodes","observe","childList","subtree","ol","_iterator20","_step20","le","Ls","Un","rl","al","ll","ResizeObserver","contentRect","fi","disconnect","cl","Kn","_Hi2","_super11","removeAttribute","setAttribute","$proxies","attach","detach","isConnected","qn","OffscreenCanvas","hl","_init","notify","_createDescriptors","_iterator21","_step21","plugin","cancelable","invalidate","_oldCache","_notifyStateChanges","dl","fl","some","localIds","ul","_ref3","_iterator22","_step22","gl","local","_ref4","pluginScopeKeys","Mi","pl","ml","bl","ki","xl","error","Gn","Zn","_l","Rs","Jn","Le","qt","yl","_config","_scopeCache","_resolverCache","clearCache","clear","additionalOptionScopes","_cachedScopes","chartOptionScopes","_Es","Es","resolver","subPrefixes","Ml","_iterator23","_step23","_Es2","vl","_wn","_iterator24","_step24","kl","wl","Fs","Is","zs","onComplete","Sl","onProgress","Qn","getElementById","$e","Pl","_i3","_s2","Cl","ji","_this12","_options","_aspectRatio","_metasets","_lastEvent","_listeners","_responsiveListeners","_sortedMetasets","_plugins","_hiddenIndices","attached","_doResize","resizeDelay","_initialize","_this$options11","bindEvents","_resizeBeforeDraw","_resize","onResize","render","ensureScalesHaveIDs","buildOrUpdateScales","_this13","dposition","dtype","_updateMetasets","_destroyDatasetMeta","_removeUnreferencedMetasets","_this14","buildOrUpdateControllers","order","_O$datasets$a","_resetElements","_this15","_updateScales","_checkEventBindings","_updateHiddenIndices","_this$getDatasetMeta","_minPadding","_updateLayout","_updateDatasets","_eventHandler","_updateHoverStyles","_this16","unbindEvents","_getUniformDataChanges","_iterator25","_step25","_step25$value","method","_this17","_this17$_layers","_idx","_updateDataset","meta","_this$_resizeBeforeDr","_drawDatasets","_drawDataset","getElementsAtEventForMode","setDatasetVisibility","_updateVisibility","_stop","destroy","toBase64Image","_this$canvas","toDataURL","bindUserEvents","bindResponsiveEvents","_this18","_this19","_this20","updateHoverStyle","getActiveElements","setActiveElements","_this21","_ref5","_this22","event","replay","inChartArea","_handleEvent","changed","_this$_active","_getActiveElements","Bs","instances","pt","registry","version","getChart","eo","pixelMargin","Dl","Ol","borderRadius","outerStart","outerEnd","innerStart","innerEnd","It","wi","_Ol","Al","fullCircles","Tl","Ll","lineJoin","ye","_st2","_super12","_this23","_assertThisInitialized","_hn2","_this$getProps2","_this$getProps3","_this$options12","io","lineCap","Rl","El","stepped","so","_e$start","_e$end","ilen","Fl","_so","_ref6","_ref6$move","move","Il","_so2","_ref7","_ref7$move","Si","zl","Bl","_path","Path2D","path","Vl","_iterator26","_step26","Wl","Nl","gt","_st3","_super13","_this24","_points","_segments","_pointsUpdated","_r$c","pathSegment","_iterator27","_step27","Vs","_i$getProps","hitRadius","ve","_st4","_super14","_this25","_this$getProps4","inXRange","inYRange","_this$getProps5","hoverRadius","no","_i$getProps2","bt","Hl","jl","_i$getProps3","$l","outer","inner","gi","Yl","Xl","pi","Me","_st5","_super15","_this26","_this$options13","_$l","_this$getProps6","oo","ArcElement","LineElement","PointElement","BarElement","Ul","samples","_i$h","Kl","_objectSpread","ro","Ws","ql","_o$getUserBounds","ao","algorithm","beforeElementsUpdate","_ql","threshold","Gl","_iterator28","_step28","$i","Pi","_iterator29","_step29","_iterator30","_step30","Ns","Zl","_ref8","_ref8$x","_ref8$y","_ref9","Hs","Jl","Ql","sc","tc","ec","ic","nc","oc","rc","unshift","_ac","ac","co","lc","cc","hc","uc","dc","_i$scale","mi","_ref10","_ref10$above","above","_ref10$below","below","fc","area","js","$s","_iterator31","_step31","_iterator32","_step32","_step32$value","_l$style","_l$style2","_l$style2$backgroundC","Ys","_t$chart$chartArea","_ref11","ho","afterDatasetsUpdate","$filler","propagate","beforeDraw","drawTime","beforeDatasetsDraw","beforeDatasetDraw","Xs","_i$boxHeight","boxHeight","_i$boxWidth","boxWidth","usePointStyle","pointStyleWidth","itemHeight","pc","Us","_st6","_super16","_this27","_added","legendHitBoxes","_hoveredItem","doughnutMode","legendItems","columnSizes","lineWidths","buildLabels","_this28","_computeTitleHeight","_Xs","_fitRows","_fitCols","row","col","adjustHitBoxes","_this$options14","rtl","_iterator33","_step33","_iterator34","_step34","_draw","_this29","_Xs2","lineDash","SQRT2","textDirection","fontColor","_getLegendItemAt","handleEvent","mc","onLeave","uo","_element","afterEvent","_i$legend$options$lab","Yi","_st7","_super17","_this30","_padding","_drawArgs","_this$_drawArgs","bc","titleBlock","fo","Re","WeakMap","go","se","average","rt","ht","String","xc","_o$getLabelAndValue","Ks","body","footer","bodyFont","titleFont","footerFont","before","lines","after","beforeBody","afterBody","titleSpacing","titleMarginBottom","displayColors","bodySpacing","footerMarginTop","footerSpacing","boxPadding","_c","yc","caretSize","caretPadding","vc","_i$chartArea","qs","yAlign","xAlign","Mc","kc","Gs","cornerRadius","_Dt","Ee","Zs","wc","tooltipItems","Js","Ci","_st8","_super18","_this31","opacity","_eventPosition","_size","_cachedAnimations","_tooltipItems","dataPoints","caretX","caretY","labelColors","labelPointStyles","labelTextColors","getTitle","beforeTitle","afterTitle","getBeforeBody","getBody","_this32","beforeLabel","afterLabel","getAfterBody","getFooter","beforeFooter","afterFooter","_createItems","_this33","itemSort","labelColor","labelPointStyle","labelTextColor","external","drawCaret","getCaretPosition","x3","y3","_Dt2","titleAlign","titleColor","_drawColorBox","multiKeyBackground","strokeRect","drawBody","bodyAlign","bodyColor","drawFooter","footerAlign","footerColor","_Dt3","quadraticCurveTo","_updateAnimationTarget","_willRender","globalAlpha","_this34","_ref12","_positionChanged","_ignoreReplayEvents","positioners","po","afterInit","afterDraw","mo","Decimation","Filler","Legend","SubTitle","Title","Tooltip","Sc","Pc","lastIndexOf","Cc","ce","_Mt","_super19","_this35","_startValue","_valueRange","_addedLabels","_iterator35","_step35","_step35$value","_this$getUserBounds2","_this$getMinMax","Dc","step","precision","maxTicks","maxDigits","includeBounds","Qs","_ref13","Ye","_Mt2","_super20","_this36","_endValue","handleTickRangeOptions","_this$getUserBounds3","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","getTickLimit","stepSize","computeTickLimit","Ge","_Ye","_super21","_this$getMinMax2","tn","Oc","Ze","_Mt3","_super22","_this37","_zero","_this$getMinMax3","_this$getUserBounds4","Di","Ac","en","Tc","_pointLabels","centerPointLabels","getPointLabelContext","getPointPosition","drawingArea","Lc","setCenterPoint","_pointLabelItems","Rc","Ic","Ec","Fc","zc","_i$_pointLabelItems$n","bo","Bc","Vc","Nt","_Ye2","_super23","_this38","_this$getMinMax4","_this39","getValueForDistanceFromCenter","getBasePosition","getPointLabelPosition","_this$_pointLabelItem","_this$options15","_this40","_this41","animate","Je","millisecond","common","steps","second","minute","hour","day","week","month","quarter","year","Wc","sn","_adapter","_i$_parseOpts","_parseOpts","parser","isoWeekday","nn","Nc","Hc","on","_Ti","jc","rn","Ht","_Mt4","_super24","_this42","_unit","_majorUnit","_offsets","_normalized","time","adapters","date","displayFormats","normalized","unit","_this$getUserBounds5","_getLabelBounds","getLabelTimestamps","_generate","minUnit","_getLabelCapacity","initOffsets","offsetAfterAutoskip","getDecimalForValue","factor","getDataTimestamps","tooltipFormat","datetime","_tickFormatFunction","_getLabelSize","Fe","_ft","_i$s","_i$n","_ft2","_i$s2","_i$n2","_Ht","_super25","_this43","_table","_minPos","_tableRange","_getTimestampsForTable","buildLookupTable","xo","CategoryScale","LinearScale","LogarithmicScale","RadialLinearScale","TimeScale","TimeSeriesScale","$c","Yc"],"sources":["C:\\Users\\Matt\\node_modules\\tw-elements\\node_modules\\chart.js\\dist\\chunks\\helpers.segment.mjs","C:\\Users\\Matt\\node_modules\\tw-elements\\node_modules\\chart.js\\dist\\chart.mjs"],"sourcesContent":["/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */\nfunction noop() {}\nconst uid = (function() {\n  let id = 0;\n  return function() {\n    return id++;\n  };\n}());\nfunction isNullOrUndef(value) {\n  return value === null || typeof value === 'undefined';\n}\nfunction isArray(value) {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n  const type = Object.prototype.toString.call(value);\n  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n    return true;\n  }\n  return false;\n}\nfunction isObject(value) {\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\nconst isNumberFinite = (value) => (typeof value === 'number' || value instanceof Number) && isFinite(+value);\nfunction finiteOrDefault(value, defaultValue) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\nfunction valueOrDefault(value, defaultValue) {\n  return typeof value === 'undefined' ? defaultValue : value;\n}\nconst toPercentage = (value, dimension) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100\n    : value / dimension;\nconst toDimension = (value, dimension) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100 * dimension\n    : +value;\nfunction callback(fn, args, thisArg) {\n  if (fn && typeof fn.call === 'function') {\n    return fn.apply(thisArg, args);\n  }\n}\nfunction each(loopable, fn, thisArg, reverse) {\n  let i, len, keys;\n  if (isArray(loopable)) {\n    len = loopable.length;\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\nfunction _elementsEqual(a0, a1) {\n  let i, ilen, v0, v1;\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction clone$1(source) {\n  if (isArray(source)) {\n    return source.map(clone$1);\n  }\n  if (isObject(source)) {\n    const target = Object.create(null);\n    const keys = Object.keys(source);\n    const klen = keys.length;\n    let k = 0;\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone$1(source[keys[k]]);\n    }\n    return target;\n  }\n  return source;\n}\nfunction isValidKey(key) {\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n}\nfunction _merger(key, target, source, options) {\n  if (!isValidKey(key)) {\n    return;\n  }\n  const tval = target[key];\n  const sval = source[key];\n  if (isObject(tval) && isObject(sval)) {\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone$1(sval);\n  }\n}\nfunction merge(target, source, options) {\n  const sources = isArray(source) ? source : [source];\n  const ilen = sources.length;\n  if (!isObject(target)) {\n    return target;\n  }\n  options = options || {};\n  const merger = options.merger || _merger;\n  for (let i = 0; i < ilen; ++i) {\n    source = sources[i];\n    if (!isObject(source)) {\n      continue;\n    }\n    const keys = Object.keys(source);\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, source, options);\n    }\n  }\n  return target;\n}\nfunction mergeIf(target, source) {\n  return merge(target, source, {merger: _mergerIf});\n}\nfunction _mergerIf(key, target, source) {\n  if (!isValidKey(key)) {\n    return;\n  }\n  const tval = target[key];\n  const sval = source[key];\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone$1(sval);\n  }\n}\nfunction _deprecated(scope, value, previous, current) {\n  if (value !== undefined) {\n    console.warn(scope + ': \"' + previous +\n\t\t\t'\" is deprecated. Please use \"' + current + '\" instead');\n  }\n}\nconst keyResolvers = {\n  '': v => v,\n  x: o => o.x,\n  y: o => o.y\n};\nfunction resolveObjectKey(obj, key) {\n  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n  return resolver(obj);\n}\nfunction _getKeyResolver(key) {\n  const keys = _splitKey(key);\n  return obj => {\n    for (const k of keys) {\n      if (k === '') {\n        break;\n      }\n      obj = obj && obj[k];\n    }\n    return obj;\n  };\n}\nfunction _splitKey(key) {\n  const parts = key.split('.');\n  const keys = [];\n  let tmp = '';\n  for (const part of parts) {\n    tmp += part;\n    if (tmp.endsWith('\\\\')) {\n      tmp = tmp.slice(0, -1) + '.';\n    } else {\n      keys.push(tmp);\n      tmp = '';\n    }\n  }\n  return keys;\n}\nfunction _capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\nconst defined = (value) => typeof value !== 'undefined';\nconst isFunction = (value) => typeof value === 'function';\nconst setsEqual = (a, b) => {\n  if (a.size !== b.size) {\n    return false;\n  }\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n  return true;\n};\nfunction _isClickEvent(e) {\n  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n\nconst PI = Math.PI;\nconst TAU = 2 * PI;\nconst PITAU = TAU + PI;\nconst INFINITY = Number.POSITIVE_INFINITY;\nconst RAD_PER_DEG = PI / 180;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nconst log10 = Math.log10;\nconst sign = Math.sign;\nfunction niceNum(range) {\n  const roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\n  const fraction = range / niceRange;\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\nfunction _factorize(value) {\n  const result = [];\n  const sqrt = Math.sqrt(value);\n  let i;\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n  if (sqrt === (sqrt | 0)) {\n    result.push(sqrt);\n  }\n  result.sort((a, b) => a - b).pop();\n  return result;\n}\nfunction isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostEquals(x, y, epsilon) {\n  return Math.abs(x - y) < epsilon;\n}\nfunction almostWhole(x, epsilon) {\n  const rounded = Math.round(x);\n  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\n}\nfunction _setMinAndMaxByKey(array, target, property) {\n  let i, ilen, value;\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\nfunction toRadians(degrees) {\n  return degrees * (PI / 180);\n}\nfunction toDegrees(radians) {\n  return radians * (180 / PI);\n}\nfunction _decimalPlaces(x) {\n  if (!isNumberFinite(x)) {\n    return;\n  }\n  let e = 1;\n  let p = 0;\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n  return p;\n}\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n  if (angle < (-0.5 * PI)) {\n    angle += TAU;\n  }\n  return {\n    angle,\n    distance: radialDistanceFromCenter\n  };\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\nfunction _angleDiff(a, b) {\n  return (a - b + PITAU) % TAU - PI;\n}\nfunction _normalizeAngle(a) {\n  return (a % TAU + TAU) % TAU;\n}\nfunction _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n  const a = _normalizeAngle(angle);\n  const s = _normalizeAngle(start);\n  const e = _normalizeAngle(end);\n  const angleToStart = _normalizeAngle(s - a);\n  const angleToEnd = _normalizeAngle(e - a);\n  const startToAngle = _normalizeAngle(a - s);\n  const endToAngle = _normalizeAngle(a - e);\n  return a === s || a === e || (sameAngleIsFullCircle && s === e)\n    || (angleToStart > angleToEnd && startToAngle < endToAngle);\n}\nfunction _limitValue(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\nfunction _int16Range(value) {\n  return _limitValue(value, -32768, 32767);\n}\nfunction _isBetween(value, start, end, epsilon = 1e-6) {\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n\nfunction _lookup(table, value, cmp) {\n  cmp = cmp || ((index) => table[index] < value);\n  let hi = table.length - 1;\n  let lo = 0;\n  let mid;\n  while (hi - lo > 1) {\n    mid = (lo + hi) >> 1;\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n  return {lo, hi};\n}\nconst _lookupByKey = (table, key, value, last) =>\n  _lookup(table, value, last\n    ? index => table[index][key] <= value\n    : index => table[index][key] < value);\nconst _rlookupByKey = (table, key, value) =>\n  _lookup(table, value, index => table[index][key] >= value);\nfunction _filterBetween(values, min, max) {\n  let start = 0;\n  let end = values.length;\n  while (start < end && values[start] < min) {\n    start++;\n  }\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n  return start > 0 || end < values.length\n    ? values.slice(start, end)\n    : values;\n}\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\nfunction listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n    return;\n  }\n  Object.defineProperty(array, '_chartjs', {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n  arrayEvents.forEach((key) => {\n    const method = '_onData' + _capitalize(key);\n    const base = array[key];\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n      value(...args) {\n        const res = base.apply(this, args);\n        array._chartjs.listeners.forEach((object) => {\n          if (typeof object[method] === 'function') {\n            object[method](...args);\n          }\n        });\n        return res;\n      }\n    });\n  });\n}\nfunction unlistenArrayEvents(array, listener) {\n  const stub = array._chartjs;\n  if (!stub) {\n    return;\n  }\n  const listeners = stub.listeners;\n  const index = listeners.indexOf(listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n  if (listeners.length > 0) {\n    return;\n  }\n  arrayEvents.forEach((key) => {\n    delete array[key];\n  });\n  delete array._chartjs;\n}\nfunction _arrayUnique(items) {\n  const set = new Set();\n  let i, ilen;\n  for (i = 0, ilen = items.length; i < ilen; ++i) {\n    set.add(items[i]);\n  }\n  if (set.size === ilen) {\n    return items;\n  }\n  return Array.from(set);\n}\n\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\nconst requestAnimFrame = (function() {\n  if (typeof window === 'undefined') {\n    return function(callback) {\n      return callback();\n    };\n  }\n  return window.requestAnimationFrame;\n}());\nfunction throttled(fn, thisArg, updateFn) {\n  const updateArgs = updateFn || ((args) => Array.prototype.slice.call(args));\n  let ticking = false;\n  let args = [];\n  return function(...rest) {\n    args = updateArgs(rest);\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, () => {\n        ticking = false;\n        fn.apply(thisArg, args);\n      });\n    }\n  };\n}\nfunction debounce(fn, delay) {\n  let timeout;\n  return function(...args) {\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay, args);\n    } else {\n      fn.apply(this, args);\n    }\n    return delay;\n  };\n}\nconst _toLeftRightCenter = (align) => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\nconst _alignStartEnd = (align, start, end) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\nconst _textX = (align, left, right, rtl) => {\n  const check = rtl ? 'left' : 'right';\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\nfunction _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n  const pointCount = points.length;\n  let start = 0;\n  let count = pointCount;\n  if (meta._sorted) {\n    const {iScale, _parsed} = meta;\n    const axis = iScale.axis;\n    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n    if (minDefined) {\n      start = _limitValue(Math.min(\n        _lookupByKey(_parsed, iScale.axis, min).lo,\n        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo),\n      0, pointCount - 1);\n    }\n    if (maxDefined) {\n      count = _limitValue(Math.max(\n        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,\n        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1),\n      start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n  return {start, count};\n}\nfunction _scaleRangesChanged(meta) {\n  const {xScale, yScale, _scaleRanges} = meta;\n  const newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n  const changed = _scaleRanges.xmin !== xScale.min\n\t\t|| _scaleRanges.xmax !== xScale.max\n\t\t|| _scaleRanges.ymin !== yScale.min\n\t\t|| _scaleRanges.ymax !== yScale.max;\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\n\nconst atEdge = (t) => t === 0 || t === 1;\nconst elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\nconst effects = {\n  linear: t => t,\n  easeInQuad: t => t * t,\n  easeOutQuad: t => -t * (t - 2),\n  easeInOutQuad: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t\n    : -0.5 * ((--t) * (t - 2) - 1),\n  easeInCubic: t => t * t * t,\n  easeOutCubic: t => (t -= 1) * t * t + 1,\n  easeInOutCubic: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t\n    : 0.5 * ((t -= 2) * t * t + 2),\n  easeInQuart: t => t * t * t * t,\n  easeOutQuart: t => -((t -= 1) * t * t * t - 1),\n  easeInOutQuart: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t\n    : -0.5 * ((t -= 2) * t * t * t - 2),\n  easeInQuint: t => t * t * t * t * t,\n  easeOutQuint: t => (t -= 1) * t * t * t * t + 1,\n  easeInOutQuint: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t * t\n    : 0.5 * ((t -= 2) * t * t * t * t + 2),\n  easeInSine: t => -Math.cos(t * HALF_PI) + 1,\n  easeOutSine: t => Math.sin(t * HALF_PI),\n  easeInOutSine: t => -0.5 * (Math.cos(PI * t) - 1),\n  easeInExpo: t => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\n  easeOutExpo: t => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\n  easeInOutExpo: t => atEdge(t) ? t : t < 0.5\n    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\n    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n  easeInCirc: t => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\n  easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),\n  easeInOutCirc: t => ((t /= 0.5) < 1)\n    ? -0.5 * (Math.sqrt(1 - t * t) - 1)\n    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n  easeInElastic: t => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n  easeOutElastic: t => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n  easeInOutElastic(t) {\n    const s = 0.1125;\n    const p = 0.45;\n    return atEdge(t) ? t :\n      t < 0.5\n        ? 0.5 * elasticIn(t * 2, s, p)\n        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n  easeInBack(t) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n  easeOutBack(t) {\n    const s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n  easeInOutBack(t) {\n    let s = 1.70158;\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n    }\n    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n  },\n  easeInBounce: t => 1 - effects.easeOutBounce(1 - t),\n  easeOutBounce(t) {\n    const m = 7.5625;\n    const d = 2.75;\n    if (t < (1 / d)) {\n      return m * t * t;\n    }\n    if (t < (2 / d)) {\n      return m * (t -= (1.5 / d)) * t + 0.75;\n    }\n    if (t < (2.5 / d)) {\n      return m * (t -= (2.25 / d)) * t + 0.9375;\n    }\n    return m * (t -= (2.625 / d)) * t + 0.984375;\n  },\n  easeInOutBounce: t => (t < 0.5)\n    ? effects.easeInBounce(t * 2) * 0.5\n    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\n};\n\n/*!\n * @kurkle/color v0.2.1\n * https://github.com/kurkle/color#readme\n * (c) 2022 Jukka Kurkela\n * Released under the MIT License\n */\nfunction round(v) {\n  return v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n  return lim(round(v * 2.55), 0, 255);\n}\nfunction n2b(v) {\n  return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n  return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n  return lim(round(v * 100), 0, 100);\n}\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = [...'0123456789ABCDEF'];\nconst h1 = b => hex[b & 0xF];\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map$1[str[1]] * 17,\n        g: 255 & map$1[str[2]] * 17,\n        b: 255 & map$1[str[3]] * 17,\n        a: len === 5 ? map$1[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map$1[str[1]] << 4 | map$1[str[2]],\n        g: map$1[str[3]] << 4 | map$1[str[4]],\n        b: map$1[str[5]] << 4 | map$1[str[6]],\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n      };\n    }\n  }\n  return ret;\n}\nconst alpha = (a, f) => a < 255 ? f(a) : '';\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\n    : undefined;\n}\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n  return [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n  return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n  if (r === max) {\n    return ((g - b) / d) + (g < b ? 6 : 0);\n  }\n  if (g === max) {\n    return (b - r) / d + 2;\n  }\n  return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = hueValue(r, g, b, d, max);\n    h = h * 60 + 0.5;\n  }\n  return [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n  return (\n    Array.isArray(a)\n      ? f(a[0], a[1], a[2])\n      : f(a, b, c)\n  ).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n  if (!m) {\n    return;\n  }\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n    : `hsl(${h}, ${s}%, ${l}%)`;\n}\nconst map = {\n  x: 'dark',\n  Z: 'light',\n  Y: 're',\n  X: 'blu',\n  W: 'gr',\n  V: 'medium',\n  U: 'slate',\n  A: 'ee',\n  T: 'ol',\n  S: 'or',\n  B: 'ra',\n  C: 'lateg',\n  D: 'ights',\n  R: 'in',\n  Q: 'turquois',\n  E: 'hi',\n  P: 'ro',\n  O: 'al',\n  N: 'le',\n  M: 'de',\n  L: 'yello',\n  F: 'en',\n  K: 'ch',\n  G: 'arks',\n  H: 'ea',\n  I: 'ightg',\n  J: 'wh'\n};\nconst names$1 = {\n  OiceXe: 'f0f8ff',\n  antiquewEte: 'faebd7',\n  aqua: 'ffff',\n  aquamarRe: '7fffd4',\n  azuY: 'f0ffff',\n  beige: 'f5f5dc',\n  bisque: 'ffe4c4',\n  black: '0',\n  blanKedOmond: 'ffebcd',\n  Xe: 'ff',\n  XeviTet: '8a2be2',\n  bPwn: 'a52a2a',\n  burlywood: 'deb887',\n  caMtXe: '5f9ea0',\n  KartYuse: '7fff00',\n  KocTate: 'd2691e',\n  cSO: 'ff7f50',\n  cSnflowerXe: '6495ed',\n  cSnsilk: 'fff8dc',\n  crimson: 'dc143c',\n  cyan: 'ffff',\n  xXe: '8b',\n  xcyan: '8b8b',\n  xgTMnPd: 'b8860b',\n  xWay: 'a9a9a9',\n  xgYF: '6400',\n  xgYy: 'a9a9a9',\n  xkhaki: 'bdb76b',\n  xmagFta: '8b008b',\n  xTivegYF: '556b2f',\n  xSange: 'ff8c00',\n  xScEd: '9932cc',\n  xYd: '8b0000',\n  xsOmon: 'e9967a',\n  xsHgYF: '8fbc8f',\n  xUXe: '483d8b',\n  xUWay: '2f4f4f',\n  xUgYy: '2f4f4f',\n  xQe: 'ced1',\n  xviTet: '9400d3',\n  dAppRk: 'ff1493',\n  dApskyXe: 'bfff',\n  dimWay: '696969',\n  dimgYy: '696969',\n  dodgerXe: '1e90ff',\n  fiYbrick: 'b22222',\n  flSOwEte: 'fffaf0',\n  foYstWAn: '228b22',\n  fuKsia: 'ff00ff',\n  gaRsbSo: 'dcdcdc',\n  ghostwEte: 'f8f8ff',\n  gTd: 'ffd700',\n  gTMnPd: 'daa520',\n  Way: '808080',\n  gYF: '8000',\n  gYFLw: 'adff2f',\n  gYy: '808080',\n  honeyMw: 'f0fff0',\n  hotpRk: 'ff69b4',\n  RdianYd: 'cd5c5c',\n  Rdigo: '4b0082',\n  ivSy: 'fffff0',\n  khaki: 'f0e68c',\n  lavFMr: 'e6e6fa',\n  lavFMrXsh: 'fff0f5',\n  lawngYF: '7cfc00',\n  NmoncEffon: 'fffacd',\n  ZXe: 'add8e6',\n  ZcSO: 'f08080',\n  Zcyan: 'e0ffff',\n  ZgTMnPdLw: 'fafad2',\n  ZWay: 'd3d3d3',\n  ZgYF: '90ee90',\n  ZgYy: 'd3d3d3',\n  ZpRk: 'ffb6c1',\n  ZsOmon: 'ffa07a',\n  ZsHgYF: '20b2aa',\n  ZskyXe: '87cefa',\n  ZUWay: '778899',\n  ZUgYy: '778899',\n  ZstAlXe: 'b0c4de',\n  ZLw: 'ffffe0',\n  lime: 'ff00',\n  limegYF: '32cd32',\n  lRF: 'faf0e6',\n  magFta: 'ff00ff',\n  maPon: '800000',\n  VaquamarRe: '66cdaa',\n  VXe: 'cd',\n  VScEd: 'ba55d3',\n  VpurpN: '9370db',\n  VsHgYF: '3cb371',\n  VUXe: '7b68ee',\n  VsprRggYF: 'fa9a',\n  VQe: '48d1cc',\n  VviTetYd: 'c71585',\n  midnightXe: '191970',\n  mRtcYam: 'f5fffa',\n  mistyPse: 'ffe4e1',\n  moccasR: 'ffe4b5',\n  navajowEte: 'ffdead',\n  navy: '80',\n  Tdlace: 'fdf5e6',\n  Tive: '808000',\n  TivedBb: '6b8e23',\n  Sange: 'ffa500',\n  SangeYd: 'ff4500',\n  ScEd: 'da70d6',\n  pOegTMnPd: 'eee8aa',\n  pOegYF: '98fb98',\n  pOeQe: 'afeeee',\n  pOeviTetYd: 'db7093',\n  papayawEp: 'ffefd5',\n  pHKpuff: 'ffdab9',\n  peru: 'cd853f',\n  pRk: 'ffc0cb',\n  plum: 'dda0dd',\n  powMrXe: 'b0e0e6',\n  purpN: '800080',\n  YbeccapurpN: '663399',\n  Yd: 'ff0000',\n  Psybrown: 'bc8f8f',\n  PyOXe: '4169e1',\n  saddNbPwn: '8b4513',\n  sOmon: 'fa8072',\n  sandybPwn: 'f4a460',\n  sHgYF: '2e8b57',\n  sHshell: 'fff5ee',\n  siFna: 'a0522d',\n  silver: 'c0c0c0',\n  skyXe: '87ceeb',\n  UXe: '6a5acd',\n  UWay: '708090',\n  UgYy: '708090',\n  snow: 'fffafa',\n  sprRggYF: 'ff7f',\n  stAlXe: '4682b4',\n  tan: 'd2b48c',\n  teO: '8080',\n  tEstN: 'd8bfd8',\n  tomato: 'ff6347',\n  Qe: '40e0d0',\n  viTet: 'ee82ee',\n  JHt: 'f5deb3',\n  wEte: 'ffffff',\n  wEtesmoke: 'f5f5f5',\n  Lw: 'ffff00',\n  LwgYF: '9acd32'\n};\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(names$1);\n  const tkeys = Object.keys(map);\n  let i, j, k, ok, nk;\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map[k]);\n    }\n    k = parseInt(names$1[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n  return unpacked;\n}\nlet names;\nfunction nameParse(str) {\n  if (!names) {\n    names = unpack();\n    names.transparent = [0, 0, 0, 0];\n  }\n  const a = names[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n  if (!m) {\n    return;\n  }\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n  }\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nfunction rgbString(v) {\n  return v && (\n    v.a < 255\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\n  );\n}\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n  const r = from(b2n(rgb1.r));\n  const g = from(b2n(rgb1.g));\n  const b = from(b2n(rgb1.b));\n  return {\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\n  };\n}\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n  var v = {r: 0, g: 0, b: 0, a: 255};\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {r: 0, g: 0, b: 0, a: 1});\n    v.a = n2b(v.a);\n  }\n  return v;\n}\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n  return hueParse(str);\n}\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n    const type = typeof input;\n    let v;\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n    this._rgb = v;\n    this._valid = !!v;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var v = clone(this._rgb);\n    if (v) {\n      v.a = b2n(v.a);\n    }\n    return v;\n  }\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : undefined;\n  }\n  hexString() {\n    return this._valid ? hexString(this._rgb) : undefined;\n  }\n  hslString() {\n    return this._valid ? hslString(this._rgb) : undefined;\n  }\n  mix(color, weight) {\n    if (color) {\n      const c1 = this.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      this.rgb = c1;\n    }\n    return this;\n  }\n  interpolate(color, t) {\n    if (color) {\n      this._rgb = interpolate(this._rgb, color._rgb, t);\n    }\n    return this;\n  }\n  clone() {\n    return new Color(this.rgb);\n  }\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n  greyscale() {\n    const rgb = this._rgb;\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n}\nfunction index_esm(input) {\n  return new Color(input);\n}\n\nfunction isPatternOrGradient(value) {\n  if (value && typeof value === 'object') {\n    const type = value.toString();\n    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n  }\n  return false;\n}\nfunction color(value) {\n  return isPatternOrGradient(value) ? value : index_esm(value);\n}\nfunction getHoverColor(value) {\n  return isPatternOrGradient(value)\n    ? value\n    : index_esm(value).saturate(0.5).darken(0.1).hexString();\n}\n\nconst overrides = Object.create(null);\nconst descriptors = Object.create(null);\nfunction getScope$1(node, key) {\n  if (!key) {\n    return node;\n  }\n  const keys = key.split('.');\n  for (let i = 0, n = keys.length; i < n; ++i) {\n    const k = keys[i];\n    node = node[k] || (node[k] = Object.create(null));\n  }\n  return node;\n}\nfunction set(root, scope, values) {\n  if (typeof scope === 'string') {\n    return merge(getScope$1(root, scope), values);\n  }\n  return merge(getScope$1(root, ''), scope);\n}\nclass Defaults {\n  constructor(_descriptors) {\n    this.animation = undefined;\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\n    this.borderColor = 'rgba(0,0,0,0.1)';\n    this.color = '#666';\n    this.datasets = {};\n    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\n    this.elements = {};\n    this.events = [\n      'mousemove',\n      'mouseout',\n      'click',\n      'touchstart',\n      'touchmove'\n    ];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: 'normal',\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n    this.indexAxis = 'x';\n    this.interaction = {\n      mode: 'nearest',\n      intersect: true,\n      includeInvisible: false\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = undefined;\n    this.scales = {};\n    this.showLine = true;\n    this.drawActiveElementsOnTop = true;\n    this.describe(_descriptors);\n  }\n  set(scope, values) {\n    return set(this, scope, values);\n  }\n  get(scope) {\n    return getScope$1(this, scope);\n  }\n  describe(scope, values) {\n    return set(descriptors, scope, values);\n  }\n  override(scope, values) {\n    return set(overrides, scope, values);\n  }\n  route(scope, name, targetScope, targetName) {\n    const scopeObject = getScope$1(this, scope);\n    const targetScopeObject = getScope$1(this, targetScope);\n    const privateName = '_' + name;\n    Object.defineProperties(scopeObject, {\n      [privateName]: {\n        value: scopeObject[name],\n        writable: true\n      },\n      [name]: {\n        enumerable: true,\n        get() {\n          const local = this[privateName];\n          const target = targetScopeObject[targetName];\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n          return valueOrDefault(local, target);\n        },\n        set(value) {\n          this[privateName] = value;\n        }\n      }\n    });\n  }\n}\nvar defaults = new Defaults({\n  _scriptable: (name) => !name.startsWith('on'),\n  _indexable: (name) => name !== 'events',\n  hover: {\n    _fallback: 'interaction'\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false,\n  }\n});\n\nfunction toFontString(font) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n  return (font.style ? font.style + ' ' : '')\n\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t+ font.size + 'px '\n\t\t+ font.family;\n}\nfunction _measureText(ctx, data, gc, longest, string) {\n  let textWidth = data[string];\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n  return longest;\n}\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n  cache = cache || {};\n  let data = cache.data = cache.data || {};\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n  ctx.save();\n  ctx.font = font;\n  let longest = 0;\n  const ilen = arrayOfThings.length;\n  let i, j, jlen, thing, nestedThing;\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n    if (thing !== undefined && thing !== null && isArray(thing) !== true) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n  ctx.restore();\n  const gcLen = gc.length / 2;\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n    gc.splice(0, gcLen);\n  }\n  return longest;\n}\nfunction _alignPixel(chart, pixel, width) {\n  const devicePixelRatio = chart.currentDevicePixelRatio;\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\nfunction clearCanvas(canvas, ctx) {\n  ctx = ctx || canvas.getContext('2d');\n  ctx.save();\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\nfunction drawPoint(ctx, options, x, y) {\n  drawPointLegend(ctx, options, x, y, null);\n}\nfunction drawPointLegend(ctx, options, x, y, w) {\n  let type, xOffset, yOffset, size, cornerRadius, width;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  const radius = options.radius;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n  if (style && typeof style === 'object') {\n    type = style.toString();\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n  ctx.beginPath();\n  switch (style) {\n  default:\n    if (w) {\n      ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n    } else {\n      ctx.arc(x, y, radius, 0, TAU);\n    }\n    ctx.closePath();\n    break;\n  case 'triangle':\n    ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    rad += TWO_THIRDS_PI;\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    rad += TWO_THIRDS_PI;\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    ctx.closePath();\n    break;\n  case 'rectRounded':\n    cornerRadius = radius * 0.516;\n    size = radius - cornerRadius;\n    xOffset = Math.cos(rad + QUARTER_PI) * size;\n    yOffset = Math.sin(rad + QUARTER_PI) * size;\n    ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n    ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n    ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n    ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n    ctx.closePath();\n    break;\n  case 'rect':\n    if (!rotation) {\n      size = Math.SQRT1_2 * radius;\n      width = w ? w / 2 : size;\n      ctx.rect(x - width, y - size, 2 * width, 2 * size);\n      break;\n    }\n    rad += QUARTER_PI;\n  case 'rectRot':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    ctx.closePath();\n    break;\n  case 'crossRot':\n    rad += QUARTER_PI;\n  case 'cross':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    break;\n  case 'star':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    rad += QUARTER_PI;\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    break;\n  case 'line':\n    xOffset = w ? w / 2 : Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    break;\n  case 'dash':\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n    break;\n  }\n  ctx.fill();\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\nfunction _isPointInArea(point, area, margin) {\n  margin = margin || 0.5;\n  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&\n\t\tpoint.y > area.top - margin && point.y < area.bottom + margin);\n}\nfunction clipArea(ctx, area) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\nfunction unclipArea(ctx) {\n  ctx.restore();\n}\nfunction _steppedLineTo(ctx, previous, target, flip, mode) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  if (mode === 'middle') {\n    const midpoint = (previous.x + target.x) / 2.0;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === 'after' !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n  ctx.lineTo(target.x, target.y);\n}\nfunction _bezierCurveTo(ctx, previous, target, flip) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  ctx.bezierCurveTo(\n    flip ? previous.cp1x : previous.cp2x,\n    flip ? previous.cp1y : previous.cp2y,\n    flip ? target.cp2x : target.cp1x,\n    flip ? target.cp2y : target.cp1y,\n    target.x,\n    target.y);\n}\nfunction renderText(ctx, text, x, y, font, opts = {}) {\n  const lines = isArray(text) ? text : [text];\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n  let i, line;\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n    y += font.lineHeight;\n  }\n  ctx.restore();\n}\nfunction setRenderOpts(ctx, opts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\nfunction decorateText(ctx, x, y, line, opts) {\n  if (opts.strikethrough || opts.underline) {\n    const metrics = ctx.measureText(line);\n    const left = x - metrics.actualBoundingBoxLeft;\n    const right = x + metrics.actualBoundingBoxRight;\n    const top = y - metrics.actualBoundingBoxAscent;\n    const bottom = y + metrics.actualBoundingBoxDescent;\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\nfunction addRoundedRectPath(ctx, rect) {\n  const {x, y, w, h, radius} = rect;\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n  ctx.lineTo(x + w, y + radius.topRight);\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n  ctx.lineTo(x + radius.topLeft, y);\n}\n\nconst LINE_HEIGHT = new RegExp(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\nconst FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);\nfunction toLineHeight(value, size) {\n  const matches = ('' + value).match(LINE_HEIGHT);\n  if (!matches || matches[1] === 'normal') {\n    return size * 1.2;\n  }\n  value = +matches[2];\n  switch (matches[3]) {\n  case 'px':\n    return value;\n  case '%':\n    value /= 100;\n    break;\n  }\n  return size * value;\n}\nconst numberOrZero = v => +v || 0;\nfunction _readValueToProps(value, props) {\n  const ret = {};\n  const objProps = isObject(props);\n  const keys = objProps ? Object.keys(props) : props;\n  const read = isObject(value)\n    ? objProps\n      ? prop => valueOrDefault(value[prop], value[props[prop]])\n      : prop => value[prop]\n    : () => value;\n  for (const prop of keys) {\n    ret[prop] = numberOrZero(read(prop));\n  }\n  return ret;\n}\nfunction toTRBL(value) {\n  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\n}\nfunction toTRBLCorners(value) {\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n}\nfunction toPadding(value) {\n  const obj = toTRBL(value);\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n  return obj;\n}\nfunction toFont(options, fallback) {\n  options = options || {};\n  fallback = fallback || defaults.font;\n  let size = valueOrDefault(options.size, fallback.size);\n  if (typeof size === 'string') {\n    size = parseInt(size, 10);\n  }\n  let style = valueOrDefault(options.style, fallback.style);\n  if (style && !('' + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = '';\n  }\n  const font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size,\n    style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: ''\n  };\n  font.string = toFontString(font);\n  return font;\n}\nfunction resolve(inputs, context, index, info) {\n  let cacheable = true;\n  let i, ilen, value;\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n    if (value === undefined) {\n      continue;\n    }\n    if (context !== undefined && typeof value === 'function') {\n      value = value(context);\n      cacheable = false;\n    }\n    if (index !== undefined && isArray(value)) {\n      value = value[index % value.length];\n      cacheable = false;\n    }\n    if (value !== undefined) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n      return value;\n    }\n  }\n}\nfunction _addGrace(minmax, grace, beginAtZero) {\n  const {min, max} = minmax;\n  const change = toDimension(grace, (max - min) / 2);\n  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;\n  return {\n    min: keepZero(min, -Math.abs(change)),\n    max: keepZero(max, change)\n  };\n}\nfunction createContext(parentContext, context) {\n  return Object.assign(Object.create(parentContext), context);\n}\n\nfunction _createResolver(scopes, prefixes = [''], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {\n  if (!defined(fallback)) {\n    fallback = _resolve('_fallback', scopes);\n  }\n  const cache = {\n    [Symbol.toStringTag]: 'Object',\n    _cacheable: true,\n    _scopes: scopes,\n    _rootScopes: rootScopes,\n    _fallback: fallback,\n    _getTarget: getTarget,\n    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback),\n  };\n  return new Proxy(cache, {\n    deleteProperty(target, prop) {\n      delete target[prop];\n      delete target._keys;\n      delete scopes[0][prop];\n      return true;\n    },\n    get(target, prop) {\n      return _cached(target, prop,\n        () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n    },\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n    has(target, prop) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n    ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n    set(target, prop, value) {\n      const storage = target._storage || (target._storage = getTarget());\n      target[prop] = storage[prop] = value;\n      delete target._keys;\n      return true;\n    }\n  });\n}\nfunction _attachContext(proxy, context, subProxy, descriptorDefaults) {\n  const cache = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n  };\n  return new Proxy(cache, {\n    deleteProperty(target, prop) {\n      delete target[prop];\n      delete proxy[prop];\n      return true;\n    },\n    get(target, prop, receiver) {\n      return _cached(target, prop,\n        () => _resolveWithContext(target, prop, receiver));\n    },\n    getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys\n        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\n        : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n    has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n    ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n    set(target, prop, value) {\n      proxy[prop] = value;\n      delete target[prop];\n      return true;\n    }\n  });\n}\nfunction _descriptors(proxy, defaults = {scriptable: true, indexable: true}) {\n  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n  };\n}\nconst readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters' &&\n  (Object.getPrototypeOf(value) === null || value.constructor === Object);\nfunction _cached(target, prop, resolve) {\n  if (Object.prototype.hasOwnProperty.call(target, prop)) {\n    return target[prop];\n  }\n  const value = resolve();\n  target[prop] = value;\n  return value;\n}\nfunction _resolveWithContext(target, prop, receiver) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  let value = _proxy[prop];\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n  }\n  if (needsSubResolver(prop, value)) {\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n  }\n  return value;\n}\nfunction _resolveScriptable(prop, value, target, receiver) {\n  const {_proxy, _context, _subProxy, _stack} = target;\n  if (_stack.has(prop)) {\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n  }\n  _stack.add(prop);\n  value = value(_context, _subProxy || receiver);\n  _stack.delete(prop);\n  if (needsSubResolver(prop, value)) {\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n  return value;\n}\nfunction _resolveArray(prop, value, target, isIndexable) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  if (defined(_context.index) && isIndexable(prop)) {\n    value = value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    const arr = value;\n    const scopes = _proxy._scopes.filter(s => s !== arr);\n    value = [];\n    for (const item of arr) {\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n    }\n  }\n  return value;\n}\nfunction resolveFallback(fallback, prop, value) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\nconst getScope = (key, parent) => key === true ? parent\n  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\n  for (const parent of parentScopes) {\n    const scope = getScope(key, parent);\n    if (scope) {\n      set.add(scope);\n      const fallback = resolveFallback(scope._fallback, key, value);\n      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {\n        return fallback;\n      }\n    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {\n      return null;\n    }\n  }\n  return false;\n}\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n  const rootScopes = resolver._rootScopes;\n  const fallback = resolveFallback(resolver._fallback, prop, value);\n  const allScopes = [...parentScopes, ...rootScopes];\n  const set = new Set();\n  set.add(value);\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n  if (key === null) {\n    return false;\n  }\n  if (defined(fallback) && fallback !== prop) {\n    key = addScopesFromKey(set, allScopes, fallback, key, value);\n    if (key === null) {\n      return false;\n    }\n  }\n  return _createResolver(Array.from(set), [''], rootScopes, fallback,\n    () => subGetTarget(resolver, prop, value));\n}\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\n  while (key) {\n    key = addScopes(set, allScopes, key, fallback, item);\n  }\n  return key;\n}\nfunction subGetTarget(resolver, prop, value) {\n  const parent = resolver._getTarget();\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n  const target = parent[prop];\n  if (isArray(target) && isObject(value)) {\n    return value;\n  }\n  return target;\n}\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n  let value;\n  for (const prefix of prefixes) {\n    value = _resolve(readKey(prefix, prop), scopes);\n    if (defined(value)) {\n      return needsSubResolver(prop, value)\n        ? createSubResolver(scopes, proxy, prop, value)\n        : value;\n    }\n  }\n}\nfunction _resolve(key, scopes) {\n  for (const scope of scopes) {\n    if (!scope) {\n      continue;\n    }\n    const value = scope[key];\n    if (defined(value)) {\n      return value;\n    }\n  }\n}\nfunction getKeysFromAllScopes(target) {\n  let keys = target._keys;\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n  return keys;\n}\nfunction resolveKeysFromAllScopes(scopes) {\n  const set = new Set();\n  for (const scope of scopes) {\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\n      set.add(key);\n    }\n  }\n  return Array.from(set);\n}\nfunction _parseObjectDataRadialScale(meta, data, start, count) {\n  const {iScale} = meta;\n  const {key = 'r'} = this._parsing;\n  const parsed = new Array(count);\n  let i, ilen, index, item;\n  for (i = 0, ilen = count; i < ilen; ++i) {\n    index = i + start;\n    item = data[index];\n    parsed[i] = {\n      r: iScale.parse(resolveObjectKey(item, key), index)\n    };\n  }\n  return parsed;\n}\n\nconst EPSILON = Number.EPSILON || 1e-14;\nconst getPoint = (points, i) => i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis) => indexAxis === 'x' ? 'y' : 'x';\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\n  const current = middlePoint;\n  const next = afterPoint.skip ? middlePoint : afterPoint;\n  const d01 = distanceBetweenPoints(current, previous);\n  const d12 = distanceBetweenPoints(next, current);\n  let s01 = d01 / (d01 + d12);\n  let s12 = d12 / (d01 + d12);\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n  const fa = t * s01;\n  const fb = t * s12;\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\nfunction monotoneAdjust(points, deltaK, mK) {\n  const pointsLen = points.length;\n  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\nfunction monotoneCompute(points, mK, indexAxis = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  let delta, pointBefore, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n    const iPixel = pointCurrent[indexAxis];\n    const vPixel = pointCurrent[valueAxis];\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n    }\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n    }\n  }\n}\nfunction splineCurveMonotone(points, indexAxis = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  const deltaK = Array(pointsLen).fill(0);\n  const mK = Array(pointsLen);\n  let i, pointBefore, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n    if (pointAfter) {\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n    mK[i] = !pointBefore ? deltaK[i]\n      : !pointAfter ? deltaK[i - 1]\n      : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\n      : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n  monotoneAdjust(points, deltaK, mK);\n  monotoneCompute(points, mK, indexAxis);\n}\nfunction capControlPoint(pt, min, max) {\n  return Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n  let i, ilen, point, inArea, inAreaPrev;\n  let inAreaNext = _isPointInArea(points[0], area);\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n    if (!inArea) {\n      continue;\n    }\n    point = points[i];\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\nfunction _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n  let i, ilen, point, controlPoints;\n  if (options.spanGaps) {\n    points = points.filter((pt) => !pt.skip);\n  }\n  if (options.cubicInterpolationMode === 'monotone') {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    let prev = loop ? points[points.length - 1] : points[0];\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(\n        prev,\n        point,\n        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\n        options.tension\n      );\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\n\nfunction _isDomSupported() {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\nfunction _getParentNode(domNode) {\n  let parent = domNode.parentNode;\n  if (parent && parent.toString() === '[object ShadowRoot]') {\n    parent = parent.host;\n  }\n  return parent;\n}\nfunction parseMaxStyle(styleValue, node, parentProperty) {\n  let valueInPixels;\n  if (typeof styleValue === 'string') {\n    valueInPixels = parseInt(styleValue, 10);\n    if (styleValue.indexOf('%') !== -1) {\n      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n  return valueInPixels;\n}\nconst getComputedStyle = (element) => window.getComputedStyle(element, null);\nfunction getStyle(el, property) {\n  return getComputedStyle(el).getPropertyValue(property);\n}\nconst positions = ['top', 'right', 'bottom', 'left'];\nfunction getPositionedStyle(styles, style, suffix) {\n  const result = {};\n  suffix = suffix ? '-' + suffix : '';\n  for (let i = 0; i < 4; i++) {\n    const pos = positions[i];\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n  }\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\nconst useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);\nfunction getCanvasPosition(e, canvas) {\n  const touches = e.touches;\n  const source = touches && touches.length ? touches[0] : e;\n  const {offsetX, offsetY} = source;\n  let box = false;\n  let x, y;\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    const rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n  return {x, y, box};\n}\nfunction getRelativePosition(evt, chart) {\n  if ('native' in evt) {\n    return evt;\n  }\n  const {canvas, currentDevicePixelRatio} = chart;\n  const style = getComputedStyle(canvas);\n  const borderBox = style.boxSizing === 'border-box';\n  const paddings = getPositionedStyle(style, 'padding');\n  const borders = getPositionedStyle(style, 'border', 'width');\n  const {x, y, box} = getCanvasPosition(evt, canvas);\n  const xOffset = paddings.left + (box && borders.left);\n  const yOffset = paddings.top + (box && borders.top);\n  let {width, height} = chart;\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\nfunction getContainerSize(canvas, width, height) {\n  let maxWidth, maxHeight;\n  if (width === undefined || height === undefined) {\n    const container = _getParentNode(canvas);\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      const rect = container.getBoundingClientRect();\n      const containerStyle = getComputedStyle(container);\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n    }\n  }\n  return {\n    width,\n    height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\nconst round1 = v => Math.round(v * 10) / 10;\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n  const style = getComputedStyle(canvas);\n  const margins = getPositionedStyle(style, 'margin');\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  let {width, height} = containerSize;\n  if (style.boxSizing === 'content-box') {\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const paddings = getPositionedStyle(style, 'padding');\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n  if (width && !height) {\n    height = round1(width / 2);\n  }\n  return {\n    width,\n    height\n  };\n}\nfunction retinaScale(chart, forceRatio, forceStyle) {\n  const pixelRatio = forceRatio || 1;\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\n  chart.height = deviceHeight / pixelRatio;\n  chart.width = deviceWidth / pixelRatio;\n  const canvas = chart.canvas;\n  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\n    canvas.style.height = `${chart.height}px`;\n    canvas.style.width = `${chart.width}px`;\n  }\n  if (chart.currentDevicePixelRatio !== pixelRatio\n      || canvas.height !== deviceHeight\n      || canvas.width !== deviceWidth) {\n    chart.currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n  return false;\n}\nconst supportsEventListenerOptions = (function() {\n  let passiveSupported = false;\n  try {\n    const options = {\n      get passive() {\n        passiveSupported = true;\n        return false;\n      }\n    };\n    window.addEventListener('test', null, options);\n    window.removeEventListener('test', null, options);\n  } catch (e) {\n  }\n  return passiveSupported;\n}());\nfunction readUsedSize(element, property) {\n  const value = getStyle(element, property);\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : undefined;\n}\n\nfunction _pointInLine(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\nfunction _steppedInterpolation(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\n    : mode === 'after' ? t < 1 ? p1.y : p2.y\n    : t > 0 ? p2.y : p1.y\n  };\n}\nfunction _bezierInterpolation(p1, p2, t, mode) {\n  const cp1 = {x: p1.cp2x, y: p1.cp2y};\n  const cp2 = {x: p2.cp1x, y: p2.cp1y};\n  const a = _pointInLine(p1, cp1, t);\n  const b = _pointInLine(cp1, cp2, t);\n  const c = _pointInLine(cp2, p2, t);\n  const d = _pointInLine(a, b, t);\n  const e = _pointInLine(b, c, t);\n  return _pointInLine(d, e, t);\n}\n\nconst intlCache = new Map();\nfunction getNumberFormat(locale, options) {\n  options = options || {};\n  const cacheKey = locale + JSON.stringify(options);\n  let formatter = intlCache.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n  return formatter;\n}\nfunction formatNumber(num, locale, options) {\n  return getNumberFormat(locale, options).format(num);\n}\n\nconst getRightToLeftAdapter = function(rectX, width) {\n  return {\n    x(x) {\n      return rectX + rectX + width - x;\n    },\n    setWidth(w) {\n      width = w;\n    },\n    textAlign(align) {\n      if (align === 'center') {\n        return align;\n      }\n      return align === 'right' ? 'left' : 'right';\n    },\n    xPlus(x, value) {\n      return x - value;\n    },\n    leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    },\n  };\n};\nconst getLeftToRightAdapter = function() {\n  return {\n    x(x) {\n      return x;\n    },\n    setWidth(w) {\n    },\n    textAlign(align) {\n      return align;\n    },\n    xPlus(x, value) {\n      return x + value;\n    },\n    leftForLtr(x, _itemWidth) {\n      return x;\n    },\n  };\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n  let style, original;\n  if (direction === 'ltr' || direction === 'rtl') {\n    style = ctx.canvas.style;\n    original = [\n      style.getPropertyValue('direction'),\n      style.getPropertyPriority('direction'),\n    ];\n    style.setProperty('direction', direction, 'important');\n    ctx.prevTextDirection = original;\n  }\n}\nfunction restoreTextDirection(ctx, original) {\n  if (original !== undefined) {\n    delete ctx.prevTextDirection;\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n  }\n}\n\nfunction propertyFn(property) {\n  if (property === 'angle') {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle,\n    };\n  }\n  return {\n    between: _isBetween,\n    compare: (a, b) => a - b,\n    normalize: x => x\n  };\n}\nfunction normalizeSegment({start, end, count, loop, style}) {\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style\n  };\n}\nfunction getSegment(segment, points, bounds) {\n  const {property, start: startBound, end: endBound} = bounds;\n  const {between, normalize} = propertyFn(property);\n  const count = points.length;\n  let {start, end, loop} = segment;\n  let i, ilen;\n  if (loop) {\n    start += count;\n    end += count;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n      start--;\n      end--;\n    }\n    start %= count;\n    end %= count;\n  }\n  if (end < start) {\n    end += count;\n  }\n  return {start, end, loop, style: segment.style};\n}\nfunction _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n  const {property, start: startBound, end: endBound} = bounds;\n  const count = points.length;\n  const {compare, between, normalize} = propertyFn(property);\n  const {start, end, loop, style} = getSegment(segment, points, bounds);\n  const result = [];\n  let inside = false;\n  let subStart = null;\n  let value, point, prevValue;\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n  const shouldStart = () => inside || startIsBefore();\n  const shouldStop = () => !inside || endIsBefore();\n  for (let i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n    if (point.skip) {\n      continue;\n    }\n    value = normalize(point[property]);\n    if (value === prevValue) {\n      continue;\n    }\n    inside = between(value, startBound, endBound);\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));\n      subStart = null;\n    }\n    prev = i;\n    prevValue = value;\n  }\n  if (subStart !== null) {\n    result.push(normalizeSegment({start: subStart, end, loop, count, style}));\n  }\n  return result;\n}\nfunction _boundSegments(line, bounds) {\n  const result = [];\n  const segments = line.segments;\n  for (let i = 0; i < segments.length; i++) {\n    const sub = _boundSegment(segments[i], line.points, bounds);\n    if (sub.length) {\n      result.push(...sub);\n    }\n  }\n  return result;\n}\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  let start = 0;\n  let end = count - 1;\n  if (loop && !spanGaps) {\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n  while (start < count && points[start].skip) {\n    start++;\n  }\n  start %= count;\n  if (loop) {\n    end += start;\n  }\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n  end %= count;\n  return {start, end};\n}\nfunction solidSegments(points, start, max, loop) {\n  const count = points.length;\n  const result = [];\n  let last = start;\n  let prev = points[start];\n  let end;\n  for (end = start + 1; end <= max; ++end) {\n    const cur = points[end % count];\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({start: start % count, end: (end - 1) % count, loop});\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n      if (prev.skip) {\n        start = end;\n      }\n    }\n    prev = cur;\n  }\n  if (last !== null) {\n    result.push({start: start % count, end: last % count, loop});\n  }\n  return result;\n}\nfunction _computeSegments(line, segmentOptions) {\n  const points = line.points;\n  const spanGaps = line.options.spanGaps;\n  const count = points.length;\n  if (!count) {\n    return [];\n  }\n  const loop = !!line._loop;\n  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\n  if (spanGaps === true) {\n    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);\n  }\n  const max = end < start ? end + count : end;\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  const chartContext = line._chart.getContext();\n  const baseStyle = readStyle(line.options);\n  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;\n  const count = points.length;\n  const result = [];\n  let prevStyle = baseStyle;\n  let start = segments[0].start;\n  let i = start;\n  function addStyle(s, e, l, st) {\n    const dir = spanGaps ? -1 : 1;\n    if (s === e) {\n      return;\n    }\n    s += count;\n    while (points[s % count].skip) {\n      s -= dir;\n    }\n    while (points[e % count].skip) {\n      e += dir;\n    }\n    if (s % count !== e % count) {\n      result.push({start: s % count, end: e % count, loop: l, style: st});\n      prevStyle = st;\n      start = e % count;\n    }\n  }\n  for (const segment of segments) {\n    start = spanGaps ? start : segment.start;\n    let prev = points[start % count];\n    let style;\n    for (i = start + 1; i <= segment.end; i++) {\n      const pt = points[i % count];\n      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n        type: 'segment',\n        p0: prev,\n        p1: pt,\n        p0DataIndex: (i - 1) % count,\n        p1DataIndex: i % count,\n        datasetIndex\n      })));\n      if (styleChanged(style, prevStyle)) {\n        addStyle(start, i - 1, segment.loop, prevStyle);\n      }\n      prev = pt;\n      prevStyle = style;\n    }\n    if (start < i - 1) {\n      addStyle(start, i - 1, segment.loop, prevStyle);\n    }\n  }\n  return result;\n}\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\nfunction styleChanged(style, prevStyle) {\n  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);\n}\n\nexport { _isPointInArea as $, _factorize as A, finiteOrDefault as B, callback as C, _addGrace as D, _limitValue as E, toDegrees as F, _measureText as G, HALF_PI as H, _int16Range as I, _alignPixel as J, toPadding as K, clipArea as L, renderText as M, unclipArea as N, toFont as O, PI as P, each as Q, _toLeftRightCenter as R, _alignStartEnd as S, TAU as T, overrides as U, merge as V, _capitalize as W, getRelativePosition as X, _rlookupByKey as Y, _lookupByKey as Z, _arrayUnique as _, resolve as a, toLineHeight as a$, getAngleFromPoint as a0, getMaximumSize as a1, _getParentNode as a2, readUsedSize as a3, throttled as a4, supportsEventListenerOptions as a5, _isDomSupported as a6, descriptors as a7, isFunction as a8, _attachContext as a9, getRtlAdapter as aA, overrideTextDirection as aB, _textX as aC, restoreTextDirection as aD, drawPointLegend as aE, noop as aF, distanceBetweenPoints as aG, _setMinAndMaxByKey as aH, niceNum as aI, almostWhole as aJ, almostEquals as aK, _decimalPlaces as aL, _longestText as aM, _filterBetween as aN, _lookup as aO, isPatternOrGradient as aP, getHoverColor as aQ, clone$1 as aR, _merger as aS, _mergerIf as aT, _deprecated as aU, _splitKey as aV, toFontString as aW, splineCurve as aX, splineCurveMonotone as aY, getStyle as aZ, fontString as a_, _createResolver as aa, _descriptors as ab, mergeIf as ac, uid as ad, debounce as ae, retinaScale as af, clearCanvas as ag, setsEqual as ah, _elementsEqual as ai, _isClickEvent as aj, _isBetween as ak, _readValueToProps as al, _updateBezierControlPoints as am, _computeSegments as an, _boundSegments as ao, _steppedInterpolation as ap, _bezierInterpolation as aq, _pointInLine as ar, _steppedLineTo as as, _bezierCurveTo as at, drawPoint as au, addRoundedRectPath as av, toTRBL as aw, toTRBLCorners as ax, _boundSegment as ay, _normalizeAngle as az, isArray as b, PITAU as b0, INFINITY as b1, RAD_PER_DEG as b2, QUARTER_PI as b3, TWO_THIRDS_PI as b4, _angleDiff as b5, color as c, defaults as d, effects as e, resolveObjectKey as f, isNumberFinite as g, createContext as h, isObject as i, defined as j, isNullOrUndef as k, listenArrayEvents as l, toPercentage as m, toDimension as n, formatNumber as o, _angleBetween as p, _getStartAndCountOfVisiblePoints as q, requestAnimFrame as r, sign as s, toRadians as t, unlistenArrayEvents as u, valueOrDefault as v, _scaleRangesChanged as w, isNumber as x, _parseObjectDataRadialScale as y, log10 as z };\n","/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */\nimport { r as requestAnimFrame, a as resolve, e as effects, c as color, d as defaults, i as isObject, b as isArray, v as valueOrDefault, u as unlistenArrayEvents, l as listenArrayEvents, f as resolveObjectKey, g as isNumberFinite, h as createContext, j as defined, s as sign, k as isNullOrUndef, _ as _arrayUnique, t as toRadians, m as toPercentage, n as toDimension, T as TAU, o as formatNumber, p as _angleBetween, H as HALF_PI, P as PI, q as _getStartAndCountOfVisiblePoints, w as _scaleRangesChanged, x as isNumber, y as _parseObjectDataRadialScale, z as log10, A as _factorize, B as finiteOrDefault, C as callback, D as _addGrace, E as _limitValue, F as toDegrees, G as _measureText, I as _int16Range, J as _alignPixel, K as toPadding, L as clipArea, M as renderText, N as unclipArea, O as toFont, Q as each, R as _toLeftRightCenter, S as _alignStartEnd, U as overrides, V as merge, W as _capitalize, X as getRelativePosition, Y as _rlookupByKey, Z as _lookupByKey, $ as _isPointInArea, a0 as getAngleFromPoint, a1 as getMaximumSize, a2 as _getParentNode, a3 as readUsedSize, a4 as throttled, a5 as supportsEventListenerOptions, a6 as _isDomSupported, a7 as descriptors, a8 as isFunction, a9 as _attachContext, aa as _createResolver, ab as _descriptors, ac as mergeIf, ad as uid, ae as debounce, af as retinaScale, ag as clearCanvas, ah as setsEqual, ai as _elementsEqual, aj as _isClickEvent, ak as _isBetween, al as _readValueToProps, am as _updateBezierControlPoints, an as _computeSegments, ao as _boundSegments, ap as _steppedInterpolation, aq as _bezierInterpolation, ar as _pointInLine, as as _steppedLineTo, at as _bezierCurveTo, au as drawPoint, av as addRoundedRectPath, aw as toTRBL, ax as toTRBLCorners, ay as _boundSegment, az as _normalizeAngle, aA as getRtlAdapter, aB as overrideTextDirection, aC as _textX, aD as restoreTextDirection, aE as drawPointLegend, aF as noop, aG as distanceBetweenPoints, aH as _setMinAndMaxByKey, aI as niceNum, aJ as almostWhole, aK as almostEquals, aL as _decimalPlaces, aM as _longestText, aN as _filterBetween, aO as _lookup } from './chunks/helpers.segment.mjs';\nexport { d as defaults } from './chunks/helpers.segment.mjs';\n\nclass Animator {\n  constructor() {\n    this._request = null;\n    this._charts = new Map();\n    this._running = false;\n    this._lastDate = undefined;\n  }\n  _notify(chart, anims, date, type) {\n    const callbacks = anims.listeners[type];\n    const numSteps = anims.duration;\n    callbacks.forEach(fn => fn({\n      chart,\n      initial: anims.initial,\n      numSteps,\n      currentStep: Math.min(date - anims.start, numSteps)\n    }));\n  }\n  _refresh() {\n    if (this._request) {\n      return;\n    }\n    this._running = true;\n    this._request = requestAnimFrame.call(window, () => {\n      this._update();\n      this._request = null;\n      if (this._running) {\n        this._refresh();\n      }\n    });\n  }\n  _update(date = Date.now()) {\n    let remaining = 0;\n    this._charts.forEach((anims, chart) => {\n      if (!anims.running || !anims.items.length) {\n        return;\n      }\n      const items = anims.items;\n      let i = items.length - 1;\n      let draw = false;\n      let item;\n      for (; i >= 0; --i) {\n        item = items[i];\n        if (item._active) {\n          if (item._total > anims.duration) {\n            anims.duration = item._total;\n          }\n          item.tick(date);\n          draw = true;\n        } else {\n          items[i] = items[items.length - 1];\n          items.pop();\n        }\n      }\n      if (draw) {\n        chart.draw();\n        this._notify(chart, anims, date, 'progress');\n      }\n      if (!items.length) {\n        anims.running = false;\n        this._notify(chart, anims, date, 'complete');\n        anims.initial = false;\n      }\n      remaining += items.length;\n    });\n    this._lastDate = date;\n    if (remaining === 0) {\n      this._running = false;\n    }\n  }\n  _getAnims(chart) {\n    const charts = this._charts;\n    let anims = charts.get(chart);\n    if (!anims) {\n      anims = {\n        running: false,\n        initial: true,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      };\n      charts.set(chart, anims);\n    }\n    return anims;\n  }\n  listen(chart, event, cb) {\n    this._getAnims(chart).listeners[event].push(cb);\n  }\n  add(chart, items) {\n    if (!items || !items.length) {\n      return;\n    }\n    this._getAnims(chart).items.push(...items);\n  }\n  has(chart) {\n    return this._getAnims(chart).items.length > 0;\n  }\n  start(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims) {\n      return;\n    }\n    anims.running = true;\n    anims.start = Date.now();\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\n    this._refresh();\n  }\n  running(chart) {\n    if (!this._running) {\n      return false;\n    }\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.running || !anims.items.length) {\n      return false;\n    }\n    return true;\n  }\n  stop(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.items.length) {\n      return;\n    }\n    const items = anims.items;\n    let i = items.length - 1;\n    for (; i >= 0; --i) {\n      items[i].cancel();\n    }\n    anims.items = [];\n    this._notify(chart, anims, Date.now(), 'complete');\n  }\n  remove(chart) {\n    return this._charts.delete(chart);\n  }\n}\nvar animator = new Animator();\n\nconst transparent = 'transparent';\nconst interpolators = {\n  boolean(from, to, factor) {\n    return factor > 0.5 ? to : from;\n  },\n  color(from, to, factor) {\n    const c0 = color(from || transparent);\n    const c1 = c0.valid && color(to || transparent);\n    return c1 && c1.valid\n      ? c1.mix(c0, factor).hexString()\n      : to;\n  },\n  number(from, to, factor) {\n    return from + (to - from) * factor;\n  }\n};\nclass Animation {\n  constructor(cfg, target, prop, to) {\n    const currentValue = target[prop];\n    to = resolve([cfg.to, to, currentValue, cfg.from]);\n    const from = resolve([cfg.from, currentValue, to]);\n    this._active = true;\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n    this._easing = effects[cfg.easing] || effects.linear;\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\n    this._duration = this._total = Math.floor(cfg.duration);\n    this._loop = !!cfg.loop;\n    this._target = target;\n    this._prop = prop;\n    this._from = from;\n    this._to = to;\n    this._promises = undefined;\n  }\n  active() {\n    return this._active;\n  }\n  update(cfg, to, date) {\n    if (this._active) {\n      this._notify(false);\n      const currentValue = this._target[this._prop];\n      const elapsed = date - this._start;\n      const remain = this._duration - elapsed;\n      this._start = date;\n      this._duration = Math.floor(Math.max(remain, cfg.duration));\n      this._total += elapsed;\n      this._loop = !!cfg.loop;\n      this._to = resolve([cfg.to, to, currentValue, cfg.from]);\n      this._from = resolve([cfg.from, currentValue, to]);\n    }\n  }\n  cancel() {\n    if (this._active) {\n      this.tick(Date.now());\n      this._active = false;\n      this._notify(false);\n    }\n  }\n  tick(date) {\n    const elapsed = date - this._start;\n    const duration = this._duration;\n    const prop = this._prop;\n    const from = this._from;\n    const loop = this._loop;\n    const to = this._to;\n    let factor;\n    this._active = from !== to && (loop || (elapsed < duration));\n    if (!this._active) {\n      this._target[prop] = to;\n      this._notify(true);\n      return;\n    }\n    if (elapsed < 0) {\n      this._target[prop] = from;\n      return;\n    }\n    factor = (elapsed / duration) % 2;\n    factor = loop && factor > 1 ? 2 - factor : factor;\n    factor = this._easing(Math.min(1, Math.max(0, factor)));\n    this._target[prop] = this._fn(from, to, factor);\n  }\n  wait() {\n    const promises = this._promises || (this._promises = []);\n    return new Promise((res, rej) => {\n      promises.push({res, rej});\n    });\n  }\n  _notify(resolved) {\n    const method = resolved ? 'res' : 'rej';\n    const promises = this._promises || [];\n    for (let i = 0; i < promises.length; i++) {\n      promises[i][method]();\n    }\n  }\n}\n\nconst numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['color', 'borderColor', 'backgroundColor'];\ndefaults.set('animation', {\n  delay: undefined,\n  duration: 1000,\n  easing: 'easeOutQuart',\n  fn: undefined,\n  from: undefined,\n  loop: undefined,\n  to: undefined,\n  type: undefined,\n});\nconst animationOptions = Object.keys(defaults.animation);\ndefaults.describe('animation', {\n  _fallback: false,\n  _indexable: false,\n  _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\n});\ndefaults.set('animations', {\n  colors: {\n    type: 'color',\n    properties: colors\n  },\n  numbers: {\n    type: 'number',\n    properties: numbers\n  },\n});\ndefaults.describe('animations', {\n  _fallback: 'animation',\n});\ndefaults.set('transitions', {\n  active: {\n    animation: {\n      duration: 400\n    }\n  },\n  resize: {\n    animation: {\n      duration: 0\n    }\n  },\n  show: {\n    animations: {\n      colors: {\n        from: 'transparent'\n      },\n      visible: {\n        type: 'boolean',\n        duration: 0\n      },\n    }\n  },\n  hide: {\n    animations: {\n      colors: {\n        to: 'transparent'\n      },\n      visible: {\n        type: 'boolean',\n        easing: 'linear',\n        fn: v => v | 0\n      },\n    }\n  }\n});\nclass Animations {\n  constructor(chart, config) {\n    this._chart = chart;\n    this._properties = new Map();\n    this.configure(config);\n  }\n  configure(config) {\n    if (!isObject(config)) {\n      return;\n    }\n    const animatedProps = this._properties;\n    Object.getOwnPropertyNames(config).forEach(key => {\n      const cfg = config[key];\n      if (!isObject(cfg)) {\n        return;\n      }\n      const resolved = {};\n      for (const option of animationOptions) {\n        resolved[option] = cfg[option];\n      }\n      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\n        if (prop === key || !animatedProps.has(prop)) {\n          animatedProps.set(prop, resolved);\n        }\n      });\n    });\n  }\n  _animateOptions(target, values) {\n    const newOptions = values.options;\n    const options = resolveTargetOptions(target, newOptions);\n    if (!options) {\n      return [];\n    }\n    const animations = this._createAnimations(options, newOptions);\n    if (newOptions.$shared) {\n      awaitAll(target.options.$animations, newOptions).then(() => {\n        target.options = newOptions;\n      }, () => {\n      });\n    }\n    return animations;\n  }\n  _createAnimations(target, values) {\n    const animatedProps = this._properties;\n    const animations = [];\n    const running = target.$animations || (target.$animations = {});\n    const props = Object.keys(values);\n    const date = Date.now();\n    let i;\n    for (i = props.length - 1; i >= 0; --i) {\n      const prop = props[i];\n      if (prop.charAt(0) === '$') {\n        continue;\n      }\n      if (prop === 'options') {\n        animations.push(...this._animateOptions(target, values));\n        continue;\n      }\n      const value = values[prop];\n      let animation = running[prop];\n      const cfg = animatedProps.get(prop);\n      if (animation) {\n        if (cfg && animation.active()) {\n          animation.update(cfg, value, date);\n          continue;\n        } else {\n          animation.cancel();\n        }\n      }\n      if (!cfg || !cfg.duration) {\n        target[prop] = value;\n        continue;\n      }\n      running[prop] = animation = new Animation(cfg, target, prop, value);\n      animations.push(animation);\n    }\n    return animations;\n  }\n  update(target, values) {\n    if (this._properties.size === 0) {\n      Object.assign(target, values);\n      return;\n    }\n    const animations = this._createAnimations(target, values);\n    if (animations.length) {\n      animator.add(this._chart, animations);\n      return true;\n    }\n  }\n}\nfunction awaitAll(animations, properties) {\n  const running = [];\n  const keys = Object.keys(properties);\n  for (let i = 0; i < keys.length; i++) {\n    const anim = animations[keys[i]];\n    if (anim && anim.active()) {\n      running.push(anim.wait());\n    }\n  }\n  return Promise.all(running);\n}\nfunction resolveTargetOptions(target, newOptions) {\n  if (!newOptions) {\n    return;\n  }\n  let options = target.options;\n  if (!options) {\n    target.options = newOptions;\n    return;\n  }\n  if (options.$shared) {\n    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\n  }\n  return options;\n}\n\nfunction scaleClip(scale, allowedOverflow) {\n  const opts = scale && scale.options || {};\n  const reverse = opts.reverse;\n  const min = opts.min === undefined ? allowedOverflow : 0;\n  const max = opts.max === undefined ? allowedOverflow : 0;\n  return {\n    start: reverse ? max : min,\n    end: reverse ? min : max\n  };\n}\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n  if (allowedOverflow === false) {\n    return false;\n  }\n  const x = scaleClip(xScale, allowedOverflow);\n  const y = scaleClip(yScale, allowedOverflow);\n  return {\n    top: y.end,\n    right: x.end,\n    bottom: y.start,\n    left: x.start\n  };\n}\nfunction toClip(value) {\n  let t, r, b, l;\n  if (isObject(value)) {\n    t = value.top;\n    r = value.right;\n    b = value.bottom;\n    l = value.left;\n  } else {\n    t = r = b = l = value;\n  }\n  return {\n    top: t,\n    right: r,\n    bottom: b,\n    left: l,\n    disabled: value === false\n  };\n}\nfunction getSortedDatasetIndices(chart, filterVisible) {\n  const keys = [];\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\n  let i, ilen;\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n    keys.push(metasets[i].index);\n  }\n  return keys;\n}\nfunction applyStack(stack, value, dsIndex, options = {}) {\n  const keys = stack.keys;\n  const singleMode = options.mode === 'single';\n  let i, ilen, datasetIndex, otherValue;\n  if (value === null) {\n    return;\n  }\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    datasetIndex = +keys[i];\n    if (datasetIndex === dsIndex) {\n      if (options.all) {\n        continue;\n      }\n      break;\n    }\n    otherValue = stack.values[datasetIndex];\n    if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {\n      value += otherValue;\n    }\n  }\n  return value;\n}\nfunction convertObjectDataToArray(data) {\n  const keys = Object.keys(data);\n  const adata = new Array(keys.length);\n  let i, ilen, key;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    key = keys[i];\n    adata[i] = {\n      x: key,\n      y: data[key]\n    };\n  }\n  return adata;\n}\nfunction isStacked(scale, meta) {\n  const stacked = scale && scale.options.stacked;\n  return stacked || (stacked === undefined && meta.stack !== undefined);\n}\nfunction getStackKey(indexScale, valueScale, meta) {\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\nfunction getUserBounds(scale) {\n  const {min, max, minDefined, maxDefined} = scale.getUserBounds();\n  return {\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\n  };\n}\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n  return subStack[indexValue] || (subStack[indexValue] = {});\n}\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {\n    const value = stack[meta.index];\n    if ((positive && value > 0) || (!positive && value < 0)) {\n      return meta.index;\n    }\n  }\n  return null;\n}\nfunction updateStacks(controller, parsed) {\n  const {chart, _cachedMeta: meta} = controller;\n  const stacks = chart._stacks || (chart._stacks = {});\n  const {iScale, vScale, index: datasetIndex} = meta;\n  const iAxis = iScale.axis;\n  const vAxis = vScale.axis;\n  const key = getStackKey(iScale, vScale, meta);\n  const ilen = parsed.length;\n  let stack;\n  for (let i = 0; i < ilen; ++i) {\n    const item = parsed[i];\n    const {[iAxis]: index, [vAxis]: value} = item;\n    const itemStacks = item._stacks || (item._stacks = {});\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n    stack[datasetIndex] = value;\n    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n  }\n}\nfunction getFirstScaleId(chart, axis) {\n  const scales = chart.scales;\n  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\n}\nfunction createDatasetContext(parent, index) {\n  return createContext(parent,\n    {\n      active: false,\n      dataset: undefined,\n      datasetIndex: index,\n      index,\n      mode: 'default',\n      type: 'dataset'\n    }\n  );\n}\nfunction createDataContext(parent, index, element) {\n  return createContext(parent, {\n    active: false,\n    dataIndex: index,\n    parsed: undefined,\n    raw: undefined,\n    element,\n    index,\n    mode: 'default',\n    type: 'data'\n  });\n}\nfunction clearStacks(meta, items) {\n  const datasetIndex = meta.controller.index;\n  const axis = meta.vScale && meta.vScale.axis;\n  if (!axis) {\n    return;\n  }\n  items = items || meta._parsed;\n  for (const parsed of items) {\n    const stacks = parsed._stacks;\n    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n      return;\n    }\n    delete stacks[axis][datasetIndex];\n  }\n}\nconst isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked\n  && {keys: getSortedDatasetIndices(chart, true), values: null};\nclass DatasetController {\n  constructor(chart, datasetIndex) {\n    this.chart = chart;\n    this._ctx = chart.ctx;\n    this.index = datasetIndex;\n    this._cachedDataOpts = {};\n    this._cachedMeta = this.getMeta();\n    this._type = this._cachedMeta.type;\n    this.options = undefined;\n    this._parsing = false;\n    this._data = undefined;\n    this._objectData = undefined;\n    this._sharedOptions = undefined;\n    this._drawStart = undefined;\n    this._drawCount = undefined;\n    this.enableOptionSharing = false;\n    this.supportsDecimation = false;\n    this.$context = undefined;\n    this._syncList = [];\n    this.initialize();\n  }\n  initialize() {\n    const meta = this._cachedMeta;\n    this.configure();\n    this.linkScales();\n    meta._stacked = isStacked(meta.vScale, meta);\n    this.addElements();\n  }\n  updateIndex(datasetIndex) {\n    if (this.index !== datasetIndex) {\n      clearStacks(this._cachedMeta);\n    }\n    this.index = datasetIndex;\n  }\n  linkScales() {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\n    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n    const indexAxis = meta.indexAxis;\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n    meta.xScale = this.getScaleForId(xid);\n    meta.yScale = this.getScaleForId(yid);\n    meta.rScale = this.getScaleForId(rid);\n    meta.iScale = this.getScaleForId(iid);\n    meta.vScale = this.getScaleForId(vid);\n  }\n  getDataset() {\n    return this.chart.data.datasets[this.index];\n  }\n  getMeta() {\n    return this.chart.getDatasetMeta(this.index);\n  }\n  getScaleForId(scaleID) {\n    return this.chart.scales[scaleID];\n  }\n  _getOtherScale(scale) {\n    const meta = this._cachedMeta;\n    return scale === meta.iScale\n      ? meta.vScale\n      : meta.iScale;\n  }\n  reset() {\n    this._update('reset');\n  }\n  _destroy() {\n    const meta = this._cachedMeta;\n    if (this._data) {\n      unlistenArrayEvents(this._data, this);\n    }\n    if (meta._stacked) {\n      clearStacks(meta);\n    }\n  }\n  _dataCheck() {\n    const dataset = this.getDataset();\n    const data = dataset.data || (dataset.data = []);\n    const _data = this._data;\n    if (isObject(data)) {\n      this._data = convertObjectDataToArray(data);\n    } else if (_data !== data) {\n      if (_data) {\n        unlistenArrayEvents(_data, this);\n        const meta = this._cachedMeta;\n        clearStacks(meta);\n        meta._parsed = [];\n      }\n      if (data && Object.isExtensible(data)) {\n        listenArrayEvents(data, this);\n      }\n      this._syncList = [];\n      this._data = data;\n    }\n  }\n  addElements() {\n    const meta = this._cachedMeta;\n    this._dataCheck();\n    if (this.datasetElementType) {\n      meta.dataset = new this.datasetElementType();\n    }\n  }\n  buildOrUpdateElements(resetNewElements) {\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    let stackChanged = false;\n    this._dataCheck();\n    const oldStacked = meta._stacked;\n    meta._stacked = isStacked(meta.vScale, meta);\n    if (meta.stack !== dataset.stack) {\n      stackChanged = true;\n      clearStacks(meta);\n      meta.stack = dataset.stack;\n    }\n    this._resyncElements(resetNewElements);\n    if (stackChanged || oldStacked !== meta._stacked) {\n      updateStacks(this, meta._parsed);\n    }\n  }\n  configure() {\n    const config = this.chart.config;\n    const scopeKeys = config.datasetScopeKeys(this._type);\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n    this.options = config.createResolver(scopes, this.getContext());\n    this._parsing = this.options.parsing;\n    this._cachedDataOpts = {};\n  }\n  parse(start, count) {\n    const {_cachedMeta: meta, _data: data} = this;\n    const {iScale, _stacked} = meta;\n    const iAxis = iScale.axis;\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\n    let prev = start > 0 && meta._parsed[start - 1];\n    let i, cur, parsed;\n    if (this._parsing === false) {\n      meta._parsed = data;\n      meta._sorted = true;\n      parsed = data;\n    } else {\n      if (isArray(data[start])) {\n        parsed = this.parseArrayData(meta, data, start, count);\n      } else if (isObject(data[start])) {\n        parsed = this.parseObjectData(meta, data, start, count);\n      } else {\n        parsed = this.parsePrimitiveData(meta, data, start, count);\n      }\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\n      for (i = 0; i < count; ++i) {\n        meta._parsed[i + start] = cur = parsed[i];\n        if (sorted) {\n          if (isNotInOrderComparedToPrev()) {\n            sorted = false;\n          }\n          prev = cur;\n        }\n      }\n      meta._sorted = sorted;\n    }\n    if (_stacked) {\n      updateStacks(this, parsed);\n    }\n  }\n  parsePrimitiveData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = new Array(count);\n    let i, ilen, index;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      parsed[i] = {\n        [iAxis]: singleScale || iScale.parse(labels[index], index),\n        [vAxis]: vScale.parse(data[index], index)\n      };\n    }\n    return parsed;\n  }\n  parseArrayData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(item[0], index),\n        y: yScale.parse(item[1], index)\n      };\n    }\n    return parsed;\n  }\n  parseObjectData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n      };\n    }\n    return parsed;\n  }\n  getParsed(index) {\n    return this._cachedMeta._parsed[index];\n  }\n  getDataElement(index) {\n    return this._cachedMeta.data[index];\n  }\n  applyStack(scale, parsed, mode) {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const value = parsed[scale.axis];\n    const stack = {\n      keys: getSortedDatasetIndices(chart, true),\n      values: parsed._stacks[scale.axis]\n    };\n    return applyStack(stack, value, meta.index, {mode});\n  }\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    const parsedValue = parsed[scale.axis];\n    let value = parsedValue === null ? NaN : parsedValue;\n    const values = stack && parsed._stacks[scale.axis];\n    if (stack && values) {\n      stack.values = values;\n      value = applyStack(stack, parsedValue, this._cachedMeta.index);\n    }\n    range.min = Math.min(range.min, value);\n    range.max = Math.max(range.max, value);\n  }\n  getMinMax(scale, canStack) {\n    const meta = this._cachedMeta;\n    const _parsed = meta._parsed;\n    const sorted = meta._sorted && scale === meta.iScale;\n    const ilen = _parsed.length;\n    const otherScale = this._getOtherScale(scale);\n    const stack = createStack(canStack, meta, this.chart);\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\n    let i, parsed;\n    function _skip() {\n      parsed = _parsed[i];\n      const otherValue = parsed[otherScale.axis];\n      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n    }\n    for (i = 0; i < ilen; ++i) {\n      if (_skip()) {\n        continue;\n      }\n      this.updateRangeFromParsed(range, scale, parsed, stack);\n      if (sorted) {\n        break;\n      }\n    }\n    if (sorted) {\n      for (i = ilen - 1; i >= 0; --i) {\n        if (_skip()) {\n          continue;\n        }\n        this.updateRangeFromParsed(range, scale, parsed, stack);\n        break;\n      }\n    }\n    return range;\n  }\n  getAllParsedValues(scale) {\n    const parsed = this._cachedMeta._parsed;\n    const values = [];\n    let i, ilen, value;\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\n      value = parsed[i][scale.axis];\n      if (isNumberFinite(value)) {\n        values.push(value);\n      }\n    }\n    return values;\n  }\n  getMaxOverflow() {\n    return false;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n    };\n  }\n  _update(mode) {\n    const meta = this._cachedMeta;\n    this.update(mode || 'default');\n    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n  }\n  update(mode) {}\n  draw() {\n    const ctx = this._ctx;\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const elements = meta.data || [];\n    const area = chart.chartArea;\n    const active = [];\n    const start = this._drawStart || 0;\n    const count = this._drawCount || (elements.length - start);\n    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n    let i;\n    if (meta.dataset) {\n      meta.dataset.draw(ctx, area, start, count);\n    }\n    for (i = start; i < start + count; ++i) {\n      const element = elements[i];\n      if (element.hidden) {\n        continue;\n      }\n      if (element.active && drawActiveElementsOnTop) {\n        active.push(element);\n      } else {\n        element.draw(ctx, area);\n      }\n    }\n    for (i = 0; i < active.length; ++i) {\n      active[i].draw(ctx, area);\n    }\n  }\n  getStyle(index, active) {\n    const mode = active ? 'active' : 'default';\n    return index === undefined && this._cachedMeta.dataset\n      ? this.resolveDatasetElementOptions(mode)\n      : this.resolveDataElementOptions(index || 0, mode);\n  }\n  getContext(index, active, mode) {\n    const dataset = this.getDataset();\n    let context;\n    if (index >= 0 && index < this._cachedMeta.data.length) {\n      const element = this._cachedMeta.data[index];\n      context = element.$context ||\n        (element.$context = createDataContext(this.getContext(), index, element));\n      context.parsed = this.getParsed(index);\n      context.raw = dataset.data[index];\n      context.index = context.dataIndex = index;\n    } else {\n      context = this.$context ||\n        (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n      context.dataset = dataset;\n      context.index = context.datasetIndex = this.index;\n    }\n    context.active = !!active;\n    context.mode = mode;\n    return context;\n  }\n  resolveDatasetElementOptions(mode) {\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\n  }\n  resolveDataElementOptions(index, mode) {\n    return this._resolveElementOptions(this.dataElementType.id, mode, index);\n  }\n  _resolveElementOptions(elementType, mode = 'default', index) {\n    const active = mode === 'active';\n    const cache = this._cachedDataOpts;\n    const cacheKey = elementType + '-' + mode;\n    const cached = cache[cacheKey];\n    const sharing = this.enableOptionSharing && defined(index);\n    if (cached) {\n      return cloneIfNotShared(cached, sharing);\n    }\n    const config = this.chart.config;\n    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n    const names = Object.keys(defaults.elements[elementType]);\n    const context = () => this.getContext(index, active);\n    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n    if (values.$shared) {\n      values.$shared = sharing;\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n    }\n    return values;\n  }\n  _resolveAnimations(index, transition, active) {\n    const chart = this.chart;\n    const cache = this._cachedDataOpts;\n    const cacheKey = `animation-${transition}`;\n    const cached = cache[cacheKey];\n    if (cached) {\n      return cached;\n    }\n    let options;\n    if (chart.options.animation !== false) {\n      const config = this.chart.config;\n      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n      options = config.createResolver(scopes, this.getContext(index, active, transition));\n    }\n    const animations = new Animations(chart, options && options.animations);\n    if (options && options._cacheable) {\n      cache[cacheKey] = Object.freeze(animations);\n    }\n    return animations;\n  }\n  getSharedOptions(options) {\n    if (!options.$shared) {\n      return;\n    }\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n  }\n  includeOptions(mode, sharedOptions) {\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n  }\n  _getSharedOptions(start, mode) {\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const previouslySharedOptions = this._sharedOptions;\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions) || (sharedOptions !== previouslySharedOptions);\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    return {sharedOptions, includeOptions};\n  }\n  updateElement(element, index, properties, mode) {\n    if (isDirectUpdateMode(mode)) {\n      Object.assign(element, properties);\n    } else {\n      this._resolveAnimations(index, mode).update(element, properties);\n    }\n  }\n  updateSharedOptions(sharedOptions, mode, newOptions) {\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\n      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n    }\n  }\n  _setStyle(element, index, mode, active) {\n    element.active = active;\n    const options = this.getStyle(index, active);\n    this._resolveAnimations(index, mode, active).update(element, {\n      options: (!active && this.getSharedOptions(options)) || options\n    });\n  }\n  removeHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', false);\n  }\n  setHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', true);\n  }\n  _removeDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n    if (element) {\n      this._setStyle(element, undefined, 'active', false);\n    }\n  }\n  _setDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n    if (element) {\n      this._setStyle(element, undefined, 'active', true);\n    }\n  }\n  _resyncElements(resetNewElements) {\n    const data = this._data;\n    const elements = this._cachedMeta.data;\n    for (const [method, arg1, arg2] of this._syncList) {\n      this[method](arg1, arg2);\n    }\n    this._syncList = [];\n    const numMeta = elements.length;\n    const numData = data.length;\n    const count = Math.min(numData, numMeta);\n    if (count) {\n      this.parse(0, count);\n    }\n    if (numData > numMeta) {\n      this._insertElements(numMeta, numData - numMeta, resetNewElements);\n    } else if (numData < numMeta) {\n      this._removeElements(numData, numMeta - numData);\n    }\n  }\n  _insertElements(start, count, resetNewElements = true) {\n    const meta = this._cachedMeta;\n    const data = meta.data;\n    const end = start + count;\n    let i;\n    const move = (arr) => {\n      arr.length += count;\n      for (i = arr.length - 1; i >= end; i--) {\n        arr[i] = arr[i - count];\n      }\n    };\n    move(data);\n    for (i = start; i < end; ++i) {\n      data[i] = new this.dataElementType();\n    }\n    if (this._parsing) {\n      move(meta._parsed);\n    }\n    this.parse(start, count);\n    if (resetNewElements) {\n      this.updateElements(data, start, count, 'reset');\n    }\n  }\n  updateElements(element, start, count, mode) {}\n  _removeElements(start, count) {\n    const meta = this._cachedMeta;\n    if (this._parsing) {\n      const removed = meta._parsed.splice(start, count);\n      if (meta._stacked) {\n        clearStacks(meta, removed);\n      }\n    }\n    meta.data.splice(start, count);\n  }\n  _sync(args) {\n    if (this._parsing) {\n      this._syncList.push(args);\n    } else {\n      const [method, arg1, arg2] = args;\n      this[method](arg1, arg2);\n    }\n    this.chart._dataChanges.push([this.index, ...args]);\n  }\n  _onDataPush() {\n    const count = arguments.length;\n    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\n  }\n  _onDataPop() {\n    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\n  }\n  _onDataShift() {\n    this._sync(['_removeElements', 0, 1]);\n  }\n  _onDataSplice(start, count) {\n    if (count) {\n      this._sync(['_removeElements', start, count]);\n    }\n    const newCount = arguments.length - 2;\n    if (newCount) {\n      this._sync(['_insertElements', start, newCount]);\n    }\n  }\n  _onDataUnshift() {\n    this._sync(['_insertElements', 0, arguments.length]);\n  }\n}\nDatasetController.defaults = {};\nDatasetController.prototype.datasetElementType = null;\nDatasetController.prototype.dataElementType = null;\n\nfunction getAllScaleValues(scale, type) {\n  if (!scale._cache.$bar) {\n    const visibleMetas = scale.getMatchingVisibleMetas(type);\n    let values = [];\n    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {\n      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n    }\n    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\n  }\n  return scale._cache.$bar;\n}\nfunction computeMinSampleSize(meta) {\n  const scale = meta.iScale;\n  const values = getAllScaleValues(scale, meta.type);\n  let min = scale._length;\n  let i, ilen, curr, prev;\n  const updateMinAndPrev = () => {\n    if (curr === 32767 || curr === -32768) {\n      return;\n    }\n    if (defined(prev)) {\n      min = Math.min(min, Math.abs(curr - prev) || min);\n    }\n    prev = curr;\n  };\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\n    curr = scale.getPixelForValue(values[i]);\n    updateMinAndPrev();\n  }\n  prev = undefined;\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\n    curr = scale.getPixelForTick(i);\n    updateMinAndPrev();\n  }\n  return min;\n}\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n  const thickness = options.barThickness;\n  let size, ratio;\n  if (isNullOrUndef(thickness)) {\n    size = ruler.min * options.categoryPercentage;\n    ratio = options.barPercentage;\n  } else {\n    size = thickness * stackCount;\n    ratio = 1;\n  }\n  return {\n    chunk: size / stackCount,\n    ratio,\n    start: ruler.pixels[index] - (size / 2)\n  };\n}\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n  const pixels = ruler.pixels;\n  const curr = pixels[index];\n  let prev = index > 0 ? pixels[index - 1] : null;\n  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n  const percent = options.categoryPercentage;\n  if (prev === null) {\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n  }\n  if (next === null) {\n    next = curr + curr - prev;\n  }\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n  const size = Math.abs(next - prev) / 2 * percent;\n  return {\n    chunk: size / stackCount,\n    ratio: options.barPercentage,\n    start\n  };\n}\nfunction parseFloatBar(entry, item, vScale, i) {\n  const startValue = vScale.parse(entry[0], i);\n  const endValue = vScale.parse(entry[1], i);\n  const min = Math.min(startValue, endValue);\n  const max = Math.max(startValue, endValue);\n  let barStart = min;\n  let barEnd = max;\n  if (Math.abs(min) > Math.abs(max)) {\n    barStart = max;\n    barEnd = min;\n  }\n  item[vScale.axis] = barEnd;\n  item._custom = {\n    barStart,\n    barEnd,\n    start: startValue,\n    end: endValue,\n    min,\n    max\n  };\n}\nfunction parseValue(entry, item, vScale, i) {\n  if (isArray(entry)) {\n    parseFloatBar(entry, item, vScale, i);\n  } else {\n    item[vScale.axis] = vScale.parse(entry, i);\n  }\n  return item;\n}\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n  const iScale = meta.iScale;\n  const vScale = meta.vScale;\n  const labels = iScale.getLabels();\n  const singleScale = iScale === vScale;\n  const parsed = [];\n  let i, ilen, item, entry;\n  for (i = start, ilen = start + count; i < ilen; ++i) {\n    entry = data[i];\n    item = {};\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n    parsed.push(parseValue(entry, item, vScale, i));\n  }\n  return parsed;\n}\nfunction isFloatBar(custom) {\n  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\nfunction barSign(size, vScale, actualBase) {\n  if (size !== 0) {\n    return sign(size);\n  }\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\nfunction borderProps(properties) {\n  let reverse, start, end, top, bottom;\n  if (properties.horizontal) {\n    reverse = properties.base > properties.x;\n    start = 'left';\n    end = 'right';\n  } else {\n    reverse = properties.base < properties.y;\n    start = 'bottom';\n    end = 'top';\n  }\n  if (reverse) {\n    top = 'end';\n    bottom = 'start';\n  } else {\n    top = 'start';\n    bottom = 'end';\n  }\n  return {start, end, reverse, top, bottom};\n}\nfunction setBorderSkipped(properties, options, stack, index) {\n  let edge = options.borderSkipped;\n  const res = {};\n  if (!edge) {\n    properties.borderSkipped = res;\n    return;\n  }\n  if (edge === true) {\n    properties.borderSkipped = {top: true, right: true, bottom: true, left: true};\n    return;\n  }\n  const {start, end, reverse, top, bottom} = borderProps(properties);\n  if (edge === 'middle' && stack) {\n    properties.enableBorderRadius = true;\n    if ((stack._top || 0) === index) {\n      edge = top;\n    } else if ((stack._bottom || 0) === index) {\n      edge = bottom;\n    } else {\n      res[parseEdge(bottom, start, end, reverse)] = true;\n      edge = top;\n    }\n  }\n  res[parseEdge(edge, start, end, reverse)] = true;\n  properties.borderSkipped = res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n  if (reverse) {\n    edge = swap(edge, a, b);\n    edge = startEnd(edge, b, a);\n  } else {\n    edge = startEnd(edge, a, b);\n  }\n  return edge;\n}\nfunction swap(orig, v1, v2) {\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n  return v === 'start' ? start : v === 'end' ? end : v;\n}\nfunction setInflateAmount(properties, {inflateAmount}, ratio) {\n  properties.inflateAmount = inflateAmount === 'auto'\n    ? ratio === 1 ? 0.33 : 0\n    : inflateAmount;\n}\nclass BarController extends DatasetController {\n  parsePrimitiveData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n  parseArrayData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n  parseObjectData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const parsed = [];\n    let i, ilen, item, obj;\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      obj = data[i];\n      item = {};\n      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n    }\n    return parsed;\n  }\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    super.updateRangeFromParsed(range, scale, parsed, stack);\n    const custom = parsed._custom;\n    if (custom && scale === this._cachedMeta.vScale) {\n      range.min = Math.min(range.min, custom.min);\n      range.max = Math.max(range.max, custom.max);\n    }\n  }\n  getMaxOverflow() {\n    return 0;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {iScale, vScale} = meta;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const value = isFloatBar(custom)\n      ? '[' + custom.start + ', ' + custom.end + ']'\n      : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n    return {\n      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n      value\n    };\n  }\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n    const meta = this._cachedMeta;\n    meta.stack = this.getDataset().stack;\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    this.updateElements(meta.data, 0, meta.data.length, mode);\n  }\n  updateElements(bars, start, count, mode) {\n    const reset = mode === 'reset';\n    const {index, _cachedMeta: {vScale}} = this;\n    const base = vScale.getBasePixel();\n    const horizontal = vScale.isHorizontal();\n    const ruler = this._getRuler();\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    for (let i = start; i < start + count; i++) {\n      const parsed = this.getParsed(i);\n      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);\n      const ipixels = this._calculateBarIndexPixels(i, ruler);\n      const stack = (parsed._stacks || {})[vScale.axis];\n      const properties = {\n        horizontal,\n        base: vpixels.base,\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),\n        x: horizontal ? vpixels.head : ipixels.center,\n        y: horizontal ? ipixels.center : vpixels.head,\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n      }\n      const options = properties.options || bars[i].options;\n      setBorderSkipped(properties, options, stack, index);\n      setInflateAmount(properties, options, ruler.ratio);\n      this.updateElement(bars[i], i, properties, mode);\n    }\n  }\n  _getStacks(last, dataIndex) {\n    const {iScale} = this._cachedMeta;\n    const metasets = iScale.getMatchingVisibleMetas(this._type)\n      .filter(meta => meta.controller.options.grouped);\n    const stacked = iScale.options.stacked;\n    const stacks = [];\n    const skipNull = (meta) => {\n      const parsed = meta.controller.getParsed(dataIndex);\n      const val = parsed && parsed[meta.vScale.axis];\n      if (isNullOrUndef(val) || isNaN(val)) {\n        return true;\n      }\n    };\n    for (const meta of metasets) {\n      if (dataIndex !== undefined && skipNull(meta)) {\n        continue;\n      }\n      if (stacked === false || stacks.indexOf(meta.stack) === -1 ||\n\t\t\t\t(stacked === undefined && meta.stack === undefined)) {\n        stacks.push(meta.stack);\n      }\n      if (meta.index === last) {\n        break;\n      }\n    }\n    if (!stacks.length) {\n      stacks.push(undefined);\n    }\n    return stacks;\n  }\n  _getStackCount(index) {\n    return this._getStacks(undefined, index).length;\n  }\n  _getStackIndex(datasetIndex, name, dataIndex) {\n    const stacks = this._getStacks(datasetIndex, dataIndex);\n    const index = (name !== undefined)\n      ? stacks.indexOf(name)\n      : -1;\n    return (index === -1)\n      ? stacks.length - 1\n      : index;\n  }\n  _getRuler() {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const pixels = [];\n    let i, ilen;\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\n      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n    }\n    const barThickness = opts.barThickness;\n    const min = barThickness || computeMinSampleSize(meta);\n    return {\n      min,\n      pixels,\n      start: iScale._startPixel,\n      end: iScale._endPixel,\n      stackCount: this._getStackCount(),\n      scale: iScale,\n      grouped: opts.grouped,\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n    };\n  }\n  _calculateBarValuePixels(index) {\n    const {_cachedMeta: {vScale, _stacked}, options: {base: baseValue, minBarLength}} = this;\n    const actualBase = baseValue || 0;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const floating = isFloatBar(custom);\n    let value = parsed[vScale.axis];\n    let start = 0;\n    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n    let head, size;\n    if (length !== value) {\n      start = length - value;\n      length = value;\n    }\n    if (floating) {\n      value = custom.barStart;\n      length = custom.barEnd - custom.barStart;\n      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n        start = 0;\n      }\n      start += value;\n    }\n    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n    let base = vScale.getPixelForValue(startValue);\n    if (this.chart.getDataVisibility(index)) {\n      head = vScale.getPixelForValue(start + length);\n    } else {\n      head = base;\n    }\n    size = head - base;\n    if (Math.abs(size) < minBarLength) {\n      size = barSign(size, vScale, actualBase) * minBarLength;\n      if (value === actualBase) {\n        base -= size / 2;\n      }\n      const startPixel = vScale.getPixelForDecimal(0);\n      const endPixel = vScale.getPixelForDecimal(1);\n      const min = Math.min(startPixel, endPixel);\n      const max = Math.max(startPixel, endPixel);\n      base = Math.max(Math.min(base, max), min);\n      head = base + size;\n    }\n    if (base === vScale.getPixelForValue(actualBase)) {\n      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n      base += halfGrid;\n      size -= halfGrid;\n    }\n    return {\n      size,\n      base,\n      head,\n      center: head + size / 2\n    };\n  }\n  _calculateBarIndexPixels(index, ruler) {\n    const scale = ruler.scale;\n    const options = this.options;\n    const skipNull = options.skipNull;\n    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n    let center, size;\n    if (ruler.grouped) {\n      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n      const range = options.barThickness === 'flex'\n        ? computeFlexCategoryTraits(index, ruler, options, stackCount)\n        : computeFitCategoryTraits(index, ruler, options, stackCount);\n      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\n      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\n    } else {\n      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n    }\n    return {\n      base: center - size / 2,\n      head: center + size / 2,\n      center,\n      size\n    };\n  }\n  draw() {\n    const meta = this._cachedMeta;\n    const vScale = meta.vScale;\n    const rects = meta.data;\n    const ilen = rects.length;\n    let i = 0;\n    for (; i < ilen; ++i) {\n      if (this.getParsed(i)[vScale.axis] !== null) {\n        rects[i].draw(this._ctx);\n      }\n    }\n  }\n}\nBarController.id = 'bar';\nBarController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'bar',\n  categoryPercentage: 0.8,\n  barPercentage: 0.9,\n  grouped: true,\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'base', 'width', 'height']\n    }\n  }\n};\nBarController.overrides = {\n  scales: {\n    _index_: {\n      type: 'category',\n      offset: true,\n      grid: {\n        offset: true\n      }\n    },\n    _value_: {\n      type: 'linear',\n      beginAtZero: true,\n    }\n  }\n};\n\nclass BubbleController extends DatasetController {\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n  parsePrimitiveData(meta, data, start, count) {\n    const parsed = super.parsePrimitiveData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n    }\n    return parsed;\n  }\n  parseArrayData(meta, data, start, count) {\n    const parsed = super.parseArrayData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n  parseObjectData(meta, data, start, count) {\n    const parsed = super.parseObjectData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n  getMaxOverflow() {\n    const data = this._cachedMeta.data;\n    let max = 0;\n    for (let i = data.length - 1; i >= 0; --i) {\n      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n    }\n    return max > 0 && max;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n    const r = parsed._custom;\n    return {\n      label: meta.label,\n      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n    };\n  }\n  update(mode) {\n    const points = this._cachedMeta.data;\n    this.updateElements(points, 0, points.length, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const parsed = !reset && this.getParsed(i);\n      const properties = {};\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n        if (reset) {\n          properties.options.radius = 0;\n        }\n      }\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n  resolveDataElementOptions(index, mode) {\n    const parsed = this.getParsed(index);\n    let values = super.resolveDataElementOptions(index, mode);\n    if (values.$shared) {\n      values = Object.assign({}, values, {$shared: false});\n    }\n    const radius = values.radius;\n    if (mode !== 'active') {\n      values.radius = 0;\n    }\n    values.radius += valueOrDefault(parsed && parsed._custom, radius);\n    return values;\n  }\n}\nBubbleController.id = 'bubble';\nBubbleController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'point',\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'borderWidth', 'radius']\n    }\n  }\n};\nBubbleController.overrides = {\n  scales: {\n    x: {\n      type: 'linear'\n    },\n    y: {\n      type: 'linear'\n    }\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        }\n      }\n    }\n  }\n};\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n  let ratioX = 1;\n  let ratioY = 1;\n  let offsetX = 0;\n  let offsetY = 0;\n  if (circumference < TAU) {\n    const startAngle = rotation;\n    const endAngle = startAngle + circumference;\n    const startX = Math.cos(startAngle);\n    const startY = Math.sin(startAngle);\n    const endX = Math.cos(endAngle);\n    const endY = Math.sin(endAngle);\n    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n    const maxX = calcMax(0, startX, endX);\n    const maxY = calcMax(HALF_PI, startY, endY);\n    const minX = calcMin(PI, startX, endX);\n    const minY = calcMin(PI + HALF_PI, startY, endY);\n    ratioX = (maxX - minX) / 2;\n    ratioY = (maxY - minY) / 2;\n    offsetX = -(maxX + minX) / 2;\n    offsetY = -(maxY + minY) / 2;\n  }\n  return {ratioX, ratioY, offsetX, offsetY};\n}\nclass DoughnutController extends DatasetController {\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n    this.enableOptionSharing = true;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.offsetX = undefined;\n    this.offsetY = undefined;\n  }\n  linkScales() {}\n  parse(start, count) {\n    const data = this.getDataset().data;\n    const meta = this._cachedMeta;\n    if (this._parsing === false) {\n      meta._parsed = data;\n    } else {\n      let getter = (i) => +data[i];\n      if (isObject(data[start])) {\n        const {key = 'value'} = this._parsing;\n        getter = (i) => +resolveObjectKey(data[i], key);\n      }\n      let i, ilen;\n      for (i = start, ilen = start + count; i < ilen; ++i) {\n        meta._parsed[i] = getter(i);\n      }\n    }\n  }\n  _getRotation() {\n    return toRadians(this.options.rotation - 90);\n  }\n  _getCircumference() {\n    return toRadians(this.options.circumference);\n  }\n  _getRotationExtents() {\n    let min = TAU;\n    let max = -TAU;\n    for (let i = 0; i < this.chart.data.datasets.length; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        const controller = this.chart.getDatasetMeta(i).controller;\n        const rotation = controller._getRotation();\n        const circumference = controller._getCircumference();\n        min = Math.min(min, rotation);\n        max = Math.max(max, rotation + circumference);\n      }\n    }\n    return {\n      rotation: min,\n      circumference: max - min,\n    };\n  }\n  update(mode) {\n    const chart = this.chart;\n    const {chartArea} = chart;\n    const meta = this._cachedMeta;\n    const arcs = meta.data;\n    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\n    const chartWeight = this._getRingWeight(this.index);\n    const {circumference, rotation} = this._getRotationExtents();\n    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\n    const maxWidth = (chartArea.width - spacing) / ratioX;\n    const maxHeight = (chartArea.height - spacing) / ratioY;\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n    const outerRadius = toDimension(this.options.radius, maxRadius);\n    const innerRadius = Math.max(outerRadius * cutout, 0);\n    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n    this.offsetX = offsetX * outerRadius;\n    this.offsetY = offsetY * outerRadius;\n    meta.total = this.calculateTotal();\n    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n  _circumference(i, reset) {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const circumference = this._getCircumference();\n    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n      return 0;\n    }\n    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\n  }\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const centerX = (chartArea.left + chartArea.right) / 2;\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\n    const animateScale = reset && animationOpts.animateScale;\n    const innerRadius = animateScale ? 0 : this.innerRadius;\n    const outerRadius = animateScale ? 0 : this.outerRadius;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    let startAngle = this._getRotation();\n    let i;\n    for (i = 0; i < start; ++i) {\n      startAngle += this._circumference(i, reset);\n    }\n    for (i = start; i < start + count; ++i) {\n      const circumference = this._circumference(i, reset);\n      const arc = arcs[i];\n      const properties = {\n        x: centerX + this.offsetX,\n        y: centerY + this.offsetY,\n        startAngle,\n        endAngle: startAngle + circumference,\n        circumference,\n        outerRadius,\n        innerRadius\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n      }\n      startAngle += circumference;\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n  calculateTotal() {\n    const meta = this._cachedMeta;\n    const metaData = meta.data;\n    let total = 0;\n    let i;\n    for (i = 0; i < metaData.length; i++) {\n      const value = meta._parsed[i];\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n        total += Math.abs(value);\n      }\n    }\n    return total;\n  }\n  calculateCircumference(value) {\n    const total = this._cachedMeta.total;\n    if (total > 0 && !isNaN(value)) {\n      return TAU * (Math.abs(value) / total);\n    }\n    return 0;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index], chart.options.locale);\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n  getMaxBorderWidth(arcs) {\n    let max = 0;\n    const chart = this.chart;\n    let i, ilen, meta, controller, options;\n    if (!arcs) {\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          meta = chart.getDatasetMeta(i);\n          arcs = meta.data;\n          controller = meta.controller;\n          break;\n        }\n      }\n    }\n    if (!arcs) {\n      return 0;\n    }\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n      options = controller.resolveDataElementOptions(i);\n      if (options.borderAlign !== 'inner') {\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n      }\n    }\n    return max;\n  }\n  getMaxOffset(arcs) {\n    let max = 0;\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\n      const options = this.resolveDataElementOptions(i);\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n    }\n    return max;\n  }\n  _getRingWeightOffset(datasetIndex) {\n    let ringWeightOffset = 0;\n    for (let i = 0; i < datasetIndex; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        ringWeightOffset += this._getRingWeight(i);\n      }\n    }\n    return ringWeightOffset;\n  }\n  _getRingWeight(datasetIndex) {\n    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n  }\n  _getVisibleDatasetWeightTotal() {\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n  }\n}\nDoughnutController.id = 'doughnut';\nDoughnutController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'arc',\n  animation: {\n    animateRotate: true,\n    animateScale: false\n  },\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\n    },\n  },\n  cutout: '50%',\n  rotation: 0,\n  circumference: 360,\n  radius: '100%',\n  spacing: 0,\n  indexAxis: 'r',\n};\nDoughnutController.descriptors = {\n  _scriptable: (name) => name !== 'spacing',\n  _indexable: (name) => name !== 'spacing',\n};\nDoughnutController.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels(chart) {\n          const data = chart.data;\n          if (data.labels.length && data.datasets.length) {\n            const {labels: {pointStyle}} = chart.legend.options;\n            return data.labels.map((label, i) => {\n              const meta = chart.getDatasetMeta(0);\n              const style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                pointStyle: pointStyle,\n                hidden: !chart.getDataVisibility(i),\n                index: i\n              };\n            });\n          }\n          return [];\n        }\n      },\n      onClick(e, legendItem, legend) {\n        legend.chart.toggleDataVisibility(legendItem.index);\n        legend.chart.update();\n      }\n    },\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(tooltipItem) {\n          let dataLabel = tooltipItem.label;\n          const value = ': ' + tooltipItem.formattedValue;\n          if (isArray(dataLabel)) {\n            dataLabel = dataLabel.slice();\n            dataLabel[0] += value;\n          } else {\n            dataLabel += value;\n          }\n          return dataLabel;\n        }\n      }\n    }\n  }\n};\n\nclass LineController extends DatasetController {\n  initialize() {\n    this.enableOptionSharing = true;\n    this.supportsDecimation = true;\n    super.initialize();\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {dataset: line, data: points = [], _dataset} = meta;\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n    this._drawStart = start;\n    this._drawCount = count;\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n    line._chart = this.chart;\n    line._datasetIndex = this.index;\n    line._decimated = !!_dataset._decimated;\n    line.points = points;\n    const options = this.resolveDatasetElementOptions(mode);\n    if (!this.options.showLine) {\n      options.borderWidth = 0;\n    }\n    options.segment = this.options.segment;\n    this.updateElement(line, undefined, {\n      animated: !animationsDisabled,\n      options\n    }, mode);\n    this.updateElements(points, start, count, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n      prevParsed = parsed;\n    }\n  }\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    const data = meta.data || [];\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n  draw() {\n    const meta = this._cachedMeta;\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n    super.draw();\n  }\n}\nLineController.id = 'line';\nLineController.defaults = {\n  datasetElementType: 'line',\n  dataElementType: 'point',\n  showLine: true,\n  spanGaps: false,\n};\nLineController.overrides = {\n  scales: {\n    _index_: {\n      type: 'category',\n    },\n    _value_: {\n      type: 'linear',\n    },\n  }\n};\n\nclass PolarAreaController extends DatasetController {\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n  update(mode) {\n    const arcs = this._cachedMeta.data;\n    this._updateRadius();\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n  getMinMax() {\n    const meta = this._cachedMeta;\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n    meta.data.forEach((element, index) => {\n      const parsed = this.getParsed(index).r;\n      if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n        if (parsed < range.min) {\n          range.min = parsed;\n        }\n        if (parsed > range.max) {\n          range.max = parsed;\n        }\n      }\n    });\n    return range;\n  }\n  _updateRadius() {\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n    const outerRadius = Math.max(minSize / 2, 0);\n    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n    this.outerRadius = outerRadius - (radiusLength * this.index);\n    this.innerRadius = this.outerRadius - radiusLength;\n  }\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const scale = this._cachedMeta.rScale;\n    const centerX = scale.xCenter;\n    const centerY = scale.yCenter;\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n    let angle = datasetStartAngle;\n    let i;\n    const defaultAngle = 360 / this.countVisibleElements();\n    for (i = 0; i < start; ++i) {\n      angle += this._computeAngle(i, mode, defaultAngle);\n    }\n    for (i = start; i < start + count; i++) {\n      const arc = arcs[i];\n      let startAngle = angle;\n      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n      angle = endAngle;\n      if (reset) {\n        if (animationOpts.animateScale) {\n          outerRadius = 0;\n        }\n        if (animationOpts.animateRotate) {\n          startAngle = endAngle = datasetStartAngle;\n        }\n      }\n      const properties = {\n        x: centerX,\n        y: centerY,\n        innerRadius: 0,\n        outerRadius,\n        startAngle,\n        endAngle,\n        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n      };\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n  countVisibleElements() {\n    const meta = this._cachedMeta;\n    let count = 0;\n    meta.data.forEach((element, index) => {\n      if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n        count++;\n      }\n    });\n    return count;\n  }\n  _computeAngle(index, mode, defaultAngle) {\n    return this.chart.getDataVisibility(index)\n      ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\n      : 0;\n  }\n}\nPolarAreaController.id = 'polarArea';\nPolarAreaController.defaults = {\n  dataElementType: 'arc',\n  animation: {\n    animateRotate: true,\n    animateScale: true\n  },\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\n    },\n  },\n  indexAxis: 'r',\n  startAngle: 0,\n};\nPolarAreaController.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels(chart) {\n          const data = chart.data;\n          if (data.labels.length && data.datasets.length) {\n            const {labels: {pointStyle}} = chart.legend.options;\n            return data.labels.map((label, i) => {\n              const meta = chart.getDatasetMeta(0);\n              const style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                pointStyle: pointStyle,\n                hidden: !chart.getDataVisibility(i),\n                index: i\n              };\n            });\n          }\n          return [];\n        }\n      },\n      onClick(e, legendItem, legend) {\n        legend.chart.toggleDataVisibility(legendItem.index);\n        legend.chart.update();\n      }\n    },\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(context) {\n          return context.chart.data.labels[context.dataIndex] + ': ' + context.formattedValue;\n        }\n      }\n    }\n  },\n  scales: {\n    r: {\n      type: 'radialLinear',\n      angleLines: {\n        display: false\n      },\n      beginAtZero: true,\n      grid: {\n        circular: true\n      },\n      pointLabels: {\n        display: false\n      },\n      startAngle: 0\n    }\n  }\n};\n\nclass PieController extends DoughnutController {\n}\nPieController.id = 'pie';\nPieController.defaults = {\n  cutout: 0,\n  rotation: 0,\n  circumference: 360,\n  radius: '100%'\n};\n\nclass RadarController extends DatasetController {\n  getLabelAndValue(index) {\n    const vScale = this._cachedMeta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: vScale.getLabels()[index],\n      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n    };\n  }\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    const line = meta.dataset;\n    const points = meta.data || [];\n    const labels = meta.iScale.getLabels();\n    line.points = points;\n    if (mode !== 'resize') {\n      const options = this.resolveDatasetElementOptions(mode);\n      if (!this.options.showLine) {\n        options.borderWidth = 0;\n      }\n      const properties = {\n        _loop: true,\n        _fullLoop: labels.length === points.length,\n        options\n      };\n      this.updateElement(line, undefined, properties, mode);\n    }\n    this.updateElements(points, 0, points.length, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const scale = this._cachedMeta.rScale;\n    const reset = mode === 'reset';\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n      const x = reset ? scale.xCenter : pointPosition.x;\n      const y = reset ? scale.yCenter : pointPosition.y;\n      const properties = {\n        x,\n        y,\n        angle: pointPosition.angle,\n        skip: isNaN(x) || isNaN(y),\n        options\n      };\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n}\nRadarController.id = 'radar';\nRadarController.defaults = {\n  datasetElementType: 'line',\n  dataElementType: 'point',\n  indexAxis: 'r',\n  showLine: true,\n  elements: {\n    line: {\n      fill: 'start'\n    }\n  },\n};\nRadarController.overrides = {\n  aspectRatio: 1,\n  scales: {\n    r: {\n      type: 'radialLinear',\n    }\n  }\n};\n\nclass Element {\n  constructor() {\n    this.x = undefined;\n    this.y = undefined;\n    this.active = false;\n    this.options = undefined;\n    this.$animations = undefined;\n  }\n  tooltipPosition(useFinalPosition) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n  hasValue() {\n    return isNumber(this.x) && isNumber(this.y);\n  }\n  getProps(props, final) {\n    const anims = this.$animations;\n    if (!final || !anims) {\n      return this;\n    }\n    const ret = {};\n    props.forEach(prop => {\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\n    });\n    return ret;\n  }\n}\nElement.defaults = {};\nElement.defaultRoutes = undefined;\n\nconst formatters = {\n  values(value) {\n    return isArray(value) ? value : '' + value;\n  },\n  numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue;\n    if (ticks.length > 1) {\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n      delta = calculateDelta(tickValue, ticks);\n    }\n    const logDelta = log10(Math.abs(delta));\n    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\n    Object.assign(options, this.options.ticks.format);\n    return formatNumber(tickValue, locale, options);\n  },\n  logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const remain = tickValue / (Math.pow(10, Math.floor(log10(tickValue))));\n    if (remain === 1 || remain === 2 || remain === 5) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n    return '';\n  }\n};\nfunction calculateDelta(tickValue, ticks) {\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    delta = tickValue - Math.floor(tickValue);\n  }\n  return delta;\n}\nvar Ticks = {formatters};\n\ndefaults.set('scale', {\n  display: true,\n  offset: false,\n  reverse: false,\n  beginAtZero: false,\n  bounds: 'ticks',\n  grace: 0,\n  grid: {\n    display: true,\n    lineWidth: 1,\n    drawBorder: true,\n    drawOnChartArea: true,\n    drawTicks: true,\n    tickLength: 8,\n    tickWidth: (_ctx, options) => options.lineWidth,\n    tickColor: (_ctx, options) => options.color,\n    offset: false,\n    borderDash: [],\n    borderDashOffset: 0.0,\n    borderWidth: 1\n  },\n  title: {\n    display: false,\n    text: '',\n    padding: {\n      top: 4,\n      bottom: 4\n    }\n  },\n  ticks: {\n    minRotation: 0,\n    maxRotation: 50,\n    mirror: false,\n    textStrokeWidth: 0,\n    textStrokeColor: '',\n    padding: 3,\n    display: true,\n    autoSkip: true,\n    autoSkipPadding: 3,\n    labelOffset: 0,\n    callback: Ticks.formatters.values,\n    minor: {},\n    major: {},\n    align: 'center',\n    crossAlign: 'near',\n    showLabelBackdrop: false,\n    backdropColor: 'rgba(255, 255, 255, 0.75)',\n    backdropPadding: 2,\n  }\n});\ndefaults.route('scale.ticks', 'color', '', 'color');\ndefaults.route('scale.grid', 'color', '', 'borderColor');\ndefaults.route('scale.grid', 'borderColor', '', 'borderColor');\ndefaults.route('scale.title', 'color', '', 'color');\ndefaults.describe('scale', {\n  _fallback: false,\n  _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n  _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash',\n});\ndefaults.describe('scales', {\n  _fallback: 'scale',\n});\ndefaults.describe('scale.ticks', {\n  _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',\n  _indexable: (name) => name !== 'backdropPadding',\n});\n\nfunction autoSkip(scale, ticks) {\n  const tickOpts = scale.options.ticks;\n  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n  const numMajorIndices = majorIndices.length;\n  const first = majorIndices[0];\n  const last = majorIndices[numMajorIndices - 1];\n  const newTicks = [];\n  if (numMajorIndices > ticksLimit) {\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n    return newTicks;\n  }\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n  if (numMajorIndices > 0) {\n    let i, ilen;\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n    }\n    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n    return newTicks;\n  }\n  skip(ticks, newTicks, spacing);\n  return newTicks;\n}\nfunction determineMaxTicks(scale) {\n  const offset = scale.options.offset;\n  const tickLength = scale._tickSize();\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n  const maxChart = scale._maxLength / tickLength;\n  return Math.floor(Math.min(maxScale, maxChart));\n}\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\n  const spacing = ticks.length / ticksLimit;\n  if (!evenMajorSpacing) {\n    return Math.max(spacing, 1);\n  }\n  const factors = _factorize(evenMajorSpacing);\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\n    const factor = factors[i];\n    if (factor > spacing) {\n      return factor;\n    }\n  }\n  return Math.max(spacing, 1);\n}\nfunction getMajorIndices(ticks) {\n  const result = [];\n  let i, ilen;\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\n    if (ticks[i].major) {\n      result.push(i);\n    }\n  }\n  return result;\n}\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n  let count = 0;\n  let next = majorIndices[0];\n  let i;\n  spacing = Math.ceil(spacing);\n  for (i = 0; i < ticks.length; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = majorIndices[count * spacing];\n    }\n  }\n}\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n  const start = valueOrDefault(majorStart, 0);\n  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n  let count = 0;\n  let length, i, next;\n  spacing = Math.ceil(spacing);\n  if (majorEnd) {\n    length = majorEnd - majorStart;\n    spacing = length / Math.floor(length / spacing);\n  }\n  next = start;\n  while (next < 0) {\n    count++;\n    next = Math.round(start + count * spacing);\n  }\n  for (i = Math.max(start, 0); i < end; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = Math.round(start + count * spacing);\n    }\n  }\n}\nfunction getEvenSpacing(arr) {\n  const len = arr.length;\n  let i, diff;\n  if (len < 2) {\n    return false;\n  }\n  for (diff = arr[0], i = 1; i < len; ++i) {\n    if (arr[i] - arr[i - 1] !== diff) {\n      return false;\n    }\n  }\n  return diff;\n}\n\nconst reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nfunction sample(arr, numItems) {\n  const result = [];\n  const increment = arr.length / numItems;\n  const len = arr.length;\n  let i = 0;\n  for (; i < len; i += increment) {\n    result.push(arr[Math.floor(i)]);\n  }\n  return result;\n}\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n  const length = scale.ticks.length;\n  const validIndex = Math.min(index, length - 1);\n  const start = scale._startPixel;\n  const end = scale._endPixel;\n  const epsilon = 1e-6;\n  let lineValue = scale.getPixelForTick(validIndex);\n  let offset;\n  if (offsetGridLines) {\n    if (length === 1) {\n      offset = Math.max(lineValue - start, end - lineValue);\n    } else if (index === 0) {\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n    }\n    lineValue += validIndex < index ? offset : -offset;\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\n      return;\n    }\n  }\n  return lineValue;\n}\nfunction garbageCollect(caches, length) {\n  each(caches, (cache) => {\n    const gc = cache.gc;\n    const gcLen = gc.length / 2;\n    let i;\n    if (gcLen > length) {\n      for (i = 0; i < gcLen; ++i) {\n        delete cache.data[gc[i]];\n      }\n      gc.splice(0, gcLen);\n    }\n  });\n}\nfunction getTickMarkLength(options) {\n  return options.drawTicks ? options.tickLength : 0;\n}\nfunction getTitleHeight(options, fallback) {\n  if (!options.display) {\n    return 0;\n  }\n  const font = toFont(options.font, fallback);\n  const padding = toPadding(options.padding);\n  const lines = isArray(options.text) ? options.text.length : 1;\n  return (lines * font.lineHeight) + padding.height;\n}\nfunction createScaleContext(parent, scale) {\n  return createContext(parent, {\n    scale,\n    type: 'scale'\n  });\n}\nfunction createTickContext(parent, index, tick) {\n  return createContext(parent, {\n    tick,\n    index,\n    type: 'tick'\n  });\n}\nfunction titleAlign(align, position, reverse) {\n  let ret = _toLeftRightCenter(align);\n  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\n    ret = reverseAlign(ret);\n  }\n  return ret;\n}\nfunction titleArgs(scale, offset, position, align) {\n  const {top, left, bottom, right, chart} = scale;\n  const {chartArea, scales} = chart;\n  let rotation = 0;\n  let maxWidth, titleX, titleY;\n  const height = bottom - top;\n  const width = right - left;\n  if (scale.isHorizontal()) {\n    titleX = _alignStartEnd(align, left, right);\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n    } else if (position === 'center') {\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n    } else {\n      titleY = offsetFromEdge(scale, position, offset);\n    }\n    maxWidth = right - left;\n  } else {\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n    } else if (position === 'center') {\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n    } else {\n      titleX = offsetFromEdge(scale, position, offset);\n    }\n    titleY = _alignStartEnd(align, bottom, top);\n    rotation = position === 'left' ? -HALF_PI : HALF_PI;\n  }\n  return {titleX, titleY, maxWidth, rotation};\n}\nclass Scale extends Element {\n  constructor(cfg) {\n    super();\n    this.id = cfg.id;\n    this.type = cfg.type;\n    this.options = undefined;\n    this.ctx = cfg.ctx;\n    this.chart = cfg.chart;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    this.maxWidth = undefined;\n    this.maxHeight = undefined;\n    this.paddingTop = undefined;\n    this.paddingBottom = undefined;\n    this.paddingLeft = undefined;\n    this.paddingRight = undefined;\n    this.axis = undefined;\n    this.labelRotation = undefined;\n    this.min = undefined;\n    this.max = undefined;\n    this._range = undefined;\n    this.ticks = [];\n    this._gridLineItems = null;\n    this._labelItems = null;\n    this._labelSizes = null;\n    this._length = 0;\n    this._maxLength = 0;\n    this._longestTextCache = {};\n    this._startPixel = undefined;\n    this._endPixel = undefined;\n    this._reversePixels = false;\n    this._userMax = undefined;\n    this._userMin = undefined;\n    this._suggestedMax = undefined;\n    this._suggestedMin = undefined;\n    this._ticksLength = 0;\n    this._borderValue = 0;\n    this._cache = {};\n    this._dataLimitsCached = false;\n    this.$context = undefined;\n  }\n  init(options) {\n    this.options = options.setContext(this.getContext());\n    this.axis = options.axis;\n    this._userMin = this.parse(options.min);\n    this._userMax = this.parse(options.max);\n    this._suggestedMin = this.parse(options.suggestedMin);\n    this._suggestedMax = this.parse(options.suggestedMax);\n  }\n  parse(raw, index) {\n    return raw;\n  }\n  getUserBounds() {\n    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\n    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n    return {\n      min: finiteOrDefault(_userMin, _suggestedMin),\n      max: finiteOrDefault(_userMax, _suggestedMax),\n      minDefined: isNumberFinite(_userMin),\n      maxDefined: isNumberFinite(_userMax)\n    };\n  }\n  getMinMax(canStack) {\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    let range;\n    if (minDefined && maxDefined) {\n      return {min, max};\n    }\n    const metas = this.getMatchingVisibleMetas();\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\n      range = metas[i].controller.getMinMax(this, canStack);\n      if (!minDefined) {\n        min = Math.min(min, range.min);\n      }\n      if (!maxDefined) {\n        max = Math.max(max, range.max);\n      }\n    }\n    min = maxDefined && min > max ? max : min;\n    max = minDefined && min > max ? min : max;\n    return {\n      min: finiteOrDefault(min, finiteOrDefault(max, min)),\n      max: finiteOrDefault(max, finiteOrDefault(min, max))\n    };\n  }\n  getPadding() {\n    return {\n      left: this.paddingLeft || 0,\n      top: this.paddingTop || 0,\n      right: this.paddingRight || 0,\n      bottom: this.paddingBottom || 0\n    };\n  }\n  getTicks() {\n    return this.ticks;\n  }\n  getLabels() {\n    const data = this.chart.data;\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n  }\n  beforeLayout() {\n    this._cache = {};\n    this._dataLimitsCached = false;\n  }\n  beforeUpdate() {\n    callback(this.options.beforeUpdate, [this]);\n  }\n  update(maxWidth, maxHeight, margins) {\n    const {beginAtZero, grace, ticks: tickOpts} = this.options;\n    const sampleSize = tickOpts.sampleSize;\n    this.beforeUpdate();\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins = Object.assign({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, margins);\n    this.ticks = null;\n    this._labelSizes = null;\n    this._gridLineItems = null;\n    this._labelItems = null;\n    this.beforeSetDimensions();\n    this.setDimensions();\n    this.afterSetDimensions();\n    this._maxLength = this.isHorizontal()\n      ? this.width + margins.left + margins.right\n      : this.height + margins.top + margins.bottom;\n    if (!this._dataLimitsCached) {\n      this.beforeDataLimits();\n      this.determineDataLimits();\n      this.afterDataLimits();\n      this._range = _addGrace(this, grace, beginAtZero);\n      this._dataLimitsCached = true;\n    }\n    this.beforeBuildTicks();\n    this.ticks = this.buildTicks() || [];\n    this.afterBuildTicks();\n    const samplingEnabled = sampleSize < this.ticks.length;\n    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n    this.configure();\n    this.beforeCalculateLabelRotation();\n    this.calculateLabelRotation();\n    this.afterCalculateLabelRotation();\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n      this.ticks = autoSkip(this, this.ticks);\n      this._labelSizes = null;\n      this.afterAutoSkip();\n    }\n    if (samplingEnabled) {\n      this._convertTicksToLabels(this.ticks);\n    }\n    this.beforeFit();\n    this.fit();\n    this.afterFit();\n    this.afterUpdate();\n  }\n  configure() {\n    let reversePixels = this.options.reverse;\n    let startPixel, endPixel;\n    if (this.isHorizontal()) {\n      startPixel = this.left;\n      endPixel = this.right;\n    } else {\n      startPixel = this.top;\n      endPixel = this.bottom;\n      reversePixels = !reversePixels;\n    }\n    this._startPixel = startPixel;\n    this._endPixel = endPixel;\n    this._reversePixels = reversePixels;\n    this._length = endPixel - startPixel;\n    this._alignToPixels = this.options.alignToPixels;\n  }\n  afterUpdate() {\n    callback(this.options.afterUpdate, [this]);\n  }\n  beforeSetDimensions() {\n    callback(this.options.beforeSetDimensions, [this]);\n  }\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = 0;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = 0;\n      this.bottom = this.height;\n    }\n    this.paddingLeft = 0;\n    this.paddingTop = 0;\n    this.paddingRight = 0;\n    this.paddingBottom = 0;\n  }\n  afterSetDimensions() {\n    callback(this.options.afterSetDimensions, [this]);\n  }\n  _callHooks(name) {\n    this.chart.notifyPlugins(name, this.getContext());\n    callback(this.options[name], [this]);\n  }\n  beforeDataLimits() {\n    this._callHooks('beforeDataLimits');\n  }\n  determineDataLimits() {}\n  afterDataLimits() {\n    this._callHooks('afterDataLimits');\n  }\n  beforeBuildTicks() {\n    this._callHooks('beforeBuildTicks');\n  }\n  buildTicks() {\n    return [];\n  }\n  afterBuildTicks() {\n    this._callHooks('afterBuildTicks');\n  }\n  beforeTickToLabelConversion() {\n    callback(this.options.beforeTickToLabelConversion, [this]);\n  }\n  generateTickLabels(ticks) {\n    const tickOpts = this.options.ticks;\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      tick = ticks[i];\n      tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);\n    }\n  }\n  afterTickToLabelConversion() {\n    callback(this.options.afterTickToLabelConversion, [this]);\n  }\n  beforeCalculateLabelRotation() {\n    callback(this.options.beforeCalculateLabelRotation, [this]);\n  }\n  calculateLabelRotation() {\n    const options = this.options;\n    const tickOpts = options.ticks;\n    const numTicks = this.ticks.length;\n    const minRotation = tickOpts.minRotation || 0;\n    const maxRotation = tickOpts.maxRotation;\n    let labelRotation = minRotation;\n    let tickWidth, maxHeight, maxLabelDiagonal;\n    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n      this.labelRotation = minRotation;\n      return;\n    }\n    const labelSizes = this._getLabelSizes();\n    const maxLabelWidth = labelSizes.widest.width;\n    const maxLabelHeight = labelSizes.highest.height;\n    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n    if (maxLabelWidth + 6 > tickWidth) {\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n      maxHeight = this.maxHeight - getTickMarkLength(options.grid)\n\t\t\t\t- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n      labelRotation = toDegrees(Math.min(\n        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),\n        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))\n      ));\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n    }\n    this.labelRotation = labelRotation;\n  }\n  afterCalculateLabelRotation() {\n    callback(this.options.afterCalculateLabelRotation, [this]);\n  }\n  afterAutoSkip() {}\n  beforeFit() {\n    callback(this.options.beforeFit, [this]);\n  }\n  fit() {\n    const minSize = {\n      width: 0,\n      height: 0\n    };\n    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;\n    const display = this._isVisible();\n    const isHorizontal = this.isHorizontal();\n    if (display) {\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n      if (isHorizontal) {\n        minSize.width = this.maxWidth;\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n      } else {\n        minSize.height = this.maxHeight;\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n      }\n      if (tickOpts.display && this.ticks.length) {\n        const {first, last, widest, highest} = this._getLabelSizes();\n        const tickPadding = tickOpts.padding * 2;\n        const angleRadians = toRadians(this.labelRotation);\n        const cos = Math.cos(angleRadians);\n        const sin = Math.sin(angleRadians);\n        if (isHorizontal) {\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n        } else {\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n        }\n        this._calculatePadding(first, last, sin, cos);\n      }\n    }\n    this._handleMargins();\n    if (isHorizontal) {\n      this.width = this._length = chart.width - this._margins.left - this._margins.right;\n      this.height = minSize.height;\n    } else {\n      this.width = minSize.width;\n      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n    }\n  }\n  _calculatePadding(first, last, sin, cos) {\n    const {ticks: {align, padding}, position} = this.options;\n    const isRotated = this.labelRotation !== 0;\n    const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n    if (this.isHorizontal()) {\n      const offsetLeft = this.getPixelForTick(0) - this.left;\n      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n      let paddingLeft = 0;\n      let paddingRight = 0;\n      if (isRotated) {\n        if (labelsBelowTicks) {\n          paddingLeft = cos * first.width;\n          paddingRight = sin * last.height;\n        } else {\n          paddingLeft = sin * first.height;\n          paddingRight = cos * last.width;\n        }\n      } else if (align === 'start') {\n        paddingRight = last.width;\n      } else if (align === 'end') {\n        paddingLeft = first.width;\n      } else if (align !== 'inner') {\n        paddingLeft = first.width / 2;\n        paddingRight = last.width / 2;\n      }\n      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n    } else {\n      let paddingTop = last.height / 2;\n      let paddingBottom = first.height / 2;\n      if (align === 'start') {\n        paddingTop = 0;\n        paddingBottom = first.height;\n      } else if (align === 'end') {\n        paddingTop = last.height;\n        paddingBottom = 0;\n      }\n      this.paddingTop = paddingTop + padding;\n      this.paddingBottom = paddingBottom + padding;\n    }\n  }\n  _handleMargins() {\n    if (this._margins) {\n      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n      this._margins.top = Math.max(this.paddingTop, this._margins.top);\n      this._margins.right = Math.max(this.paddingRight, this._margins.right);\n      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n    }\n  }\n  afterFit() {\n    callback(this.options.afterFit, [this]);\n  }\n  isHorizontal() {\n    const {axis, position} = this.options;\n    return position === 'top' || position === 'bottom' || axis === 'x';\n  }\n  isFullSize() {\n    return this.options.fullSize;\n  }\n  _convertTicksToLabels(ticks) {\n    this.beforeTickToLabelConversion();\n    this.generateTickLabels(ticks);\n    let i, ilen;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      if (isNullOrUndef(ticks[i].label)) {\n        ticks.splice(i, 1);\n        ilen--;\n        i--;\n      }\n    }\n    this.afterTickToLabelConversion();\n  }\n  _getLabelSizes() {\n    let labelSizes = this._labelSizes;\n    if (!labelSizes) {\n      const sampleSize = this.options.ticks.sampleSize;\n      let ticks = this.ticks;\n      if (sampleSize < ticks.length) {\n        ticks = sample(ticks, sampleSize);\n      }\n      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);\n    }\n    return labelSizes;\n  }\n  _computeLabelSizes(ticks, length) {\n    const {ctx, _longestTextCache: caches} = this;\n    const widths = [];\n    const heights = [];\n    let widestLabelSize = 0;\n    let highestLabelSize = 0;\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n    for (i = 0; i < length; ++i) {\n      label = ticks[i].label;\n      tickFont = this._resolveTickFontOptions(i);\n      ctx.font = fontString = tickFont.string;\n      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\n      lineHeight = tickFont.lineHeight;\n      width = height = 0;\n      if (!isNullOrUndef(label) && !isArray(label)) {\n        width = _measureText(ctx, cache.data, cache.gc, width, label);\n        height = lineHeight;\n      } else if (isArray(label)) {\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\n          nestedLabel = label[j];\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n            height += lineHeight;\n          }\n        }\n      }\n      widths.push(width);\n      heights.push(height);\n      widestLabelSize = Math.max(width, widestLabelSize);\n      highestLabelSize = Math.max(height, highestLabelSize);\n    }\n    garbageCollect(caches, length);\n    const widest = widths.indexOf(widestLabelSize);\n    const highest = heights.indexOf(highestLabelSize);\n    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\n    return {\n      first: valueAt(0),\n      last: valueAt(length - 1),\n      widest: valueAt(widest),\n      highest: valueAt(highest),\n      widths,\n      heights,\n    };\n  }\n  getLabelForValue(value) {\n    return value;\n  }\n  getPixelForValue(value, index) {\n    return NaN;\n  }\n  getValueForPixel(pixel) {}\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n  getPixelForDecimal(decimal) {\n    if (this._reversePixels) {\n      decimal = 1 - decimal;\n    }\n    const pixel = this._startPixel + decimal * this._length;\n    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\n  }\n  getDecimalForPixel(pixel) {\n    const decimal = (pixel - this._startPixel) / this._length;\n    return this._reversePixels ? 1 - decimal : decimal;\n  }\n  getBasePixel() {\n    return this.getPixelForValue(this.getBaseValue());\n  }\n  getBaseValue() {\n    const {min, max} = this;\n    return min < 0 && max < 0 ? max :\n      min > 0 && max > 0 ? min :\n      0;\n  }\n  getContext(index) {\n    const ticks = this.ticks || [];\n    if (index >= 0 && index < ticks.length) {\n      const tick = ticks[index];\n      return tick.$context ||\n\t\t\t\t(tick.$context = createTickContext(this.getContext(), index, tick));\n    }\n    return this.$context ||\n\t\t\t(this.$context = createScaleContext(this.chart.getContext(), this));\n  }\n  _tickSize() {\n    const optionTicks = this.options.ticks;\n    const rot = toRadians(this.labelRotation);\n    const cos = Math.abs(Math.cos(rot));\n    const sin = Math.abs(Math.sin(rot));\n    const labelSizes = this._getLabelSizes();\n    const padding = optionTicks.autoSkipPadding || 0;\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\n    return this.isHorizontal()\n      ? h * cos > w * sin ? w / cos : h / sin\n      : h * sin < w * cos ? h / cos : w / sin;\n  }\n  _isVisible() {\n    const display = this.options.display;\n    if (display !== 'auto') {\n      return !!display;\n    }\n    return this.getMatchingVisibleMetas().length > 0;\n  }\n  _computeGridLineItems(chartArea) {\n    const axis = this.axis;\n    const chart = this.chart;\n    const options = this.options;\n    const {grid, position} = options;\n    const offset = grid.offset;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const ticksLength = ticks.length + (offset ? 1 : 0);\n    const tl = getTickMarkLength(grid);\n    const items = [];\n    const borderOpts = grid.setContext(this.getContext());\n    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;\n    const axisHalfWidth = axisWidth / 2;\n    const alignBorderValue = function(pixel) {\n      return _alignPixel(chart, pixel, axisWidth);\n    };\n    let borderValue, i, lineValue, alignedLineValue;\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n    if (position === 'top') {\n      borderValue = alignBorderValue(this.bottom);\n      ty1 = this.bottom - tl;\n      ty2 = borderValue - axisHalfWidth;\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n      y2 = chartArea.bottom;\n    } else if (position === 'bottom') {\n      borderValue = alignBorderValue(this.top);\n      y1 = chartArea.top;\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = this.top + tl;\n    } else if (position === 'left') {\n      borderValue = alignBorderValue(this.right);\n      tx1 = this.right - tl;\n      tx2 = borderValue - axisHalfWidth;\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n      x2 = chartArea.right;\n    } else if (position === 'right') {\n      borderValue = alignBorderValue(this.left);\n      x1 = chartArea.left;\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n      tx1 = borderValue + axisHalfWidth;\n      tx2 = this.left + tl;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n      y1 = chartArea.top;\n      y2 = chartArea.bottom;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = ty1 + tl;\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n      tx1 = borderValue - axisHalfWidth;\n      tx2 = tx1 - tl;\n      x1 = chartArea.left;\n      x2 = chartArea.right;\n    }\n    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\n    for (i = 0; i < ticksLength; i += step) {\n      const optsAtIndex = grid.setContext(this.getContext(i));\n      const lineWidth = optsAtIndex.lineWidth;\n      const lineColor = optsAtIndex.color;\n      const borderDash = optsAtIndex.borderDash || [];\n      const borderDashOffset = optsAtIndex.borderDashOffset;\n      const tickWidth = optsAtIndex.tickWidth;\n      const tickColor = optsAtIndex.tickColor;\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n      lineValue = getPixelForGridLine(this, i, offset);\n      if (lineValue === undefined) {\n        continue;\n      }\n      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n      if (isHorizontal) {\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\n      } else {\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\n      }\n      items.push({\n        tx1,\n        ty1,\n        tx2,\n        ty2,\n        x1,\n        y1,\n        x2,\n        y2,\n        width: lineWidth,\n        color: lineColor,\n        borderDash,\n        borderDashOffset,\n        tickWidth,\n        tickColor,\n        tickBorderDash,\n        tickBorderDashOffset,\n      });\n    }\n    this._ticksLength = ticksLength;\n    this._borderValue = borderValue;\n    return items;\n  }\n  _computeLabelItems(chartArea) {\n    const axis = this.axis;\n    const options = this.options;\n    const {position, ticks: optionTicks} = options;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const {align, crossAlign, padding, mirror} = optionTicks;\n    const tl = getTickMarkLength(options.grid);\n    const tickAndPadding = tl + padding;\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\n    const rotation = -toRadians(this.labelRotation);\n    const items = [];\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n    let textBaseline = 'middle';\n    if (position === 'top') {\n      y = this.bottom - hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'bottom') {\n      y = this.top + hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'left') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (position === 'right') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n      }\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        x = this.chart.scales[positionAxisID].getPixelForValue(value);\n      }\n      textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n    }\n    if (axis === 'y') {\n      if (align === 'start') {\n        textBaseline = 'top';\n      } else if (align === 'end') {\n        textBaseline = 'bottom';\n      }\n    }\n    const labelSizes = this._getLabelSizes();\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      label = tick.label;\n      const optsAtIndex = optionTicks.setContext(this.getContext(i));\n      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n      font = this._resolveTickFontOptions(i);\n      lineHeight = font.lineHeight;\n      lineCount = isArray(label) ? label.length : 1;\n      const halfCount = lineCount / 2;\n      const color = optsAtIndex.color;\n      const strokeColor = optsAtIndex.textStrokeColor;\n      const strokeWidth = optsAtIndex.textStrokeWidth;\n      let tickTextAlign = textAlign;\n      if (isHorizontal) {\n        x = pixel;\n        if (textAlign === 'inner') {\n          if (i === ilen - 1) {\n            tickTextAlign = !this.options.reverse ? 'right' : 'left';\n          } else if (i === 0) {\n            tickTextAlign = !this.options.reverse ? 'left' : 'right';\n          } else {\n            tickTextAlign = 'center';\n          }\n        }\n        if (position === 'top') {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n          } else {\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\n          }\n        } else {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n          } else {\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\n          }\n        }\n        if (mirror) {\n          textOffset *= -1;\n        }\n      } else {\n        y = pixel;\n        textOffset = (1 - lineCount) * lineHeight / 2;\n      }\n      let backdrop;\n      if (optsAtIndex.showLabelBackdrop) {\n        const labelPadding = toPadding(optsAtIndex.backdropPadding);\n        const height = labelSizes.heights[i];\n        const width = labelSizes.widths[i];\n        let top = y + textOffset - labelPadding.top;\n        let left = x - labelPadding.left;\n        switch (textBaseline) {\n        case 'middle':\n          top -= height / 2;\n          break;\n        case 'bottom':\n          top -= height;\n          break;\n        }\n        switch (textAlign) {\n        case 'center':\n          left -= width / 2;\n          break;\n        case 'right':\n          left -= width;\n          break;\n        }\n        backdrop = {\n          left,\n          top,\n          width: width + labelPadding.width,\n          height: height + labelPadding.height,\n          color: optsAtIndex.backdropColor,\n        };\n      }\n      items.push({\n        rotation,\n        label,\n        font,\n        color,\n        strokeColor,\n        strokeWidth,\n        textOffset,\n        textAlign: tickTextAlign,\n        textBaseline,\n        translation: [x, y],\n        backdrop,\n      });\n    }\n    return items;\n  }\n  _getXAxisLabelAlignment() {\n    const {position, ticks} = this.options;\n    const rotation = -toRadians(this.labelRotation);\n    if (rotation) {\n      return position === 'top' ? 'left' : 'right';\n    }\n    let align = 'center';\n    if (ticks.align === 'start') {\n      align = 'left';\n    } else if (ticks.align === 'end') {\n      align = 'right';\n    } else if (ticks.align === 'inner') {\n      align = 'inner';\n    }\n    return align;\n  }\n  _getYAxisLabelAlignment(tl) {\n    const {position, ticks: {crossAlign, mirror, padding}} = this.options;\n    const labelSizes = this._getLabelSizes();\n    const tickAndPadding = tl + padding;\n    const widest = labelSizes.widest.width;\n    let textAlign;\n    let x;\n    if (position === 'left') {\n      if (mirror) {\n        x = this.right + padding;\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += (widest / 2);\n        } else {\n          textAlign = 'right';\n          x += widest;\n        }\n      } else {\n        x = this.right - tickAndPadding;\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x = this.left;\n        }\n      }\n    } else if (position === 'right') {\n      if (mirror) {\n        x = this.left + padding;\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x -= widest;\n        }\n      } else {\n        x = this.left + tickAndPadding;\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += widest / 2;\n        } else {\n          textAlign = 'right';\n          x = this.right;\n        }\n      }\n    } else {\n      textAlign = 'right';\n    }\n    return {textAlign, x};\n  }\n  _computeLabelArea() {\n    if (this.options.ticks.mirror) {\n      return;\n    }\n    const chart = this.chart;\n    const position = this.options.position;\n    if (position === 'left' || position === 'right') {\n      return {top: 0, left: this.left, bottom: chart.height, right: this.right};\n    } if (position === 'top' || position === 'bottom') {\n      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};\n    }\n  }\n  drawBackground() {\n    const {ctx, options: {backgroundColor}, left, top, width, height} = this;\n    if (backgroundColor) {\n      ctx.save();\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(left, top, width, height);\n      ctx.restore();\n    }\n  }\n  getLineWidthForValue(value) {\n    const grid = this.options.grid;\n    if (!this._isVisible() || !grid.display) {\n      return 0;\n    }\n    const ticks = this.ticks;\n    const index = ticks.findIndex(t => t.value === value);\n    if (index >= 0) {\n      const opts = grid.setContext(this.getContext(index));\n      return opts.lineWidth;\n    }\n    return 0;\n  }\n  drawGrid(chartArea) {\n    const grid = this.options.grid;\n    const ctx = this.ctx;\n    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n    let i, ilen;\n    const drawLine = (p1, p2, style) => {\n      if (!style.width || !style.color) {\n        return;\n      }\n      ctx.save();\n      ctx.lineWidth = style.width;\n      ctx.strokeStyle = style.color;\n      ctx.setLineDash(style.borderDash || []);\n      ctx.lineDashOffset = style.borderDashOffset;\n      ctx.beginPath();\n      ctx.moveTo(p1.x, p1.y);\n      ctx.lineTo(p2.x, p2.y);\n      ctx.stroke();\n      ctx.restore();\n    };\n    if (grid.display) {\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        const item = items[i];\n        if (grid.drawOnChartArea) {\n          drawLine(\n            {x: item.x1, y: item.y1},\n            {x: item.x2, y: item.y2},\n            item\n          );\n        }\n        if (grid.drawTicks) {\n          drawLine(\n            {x: item.tx1, y: item.ty1},\n            {x: item.tx2, y: item.ty2},\n            {\n              color: item.tickColor,\n              width: item.tickWidth,\n              borderDash: item.tickBorderDash,\n              borderDashOffset: item.tickBorderDashOffset\n            }\n          );\n        }\n      }\n    }\n  }\n  drawBorder() {\n    const {chart, ctx, options: {grid}} = this;\n    const borderOpts = grid.setContext(this.getContext());\n    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;\n    if (!axisWidth) {\n      return;\n    }\n    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n    const borderValue = this._borderValue;\n    let x1, x2, y1, y2;\n    if (this.isHorizontal()) {\n      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n      y1 = y2 = borderValue;\n    } else {\n      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n      x1 = x2 = borderValue;\n    }\n    ctx.save();\n    ctx.lineWidth = borderOpts.borderWidth;\n    ctx.strokeStyle = borderOpts.borderColor;\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n    ctx.restore();\n  }\n  drawLabels(chartArea) {\n    const optionTicks = this.options.ticks;\n    if (!optionTicks.display) {\n      return;\n    }\n    const ctx = this.ctx;\n    const area = this._computeLabelArea();\n    if (area) {\n      clipArea(ctx, area);\n    }\n    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n    let i, ilen;\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      const item = items[i];\n      const tickFont = item.font;\n      const label = item.label;\n      if (item.backdrop) {\n        ctx.fillStyle = item.backdrop.color;\n        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);\n      }\n      let y = item.textOffset;\n      renderText(ctx, label, 0, y, tickFont, item);\n    }\n    if (area) {\n      unclipArea(ctx);\n    }\n  }\n  drawTitle() {\n    const {ctx, options: {position, title, reverse}} = this;\n    if (!title.display) {\n      return;\n    }\n    const font = toFont(title.font);\n    const padding = toPadding(title.padding);\n    const align = title.align;\n    let offset = font.lineHeight / 2;\n    if (position === 'bottom' || position === 'center' || isObject(position)) {\n      offset += padding.bottom;\n      if (isArray(title.text)) {\n        offset += font.lineHeight * (title.text.length - 1);\n      }\n    } else {\n      offset += padding.top;\n    }\n    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\n    renderText(ctx, title.text, 0, 0, font, {\n      color: title.color,\n      maxWidth,\n      rotation,\n      textAlign: titleAlign(align, position, reverse),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n  draw(chartArea) {\n    if (!this._isVisible()) {\n      return;\n    }\n    this.drawBackground();\n    this.drawGrid(chartArea);\n    this.drawBorder();\n    this.drawTitle();\n    this.drawLabels(chartArea);\n  }\n  _layers() {\n    const opts = this.options;\n    const tz = opts.ticks && opts.ticks.z || 0;\n    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n      return [{\n        z: tz,\n        draw: (chartArea) => {\n          this.draw(chartArea);\n        }\n      }];\n    }\n    return [{\n      z: gz,\n      draw: (chartArea) => {\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawTitle();\n      }\n    }, {\n      z: gz + 1,\n      draw: () => {\n        this.drawBorder();\n      }\n    }, {\n      z: tz,\n      draw: (chartArea) => {\n        this.drawLabels(chartArea);\n      }\n    }];\n  }\n  getMatchingVisibleMetas(type) {\n    const metas = this.chart.getSortedVisibleDatasetMetas();\n    const axisID = this.axis + 'AxisID';\n    const result = [];\n    let i, ilen;\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      const meta = metas[i];\n      if (meta[axisID] === this.id && (!type || meta.type === type)) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n  _resolveTickFontOptions(index) {\n    const opts = this.options.ticks.setContext(this.getContext(index));\n    return toFont(opts.font);\n  }\n  _maxDigits() {\n    const fontSize = this._resolveTickFontOptions(0).lineHeight;\n    return (this.isHorizontal() ? this.width : this.height) / fontSize;\n  }\n}\n\nclass TypedRegistry {\n  constructor(type, scope, override) {\n    this.type = type;\n    this.scope = scope;\n    this.override = override;\n    this.items = Object.create(null);\n  }\n  isForType(type) {\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n  }\n  register(item) {\n    const proto = Object.getPrototypeOf(item);\n    let parentScope;\n    if (isIChartComponent(proto)) {\n      parentScope = this.register(proto);\n    }\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope + '.' + id;\n    if (!id) {\n      throw new Error('class does not have id: ' + item);\n    }\n    if (id in items) {\n      return scope;\n    }\n    items[id] = item;\n    registerDefaults(item, scope, parentScope);\n    if (this.override) {\n      defaults.override(item.id, item.overrides);\n    }\n    return scope;\n  }\n  get(id) {\n    return this.items[id];\n  }\n  unregister(item) {\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope;\n    if (id in items) {\n      delete items[id];\n    }\n    if (scope && id in defaults[scope]) {\n      delete defaults[scope][id];\n      if (this.override) {\n        delete overrides[id];\n      }\n    }\n  }\n}\nfunction registerDefaults(item, scope, parentScope) {\n  const itemDefaults = merge(Object.create(null), [\n    parentScope ? defaults.get(parentScope) : {},\n    defaults.get(scope),\n    item.defaults\n  ]);\n  defaults.set(scope, itemDefaults);\n  if (item.defaultRoutes) {\n    routeDefaults(scope, item.defaultRoutes);\n  }\n  if (item.descriptors) {\n    defaults.describe(scope, item.descriptors);\n  }\n}\nfunction routeDefaults(scope, routes) {\n  Object.keys(routes).forEach(property => {\n    const propertyParts = property.split('.');\n    const sourceName = propertyParts.pop();\n    const sourceScope = [scope].concat(propertyParts).join('.');\n    const parts = routes[property].split('.');\n    const targetName = parts.pop();\n    const targetScope = parts.join('.');\n    defaults.route(sourceScope, sourceName, targetScope, targetName);\n  });\n}\nfunction isIChartComponent(proto) {\n  return 'id' in proto && 'defaults' in proto;\n}\n\nclass Registry {\n  constructor() {\n    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n    this.elements = new TypedRegistry(Element, 'elements');\n    this.plugins = new TypedRegistry(Object, 'plugins');\n    this.scales = new TypedRegistry(Scale, 'scales');\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n  add(...args) {\n    this._each('register', args);\n  }\n  remove(...args) {\n    this._each('unregister', args);\n  }\n  addControllers(...args) {\n    this._each('register', args, this.controllers);\n  }\n  addElements(...args) {\n    this._each('register', args, this.elements);\n  }\n  addPlugins(...args) {\n    this._each('register', args, this.plugins);\n  }\n  addScales(...args) {\n    this._each('register', args, this.scales);\n  }\n  getController(id) {\n    return this._get(id, this.controllers, 'controller');\n  }\n  getElement(id) {\n    return this._get(id, this.elements, 'element');\n  }\n  getPlugin(id) {\n    return this._get(id, this.plugins, 'plugin');\n  }\n  getScale(id) {\n    return this._get(id, this.scales, 'scale');\n  }\n  removeControllers(...args) {\n    this._each('unregister', args, this.controllers);\n  }\n  removeElements(...args) {\n    this._each('unregister', args, this.elements);\n  }\n  removePlugins(...args) {\n    this._each('unregister', args, this.plugins);\n  }\n  removeScales(...args) {\n    this._each('unregister', args, this.scales);\n  }\n  _each(method, args, typedRegistry) {\n    [...args].forEach(arg => {\n      const reg = typedRegistry || this._getRegistryForType(arg);\n      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {\n        this._exec(method, reg, arg);\n      } else {\n        each(arg, item => {\n          const itemReg = typedRegistry || this._getRegistryForType(item);\n          this._exec(method, itemReg, item);\n        });\n      }\n    });\n  }\n  _exec(method, registry, component) {\n    const camelMethod = _capitalize(method);\n    callback(component['before' + camelMethod], [], component);\n    registry[method](component);\n    callback(component['after' + camelMethod], [], component);\n  }\n  _getRegistryForType(type) {\n    for (let i = 0; i < this._typedRegistries.length; i++) {\n      const reg = this._typedRegistries[i];\n      if (reg.isForType(type)) {\n        return reg;\n      }\n    }\n    return this.plugins;\n  }\n  _get(id, typedRegistry, type) {\n    const item = typedRegistry.get(id);\n    if (item === undefined) {\n      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n    }\n    return item;\n  }\n}\nvar registry = new Registry();\n\nclass ScatterController extends DatasetController {\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {data: points = []} = meta;\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n    this._drawStart = start;\n    this._drawCount = count;\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n    if (this.options.showLine) {\n      const {dataset: line, _dataset} = meta;\n      line._chart = this.chart;\n      line._datasetIndex = this.index;\n      line._decimated = !!_dataset._decimated;\n      line.points = points;\n      const options = this.resolveDatasetElementOptions(mode);\n      options.segment = this.options.segment;\n      this.updateElement(line, undefined, {\n        animated: !animationsDisabled,\n        options\n      }, mode);\n    }\n    this.updateElements(points, start, count, mode);\n  }\n  addElements() {\n    const {showLine} = this.options;\n    if (!this.datasetElementType && showLine) {\n      this.datasetElementType = registry.getElement('line');\n    }\n    super.addElements();\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n      prevParsed = parsed;\n    }\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const data = meta.data || [];\n    if (!this.options.showLine) {\n      let max = 0;\n      for (let i = data.length - 1; i >= 0; --i) {\n        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n      }\n      return max > 0 && max;\n    }\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n}\nScatterController.id = 'scatter';\nScatterController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'point',\n  showLine: false,\n  fill: false\n};\nScatterController.overrides = {\n  interaction: {\n    mode: 'point'\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(item) {\n          return '(' + item.label + ', ' + item.formattedValue + ')';\n        }\n      }\n    }\n  },\n  scales: {\n    x: {\n      type: 'linear'\n    },\n    y: {\n      type: 'linear'\n    }\n  }\n};\n\nvar controllers = /*#__PURE__*/Object.freeze({\n__proto__: null,\nBarController: BarController,\nBubbleController: BubbleController,\nDoughnutController: DoughnutController,\nLineController: LineController,\nPolarAreaController: PolarAreaController,\nPieController: PieController,\nRadarController: RadarController,\nScatterController: ScatterController\n});\n\nfunction abstract() {\n  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\nclass DateAdapter {\n  constructor(options) {\n    this.options = options || {};\n  }\n  init(chartOptions) {}\n  formats() {\n    return abstract();\n  }\n  parse(value, format) {\n    return abstract();\n  }\n  format(timestamp, format) {\n    return abstract();\n  }\n  add(timestamp, amount, unit) {\n    return abstract();\n  }\n  diff(a, b, unit) {\n    return abstract();\n  }\n  startOf(timestamp, unit, weekday) {\n    return abstract();\n  }\n  endOf(timestamp, unit) {\n    return abstract();\n  }\n}\nDateAdapter.override = function(members) {\n  Object.assign(DateAdapter.prototype, members);\n};\nvar adapters = {\n  _date: DateAdapter\n};\n\nfunction binarySearch(metaset, axis, value, intersect) {\n  const {controller, data, _sorted} = metaset;\n  const iScale = controller._cachedMeta.iScale;\n  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n    if (!intersect) {\n      return lookupMethod(data, axis, value);\n    } else if (controller._sharedOptions) {\n      const el = data[0];\n      const range = typeof el.getRange === 'function' && el.getRange(axis);\n      if (range) {\n        const start = lookupMethod(data, axis, value - range);\n        const end = lookupMethod(data, axis, value + range);\n        return {lo: start.lo, hi: end.hi};\n      }\n    }\n  }\n  return {lo: 0, hi: data.length - 1};\n}\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  const value = position[axis];\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    const {index, data} = metasets[i];\n    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\n    for (let j = lo; j <= hi; ++j) {\n      const element = data[j];\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\nfunction getDistanceMetricForAxis(axis) {\n  const useX = axis.indexOf('x') !== -1;\n  const useY = axis.indexOf('y') !== -1;\n  return function(pt1, pt2) {\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n  };\n}\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n  const items = [];\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return items;\n  }\n  const evaluationFunc = function(element, datasetIndex, index) {\n    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\n      return;\n    }\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n    }\n  };\n  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n  return items;\n}\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n  let items = [];\n  function evaluationFunc(element, datasetIndex, index) {\n    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);\n    const {angle} = getAngleFromPoint(element, {x: position.x, y: position.y});\n    if (_angleBetween(angle, startAngle, endAngle)) {\n      items.push({element, datasetIndex, index});\n    }\n  }\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  let items = [];\n  const distanceMetric = getDistanceMetricForAxis(axis);\n  let minDistance = Number.POSITIVE_INFINITY;\n  function evaluationFunc(element, datasetIndex, index) {\n    const inRange = element.inRange(position.x, position.y, useFinalPosition);\n    if (intersect && !inRange) {\n      return;\n    }\n    const center = element.getCenterPoint(useFinalPosition);\n    const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n    if (!pointInArea && !inRange) {\n      return;\n    }\n    const distance = distanceMetric(position, center);\n    if (distance < minDistance) {\n      items = [{element, datasetIndex, index}];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      items.push({element, datasetIndex, index});\n    }\n  }\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return [];\n  }\n  return axis === 'r' && !intersect\n    ? getNearestRadialItems(chart, position, axis, useFinalPosition)\n    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n  const items = [];\n  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n  let intersectsItem = false;\n  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {\n    if (element[rangeMethod](position[axis], useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n    }\n  });\n  if (intersect && !intersectsItem) {\n    return [];\n  }\n  return items;\n}\nvar Interaction = {\n  evaluateInteractionItems,\n  modes: {\n    index(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'x';\n      const includeInvisible = options.includeInvisible || false;\n      const items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible)\n        : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n      const elements = [];\n      if (!items.length) {\n        return [];\n      }\n      chart.getSortedVisibleDatasetMetas().forEach((meta) => {\n        const index = items[0].index;\n        const element = meta.data[index];\n        if (element && !element.skip) {\n          elements.push({element, datasetIndex: meta.index, index});\n        }\n      });\n      return elements;\n    },\n    dataset(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      let items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) :\n        getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n      if (items.length > 0) {\n        const datasetIndex = items[0].datasetIndex;\n        const data = chart.getDatasetMeta(datasetIndex).data;\n        items = [];\n        for (let i = 0; i < data.length; ++i) {\n          items.push({element: data[i], datasetIndex, index: i});\n        }\n      }\n      return items;\n    },\n    point(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n    },\n    nearest(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n    },\n    x(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\n    },\n    y(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\n    }\n  }\n};\n\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\nfunction filterByPosition(array, position) {\n  return array.filter(v => v.pos === position);\n}\nfunction filterDynamicPositionByAxis(array, axis) {\n  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\nfunction sortByWeight(array, reverse) {\n  return array.sort((a, b) => {\n    const v0 = reverse ? b : a;\n    const v1 = reverse ? a : b;\n    return v0.weight === v1.weight ?\n      v0.index - v1.index :\n      v0.weight - v1.weight;\n  });\n}\nfunction wrapBoxes(boxes) {\n  const layoutBoxes = [];\n  let i, ilen, box, pos, stack, stackWeight;\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n    box = boxes[i];\n    ({position: pos, options: {stack, stackWeight = 1}} = box);\n    layoutBoxes.push({\n      index: i,\n      box,\n      pos,\n      horizontal: box.isHorizontal(),\n      weight: box.weight,\n      stack: stack && (pos + stack),\n      stackWeight\n    });\n  }\n  return layoutBoxes;\n}\nfunction buildStacks(layouts) {\n  const stacks = {};\n  for (const wrap of layouts) {\n    const {stack, pos, stackWeight} = wrap;\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\n      continue;\n    }\n    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});\n    _stack.count++;\n    _stack.weight += stackWeight;\n  }\n  return stacks;\n}\nfunction setLayoutDims(layouts, params) {\n  const stacks = buildStacks(layouts);\n  const {vBoxMaxWidth, hBoxMaxHeight} = params;\n  let i, ilen, layout;\n  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\n    layout = layouts[i];\n    const {fullSize} = layout.box;\n    const stack = stacks[layout.stack];\n    const factor = stack && layout.stackWeight / stack.weight;\n    if (layout.horizontal) {\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n      layout.height = hBoxMaxHeight;\n    } else {\n      layout.width = vBoxMaxWidth;\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n    }\n  }\n  return stacks;\n}\nfunction buildLayoutBoxes(boxes) {\n  const layoutBoxes = wrapBoxes(boxes);\n  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\n  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n  return {\n    fullSize,\n    leftAndTop: left.concat(top),\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n    vertical: left.concat(right).concat(centerVertical),\n    horizontal: top.concat(bottom).concat(centerHorizontal)\n  };\n}\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\nfunction updateMaxPadding(maxPadding, boxPadding) {\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\nfunction updateDims(chartArea, params, layout, stacks) {\n  const {pos, box} = layout;\n  const maxPadding = chartArea.maxPadding;\n  if (!isObject(pos)) {\n    if (layout.size) {\n      chartArea[pos] -= layout.size;\n    }\n    const stack = stacks[layout.stack] || {size: 0, count: 1};\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n    layout.size = stack.size / stack.count;\n    chartArea[pos] += layout.size;\n  }\n  if (box.getPadding) {\n    updateMaxPadding(maxPadding, box.getPadding());\n  }\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n  const widthChanged = newWidth !== chartArea.w;\n  const heightChanged = newHeight !== chartArea.h;\n  chartArea.w = newWidth;\n  chartArea.h = newHeight;\n  return layout.horizontal\n    ? {same: widthChanged, other: heightChanged}\n    : {same: heightChanged, other: widthChanged};\n}\nfunction handleMaxPadding(chartArea) {\n  const maxPadding = chartArea.maxPadding;\n  function updatePos(pos) {\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n    chartArea[pos] += change;\n    return change;\n  }\n  chartArea.y += updatePos('top');\n  chartArea.x += updatePos('left');\n  updatePos('right');\n  updatePos('bottom');\n}\nfunction getMargins(horizontal, chartArea) {\n  const maxPadding = chartArea.maxPadding;\n  function marginForPositions(positions) {\n    const margin = {left: 0, top: 0, right: 0, bottom: 0};\n    positions.forEach((pos) => {\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n    });\n    return margin;\n  }\n  return horizontal\n    ? marginForPositions(['left', 'right'])\n    : marginForPositions(['top', 'bottom']);\n}\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n  const refitBoxes = [];\n  let i, ilen, layout, box, refit, changed;\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\n    layout = boxes[i];\n    box = layout.box;\n    box.update(\n      layout.width || chartArea.w,\n      layout.height || chartArea.h,\n      getMargins(layout.horizontal, chartArea)\n    );\n    const {same, other} = updateDims(chartArea, params, layout, stacks);\n    refit |= same && refitBoxes.length;\n    changed = changed || other;\n    if (!box.fullSize) {\n      refitBoxes.push(layout);\n    }\n  }\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\nfunction setBoxDims(box, left, top, width, height) {\n  box.top = top;\n  box.left = left;\n  box.right = left + width;\n  box.bottom = top + height;\n  box.width = width;\n  box.height = height;\n}\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n  const userPadding = params.padding;\n  let {x, y} = chartArea;\n  for (const layout of boxes) {\n    const box = layout.box;\n    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};\n    const weight = (layout.stackWeight / stack.weight) || 1;\n    if (layout.horizontal) {\n      const width = chartArea.w * weight;\n      const height = stack.size || box.height;\n      if (defined(stack.start)) {\n        y = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n      } else {\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n      }\n      stack.start = y;\n      stack.placed += width;\n      y = box.bottom;\n    } else {\n      const height = chartArea.h * weight;\n      const width = stack.size || box.width;\n      if (defined(stack.start)) {\n        x = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n      } else {\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n      }\n      stack.start = x;\n      stack.placed += height;\n      x = box.right;\n    }\n  }\n  chartArea.x = x;\n  chartArea.y = y;\n}\ndefaults.set('layout', {\n  autoPadding: true,\n  padding: {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  }\n});\nvar layouts = {\n  addBox(chart, item) {\n    if (!chart.boxes) {\n      chart.boxes = [];\n    }\n    item.fullSize = item.fullSize || false;\n    item.position = item.position || 'top';\n    item.weight = item.weight || 0;\n    item._layers = item._layers || function() {\n      return [{\n        z: 0,\n        draw(chartArea) {\n          item.draw(chartArea);\n        }\n      }];\n    };\n    chart.boxes.push(item);\n  },\n  removeBox(chart, layoutItem) {\n    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n    if (index !== -1) {\n      chart.boxes.splice(index, 1);\n    }\n  },\n  configure(chart, item, options) {\n    item.fullSize = options.fullSize;\n    item.position = options.position;\n    item.weight = options.weight;\n  },\n  update(chart, width, height, minPadding) {\n    if (!chart) {\n      return;\n    }\n    const padding = toPadding(chart.options.layout.padding);\n    const availableWidth = Math.max(width - padding.width, 0);\n    const availableHeight = Math.max(height - padding.height, 0);\n    const boxes = buildLayoutBoxes(chart.boxes);\n    const verticalBoxes = boxes.vertical;\n    const horizontalBoxes = boxes.horizontal;\n    each(chart.boxes, box => {\n      if (typeof box.beforeLayout === 'function') {\n        box.beforeLayout();\n      }\n    });\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\n      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n    const params = Object.freeze({\n      outerWidth: width,\n      outerHeight: height,\n      padding,\n      availableWidth,\n      availableHeight,\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n      hBoxMaxHeight: availableHeight / 2\n    });\n    const maxPadding = Object.assign({}, padding);\n    updateMaxPadding(maxPadding, toPadding(minPadding));\n    const chartArea = Object.assign({\n      maxPadding,\n      w: availableWidth,\n      h: availableHeight,\n      x: padding.left,\n      y: padding.top\n    }, padding);\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\n    }\n    handleMaxPadding(chartArea);\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n    chartArea.x += chartArea.w;\n    chartArea.y += chartArea.h;\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n    chart.chartArea = {\n      left: chartArea.left,\n      top: chartArea.top,\n      right: chartArea.left + chartArea.w,\n      bottom: chartArea.top + chartArea.h,\n      height: chartArea.h,\n      width: chartArea.w,\n    };\n    each(boxes.chartArea, (layout) => {\n      const box = layout.box;\n      Object.assign(box, chart.chartArea);\n      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});\n    });\n  }\n};\n\nclass BasePlatform {\n  acquireContext(canvas, aspectRatio) {}\n  releaseContext(context) {\n    return false;\n  }\n  addEventListener(chart, type, listener) {}\n  removeEventListener(chart, type, listener) {}\n  getDevicePixelRatio() {\n    return 1;\n  }\n  getMaximumSize(element, width, height, aspectRatio) {\n    width = Math.max(0, width || element.width);\n    height = height || element.height;\n    return {\n      width,\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n    };\n  }\n  isAttached(canvas) {\n    return true;\n  }\n  updateConfig(config) {\n  }\n}\n\nclass BasicPlatform extends BasePlatform {\n  acquireContext(item) {\n    return item && item.getContext && item.getContext('2d') || null;\n  }\n  updateConfig(config) {\n    config.options.animation = false;\n  }\n}\n\nconst EXPANDO_KEY = '$chartjs';\nconst EVENT_TYPES = {\n  touchstart: 'mousedown',\n  touchmove: 'mousemove',\n  touchend: 'mouseup',\n  pointerenter: 'mouseenter',\n  pointerdown: 'mousedown',\n  pointermove: 'mousemove',\n  pointerup: 'mouseup',\n  pointerleave: 'mouseout',\n  pointerout: 'mouseout'\n};\nconst isNullOrEmpty = value => value === null || value === '';\nfunction initCanvas(canvas, aspectRatio) {\n  const style = canvas.style;\n  const renderHeight = canvas.getAttribute('height');\n  const renderWidth = canvas.getAttribute('width');\n  canvas[EXPANDO_KEY] = {\n    initial: {\n      height: renderHeight,\n      width: renderWidth,\n      style: {\n        display: style.display,\n        height: style.height,\n        width: style.width\n      }\n    }\n  };\n  style.display = style.display || 'block';\n  style.boxSizing = style.boxSizing || 'border-box';\n  if (isNullOrEmpty(renderWidth)) {\n    const displayWidth = readUsedSize(canvas, 'width');\n    if (displayWidth !== undefined) {\n      canvas.width = displayWidth;\n    }\n  }\n  if (isNullOrEmpty(renderHeight)) {\n    if (canvas.style.height === '') {\n      canvas.height = canvas.width / (aspectRatio || 2);\n    } else {\n      const displayHeight = readUsedSize(canvas, 'height');\n      if (displayHeight !== undefined) {\n        canvas.height = displayHeight;\n      }\n    }\n  }\n  return canvas;\n}\nconst eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\nfunction addListener(node, type, listener) {\n  node.addEventListener(type, listener, eventListenerOptions);\n}\nfunction removeListener(chart, type, listener) {\n  chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n}\nfunction fromNativeEvent(event, chart) {\n  const type = EVENT_TYPES[event.type] || event.type;\n  const {x, y} = getRelativePosition(event, chart);\n  return {\n    type,\n    chart,\n    native: event,\n    x: x !== undefined ? x : null,\n    y: y !== undefined ? y : null,\n  };\n}\nfunction nodeListContains(nodeList, canvas) {\n  for (const node of nodeList) {\n    if (node === canvas || node.contains(canvas)) {\n      return true;\n    }\n  }\n}\nfunction createAttachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\nfunction createDetachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\nfunction onWindowResize() {\n  const dpr = window.devicePixelRatio;\n  if (dpr === oldDevicePixelRatio) {\n    return;\n  }\n  oldDevicePixelRatio = dpr;\n  drpListeningCharts.forEach((resize, chart) => {\n    if (chart.currentDevicePixelRatio !== dpr) {\n      resize();\n    }\n  });\n}\nfunction listenDevicePixelRatioChanges(chart, resize) {\n  if (!drpListeningCharts.size) {\n    window.addEventListener('resize', onWindowResize);\n  }\n  drpListeningCharts.set(chart, resize);\n}\nfunction unlistenDevicePixelRatioChanges(chart) {\n  drpListeningCharts.delete(chart);\n  if (!drpListeningCharts.size) {\n    window.removeEventListener('resize', onWindowResize);\n  }\n}\nfunction createResizeObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const container = canvas && _getParentNode(canvas);\n  if (!container) {\n    return;\n  }\n  const resize = throttled((width, height) => {\n    const w = container.clientWidth;\n    listener(width, height);\n    if (w < container.clientWidth) {\n      listener();\n    }\n  }, window);\n  const observer = new ResizeObserver(entries => {\n    const entry = entries[0];\n    const width = entry.contentRect.width;\n    const height = entry.contentRect.height;\n    if (width === 0 && height === 0) {\n      return;\n    }\n    resize(width, height);\n  });\n  observer.observe(container);\n  listenDevicePixelRatioChanges(chart, resize);\n  return observer;\n}\nfunction releaseObserver(chart, type, observer) {\n  if (observer) {\n    observer.disconnect();\n  }\n  if (type === 'resize') {\n    unlistenDevicePixelRatioChanges(chart);\n  }\n}\nfunction createProxyAndListen(chart, type, listener) {\n  const canvas = chart.canvas;\n  const proxy = throttled((event) => {\n    if (chart.ctx !== null) {\n      listener(fromNativeEvent(event, chart));\n    }\n  }, chart, (args) => {\n    const event = args[0];\n    return [event, event.offsetX, event.offsetY];\n  });\n  addListener(canvas, type, proxy);\n  return proxy;\n}\nclass DomPlatform extends BasePlatform {\n  acquireContext(canvas, aspectRatio) {\n    const context = canvas && canvas.getContext && canvas.getContext('2d');\n    if (context && context.canvas === canvas) {\n      initCanvas(canvas, aspectRatio);\n      return context;\n    }\n    return null;\n  }\n  releaseContext(context) {\n    const canvas = context.canvas;\n    if (!canvas[EXPANDO_KEY]) {\n      return false;\n    }\n    const initial = canvas[EXPANDO_KEY].initial;\n    ['height', 'width'].forEach((prop) => {\n      const value = initial[prop];\n      if (isNullOrUndef(value)) {\n        canvas.removeAttribute(prop);\n      } else {\n        canvas.setAttribute(prop, value);\n      }\n    });\n    const style = initial.style || {};\n    Object.keys(style).forEach((key) => {\n      canvas.style[key] = style[key];\n    });\n    canvas.width = canvas.width;\n    delete canvas[EXPANDO_KEY];\n    return true;\n  }\n  addEventListener(chart, type, listener) {\n    this.removeEventListener(chart, type);\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const handlers = {\n      attach: createAttachObserver,\n      detach: createDetachObserver,\n      resize: createResizeObserver\n    };\n    const handler = handlers[type] || createProxyAndListen;\n    proxies[type] = handler(chart, type, listener);\n  }\n  removeEventListener(chart, type) {\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const proxy = proxies[type];\n    if (!proxy) {\n      return;\n    }\n    const handlers = {\n      attach: releaseObserver,\n      detach: releaseObserver,\n      resize: releaseObserver\n    };\n    const handler = handlers[type] || removeListener;\n    handler(chart, type, proxy);\n    proxies[type] = undefined;\n  }\n  getDevicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n  getMaximumSize(canvas, width, height, aspectRatio) {\n    return getMaximumSize(canvas, width, height, aspectRatio);\n  }\n  isAttached(canvas) {\n    const container = _getParentNode(canvas);\n    return !!(container && container.isConnected);\n  }\n}\n\nfunction _detectPlatform(canvas) {\n  if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n    return BasicPlatform;\n  }\n  return DomPlatform;\n}\n\nclass PluginService {\n  constructor() {\n    this._init = [];\n  }\n  notify(chart, hook, args, filter) {\n    if (hook === 'beforeInit') {\n      this._init = this._createDescriptors(chart, true);\n      this._notify(this._init, chart, 'install');\n    }\n    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n    const result = this._notify(descriptors, chart, hook, args);\n    if (hook === 'afterDestroy') {\n      this._notify(descriptors, chart, 'stop');\n      this._notify(this._init, chart, 'uninstall');\n    }\n    return result;\n  }\n  _notify(descriptors, chart, hook, args) {\n    args = args || {};\n    for (const descriptor of descriptors) {\n      const plugin = descriptor.plugin;\n      const method = plugin[hook];\n      const params = [chart, args, descriptor.options];\n      if (callback(method, params, plugin) === false && args.cancelable) {\n        return false;\n      }\n    }\n    return true;\n  }\n  invalidate() {\n    if (!isNullOrUndef(this._cache)) {\n      this._oldCache = this._cache;\n      this._cache = undefined;\n    }\n  }\n  _descriptors(chart) {\n    if (this._cache) {\n      return this._cache;\n    }\n    const descriptors = this._cache = this._createDescriptors(chart);\n    this._notifyStateChanges(chart);\n    return descriptors;\n  }\n  _createDescriptors(chart, all) {\n    const config = chart && chart.config;\n    const options = valueOrDefault(config.options && config.options.plugins, {});\n    const plugins = allPlugins(config);\n    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n  }\n  _notifyStateChanges(chart) {\n    const previousDescriptors = this._oldCache || [];\n    const descriptors = this._cache;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\n    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n  }\n}\nfunction allPlugins(config) {\n  const localIds = {};\n  const plugins = [];\n  const keys = Object.keys(registry.plugins.items);\n  for (let i = 0; i < keys.length; i++) {\n    plugins.push(registry.getPlugin(keys[i]));\n  }\n  const local = config.plugins || [];\n  for (let i = 0; i < local.length; i++) {\n    const plugin = local[i];\n    if (plugins.indexOf(plugin) === -1) {\n      plugins.push(plugin);\n      localIds[plugin.id] = true;\n    }\n  }\n  return {plugins, localIds};\n}\nfunction getOpts(options, all) {\n  if (!all && options === false) {\n    return null;\n  }\n  if (options === true) {\n    return {};\n  }\n  return options;\n}\nfunction createDescriptors(chart, {plugins, localIds}, options, all) {\n  const result = [];\n  const context = chart.getContext();\n  for (const plugin of plugins) {\n    const id = plugin.id;\n    const opts = getOpts(options[id], all);\n    if (opts === null) {\n      continue;\n    }\n    result.push({\n      plugin,\n      options: pluginOpts(chart.config, {plugin, local: localIds[id]}, opts, context)\n    });\n  }\n  return result;\n}\nfunction pluginOpts(config, {plugin, local}, opts, context) {\n  const keys = config.pluginScopeKeys(plugin);\n  const scopes = config.getOptionScopes(opts, keys);\n  if (local && plugin.defaults) {\n    scopes.push(plugin.defaults);\n  }\n  return config.createResolver(scopes, context, [''], {\n    scriptable: false,\n    indexable: false,\n    allKeys: true\n  });\n}\n\nfunction getIndexAxis(type, options) {\n  const datasetDefaults = defaults.datasets[type] || {};\n  const datasetOptions = (options.datasets || {})[type] || {};\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n  let axis = id;\n  if (id === '_index_') {\n    axis = indexAxis;\n  } else if (id === '_value_') {\n    axis = indexAxis === 'x' ? 'y' : 'x';\n  }\n  return axis;\n}\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n  return axis === indexAxis ? '_index_' : '_value_';\n}\nfunction axisFromPosition(position) {\n  if (position === 'top' || position === 'bottom') {\n    return 'x';\n  }\n  if (position === 'left' || position === 'right') {\n    return 'y';\n  }\n}\nfunction determineAxis(id, scaleOptions) {\n  if (id === 'x' || id === 'y') {\n    return id;\n  }\n  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();\n}\nfunction mergeScaleConfig(config, options) {\n  const chartDefaults = overrides[config.type] || {scales: {}};\n  const configScales = options.scales || {};\n  const chartIndexAxis = getIndexAxis(config.type, options);\n  const firstIDs = Object.create(null);\n  const scales = Object.create(null);\n  Object.keys(configScales).forEach(id => {\n    const scaleConf = configScales[id];\n    if (!isObject(scaleConf)) {\n      return console.error(`Invalid scale configuration for scale: ${id}`);\n    }\n    if (scaleConf._proxy) {\n      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n    }\n    const axis = determineAxis(id, scaleConf);\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n    const defaultScaleOptions = chartDefaults.scales || {};\n    firstIDs[axis] = firstIDs[axis] || id;\n    scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\n  });\n  config.data.datasets.forEach(dataset => {\n    const type = dataset.type || config.type;\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n    const datasetDefaults = overrides[type] || {};\n    const defaultScaleOptions = datasetDefaults.scales || {};\n    Object.keys(defaultScaleOptions).forEach(defaultID => {\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n      const id = dataset[axis + 'AxisID'] || firstIDs[axis] || axis;\n      scales[id] = scales[id] || Object.create(null);\n      mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\n    });\n  });\n  Object.keys(scales).forEach(key => {\n    const scale = scales[key];\n    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\n  });\n  return scales;\n}\nfunction initOptions(config) {\n  const options = config.options || (config.options = {});\n  options.plugins = valueOrDefault(options.plugins, {});\n  options.scales = mergeScaleConfig(config, options);\n}\nfunction initData(data) {\n  data = data || {};\n  data.datasets = data.datasets || [];\n  data.labels = data.labels || [];\n  return data;\n}\nfunction initConfig(config) {\n  config = config || {};\n  config.data = initData(config.data);\n  initOptions(config);\n  return config;\n}\nconst keyCache = new Map();\nconst keysCached = new Set();\nfunction cachedKeys(cacheKey, generate) {\n  let keys = keyCache.get(cacheKey);\n  if (!keys) {\n    keys = generate();\n    keyCache.set(cacheKey, keys);\n    keysCached.add(keys);\n  }\n  return keys;\n}\nconst addIfFound = (set, obj, key) => {\n  const opts = resolveObjectKey(obj, key);\n  if (opts !== undefined) {\n    set.add(opts);\n  }\n};\nclass Config {\n  constructor(config) {\n    this._config = initConfig(config);\n    this._scopeCache = new Map();\n    this._resolverCache = new Map();\n  }\n  get platform() {\n    return this._config.platform;\n  }\n  get type() {\n    return this._config.type;\n  }\n  set type(type) {\n    this._config.type = type;\n  }\n  get data() {\n    return this._config.data;\n  }\n  set data(data) {\n    this._config.data = initData(data);\n  }\n  get options() {\n    return this._config.options;\n  }\n  set options(options) {\n    this._config.options = options;\n  }\n  get plugins() {\n    return this._config.plugins;\n  }\n  update() {\n    const config = this._config;\n    this.clearCache();\n    initOptions(config);\n  }\n  clearCache() {\n    this._scopeCache.clear();\n    this._resolverCache.clear();\n  }\n  datasetScopeKeys(datasetType) {\n    return cachedKeys(datasetType,\n      () => [[\n        `datasets.${datasetType}`,\n        ''\n      ]]);\n  }\n  datasetAnimationScopeKeys(datasetType, transition) {\n    return cachedKeys(`${datasetType}.transition.${transition}`,\n      () => [\n        [\n          `datasets.${datasetType}.transitions.${transition}`,\n          `transitions.${transition}`,\n        ],\n        [\n          `datasets.${datasetType}`,\n          ''\n        ]\n      ]);\n  }\n  datasetElementScopeKeys(datasetType, elementType) {\n    return cachedKeys(`${datasetType}-${elementType}`,\n      () => [[\n        `datasets.${datasetType}.elements.${elementType}`,\n        `datasets.${datasetType}`,\n        `elements.${elementType}`,\n        ''\n      ]]);\n  }\n  pluginScopeKeys(plugin) {\n    const id = plugin.id;\n    const type = this.type;\n    return cachedKeys(`${type}-plugin-${id}`,\n      () => [[\n        `plugins.${id}`,\n        ...plugin.additionalOptionScopes || [],\n      ]]);\n  }\n  _cachedScopes(mainScope, resetCache) {\n    const _scopeCache = this._scopeCache;\n    let cache = _scopeCache.get(mainScope);\n    if (!cache || resetCache) {\n      cache = new Map();\n      _scopeCache.set(mainScope, cache);\n    }\n    return cache;\n  }\n  getOptionScopes(mainScope, keyLists, resetCache) {\n    const {options, type} = this;\n    const cache = this._cachedScopes(mainScope, resetCache);\n    const cached = cache.get(keyLists);\n    if (cached) {\n      return cached;\n    }\n    const scopes = new Set();\n    keyLists.forEach(keys => {\n      if (mainScope) {\n        scopes.add(mainScope);\n        keys.forEach(key => addIfFound(scopes, mainScope, key));\n      }\n      keys.forEach(key => addIfFound(scopes, options, key));\n      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\n      keys.forEach(key => addIfFound(scopes, defaults, key));\n      keys.forEach(key => addIfFound(scopes, descriptors, key));\n    });\n    const array = Array.from(scopes);\n    if (array.length === 0) {\n      array.push(Object.create(null));\n    }\n    if (keysCached.has(keyLists)) {\n      cache.set(keyLists, array);\n    }\n    return array;\n  }\n  chartOptionScopes() {\n    const {options, type} = this;\n    return [\n      options,\n      overrides[type] || {},\n      defaults.datasets[type] || {},\n      {type},\n      defaults,\n      descriptors\n    ];\n  }\n  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\n    const result = {$shared: true};\n    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\n    let options = resolver;\n    if (needContext(resolver, names)) {\n      result.$shared = false;\n      context = isFunction(context) ? context() : context;\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\n      options = _attachContext(resolver, context, subResolver);\n    }\n    for (const prop of names) {\n      result[prop] = options[prop];\n    }\n    return result;\n  }\n  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\n    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\n    return isObject(context)\n      ? _attachContext(resolver, context, undefined, descriptorDefaults)\n      : resolver;\n  }\n}\nfunction getResolver(resolverCache, scopes, prefixes) {\n  let cache = resolverCache.get(scopes);\n  if (!cache) {\n    cache = new Map();\n    resolverCache.set(scopes, cache);\n  }\n  const cacheKey = prefixes.join();\n  let cached = cache.get(cacheKey);\n  if (!cached) {\n    const resolver = _createResolver(scopes, prefixes);\n    cached = {\n      resolver,\n      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\n    };\n    cache.set(cacheKey, cached);\n  }\n  return cached;\n}\nconst hasFunction = value => isObject(value)\n  && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);\nfunction needContext(proxy, names) {\n  const {isScriptable, isIndexable} = _descriptors(proxy);\n  for (const prop of names) {\n    const scriptable = isScriptable(prop);\n    const indexable = isIndexable(prop);\n    const value = (indexable || scriptable) && proxy[prop];\n    if ((scriptable && (isFunction(value) || hasFunction(value)))\n      || (indexable && isArray(value))) {\n      return true;\n    }\n  }\n  return false;\n}\n\nvar version = \"3.9.1\";\n\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\nfunction positionIsHorizontal(position, axis) {\n  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\n}\nfunction compare2Level(l1, l2) {\n  return function(a, b) {\n    return a[l1] === b[l1]\n      ? a[l2] - b[l2]\n      : a[l1] - b[l1];\n  };\n}\nfunction onAnimationsComplete(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  chart.notifyPlugins('afterRender');\n  callback(animationOptions && animationOptions.onComplete, [context], chart);\n}\nfunction onAnimationProgress(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  callback(animationOptions && animationOptions.onProgress, [context], chart);\n}\nfunction getCanvas(item) {\n  if (_isDomSupported() && typeof item === 'string') {\n    item = document.getElementById(item);\n  } else if (item && item.length) {\n    item = item[0];\n  }\n  if (item && item.canvas) {\n    item = item.canvas;\n  }\n  return item;\n}\nconst instances = {};\nconst getChart = (key) => {\n  const canvas = getCanvas(key);\n  return Object.values(instances).filter((c) => c.canvas === canvas).pop();\n};\nfunction moveNumericKeys(obj, start, move) {\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    const intKey = +key;\n    if (intKey >= start) {\n      const value = obj[key];\n      delete obj[key];\n      if (move > 0 || intKey > start) {\n        obj[intKey + move] = value;\n      }\n    }\n  }\n}\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n  if (!inChartArea || e.type === 'mouseout') {\n    return null;\n  }\n  if (isClick) {\n    return lastEvent;\n  }\n  return e;\n}\nclass Chart {\n  constructor(item, userConfig) {\n    const config = this.config = new Config(userConfig);\n    const initialCanvas = getCanvas(item);\n    const existingChart = getChart(initialCanvas);\n    if (existingChart) {\n      throw new Error(\n        'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\n\t\t\t\t' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.'\n      );\n    }\n    const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n    this.platform.updateConfig(config);\n    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n    const canvas = context && context.canvas;\n    const height = canvas && canvas.height;\n    const width = canvas && canvas.width;\n    this.id = uid();\n    this.ctx = context;\n    this.canvas = canvas;\n    this.width = width;\n    this.height = height;\n    this._options = options;\n    this._aspectRatio = this.aspectRatio;\n    this._layers = [];\n    this._metasets = [];\n    this._stacks = undefined;\n    this.boxes = [];\n    this.currentDevicePixelRatio = undefined;\n    this.chartArea = undefined;\n    this._active = [];\n    this._lastEvent = undefined;\n    this._listeners = {};\n    this._responsiveListeners = undefined;\n    this._sortedMetasets = [];\n    this.scales = {};\n    this._plugins = new PluginService();\n    this.$proxies = {};\n    this._hiddenIndices = {};\n    this.attached = false;\n    this._animationsDisabled = undefined;\n    this.$context = undefined;\n    this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);\n    this._dataChanges = [];\n    instances[this.id] = this;\n    if (!context || !canvas) {\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n    animator.listen(this, 'complete', onAnimationsComplete);\n    animator.listen(this, 'progress', onAnimationProgress);\n    this._initialize();\n    if (this.attached) {\n      this.update();\n    }\n  }\n  get aspectRatio() {\n    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\n    if (!isNullOrUndef(aspectRatio)) {\n      return aspectRatio;\n    }\n    if (maintainAspectRatio && _aspectRatio) {\n      return _aspectRatio;\n    }\n    return height ? width / height : null;\n  }\n  get data() {\n    return this.config.data;\n  }\n  set data(data) {\n    this.config.data = data;\n  }\n  get options() {\n    return this._options;\n  }\n  set options(options) {\n    this.config.options = options;\n  }\n  _initialize() {\n    this.notifyPlugins('beforeInit');\n    if (this.options.responsive) {\n      this.resize();\n    } else {\n      retinaScale(this, this.options.devicePixelRatio);\n    }\n    this.bindEvents();\n    this.notifyPlugins('afterInit');\n    return this;\n  }\n  clear() {\n    clearCanvas(this.canvas, this.ctx);\n    return this;\n  }\n  stop() {\n    animator.stop(this);\n    return this;\n  }\n  resize(width, height) {\n    if (!animator.running(this)) {\n      this._resize(width, height);\n    } else {\n      this._resizeBeforeDraw = {width, height};\n    }\n  }\n  _resize(width, height) {\n    const options = this.options;\n    const canvas = this.canvas;\n    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n    const mode = this.width ? 'resize' : 'attach';\n    this.width = newSize.width;\n    this.height = newSize.height;\n    this._aspectRatio = this.aspectRatio;\n    if (!retinaScale(this, newRatio, true)) {\n      return;\n    }\n    this.notifyPlugins('resize', {size: newSize});\n    callback(options.onResize, [this, newSize], this);\n    if (this.attached) {\n      if (this._doResize(mode)) {\n        this.render();\n      }\n    }\n  }\n  ensureScalesHaveIDs() {\n    const options = this.options;\n    const scalesOptions = options.scales || {};\n    each(scalesOptions, (axisOptions, axisID) => {\n      axisOptions.id = axisID;\n    });\n  }\n  buildOrUpdateScales() {\n    const options = this.options;\n    const scaleOpts = options.scales;\n    const scales = this.scales;\n    const updated = Object.keys(scales).reduce((obj, id) => {\n      obj[id] = false;\n      return obj;\n    }, {});\n    let items = [];\n    if (scaleOpts) {\n      items = items.concat(\n        Object.keys(scaleOpts).map((id) => {\n          const scaleOptions = scaleOpts[id];\n          const axis = determineAxis(id, scaleOptions);\n          const isRadial = axis === 'r';\n          const isHorizontal = axis === 'x';\n          return {\n            options: scaleOptions,\n            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n          };\n        })\n      );\n    }\n    each(items, (item) => {\n      const scaleOptions = item.options;\n      const id = scaleOptions.id;\n      const axis = determineAxis(id, scaleOptions);\n      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n        scaleOptions.position = item.dposition;\n      }\n      updated[id] = true;\n      let scale = null;\n      if (id in scales && scales[id].type === scaleType) {\n        scale = scales[id];\n      } else {\n        const scaleClass = registry.getScale(scaleType);\n        scale = new scaleClass({\n          id,\n          type: scaleType,\n          ctx: this.ctx,\n          chart: this\n        });\n        scales[scale.id] = scale;\n      }\n      scale.init(scaleOptions, options);\n    });\n    each(updated, (hasUpdated, id) => {\n      if (!hasUpdated) {\n        delete scales[id];\n      }\n    });\n    each(scales, (scale) => {\n      layouts.configure(this, scale, scale.options);\n      layouts.addBox(this, scale);\n    });\n  }\n  _updateMetasets() {\n    const metasets = this._metasets;\n    const numData = this.data.datasets.length;\n    const numMeta = metasets.length;\n    metasets.sort((a, b) => a.index - b.index);\n    if (numMeta > numData) {\n      for (let i = numData; i < numMeta; ++i) {\n        this._destroyDatasetMeta(i);\n      }\n      metasets.splice(numData, numMeta - numData);\n    }\n    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n  }\n  _removeUnreferencedMetasets() {\n    const {_metasets: metasets, data: {datasets}} = this;\n    if (metasets.length > datasets.length) {\n      delete this._stacks;\n    }\n    metasets.forEach((meta, index) => {\n      if (datasets.filter(x => x === meta._dataset).length === 0) {\n        this._destroyDatasetMeta(index);\n      }\n    });\n  }\n  buildOrUpdateControllers() {\n    const newControllers = [];\n    const datasets = this.data.datasets;\n    let i, ilen;\n    this._removeUnreferencedMetasets();\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\n      const dataset = datasets[i];\n      let meta = this.getDatasetMeta(i);\n      const type = dataset.type || this.config.type;\n      if (meta.type && meta.type !== type) {\n        this._destroyDatasetMeta(i);\n        meta = this.getDatasetMeta(i);\n      }\n      meta.type = type;\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n      meta.order = dataset.order || 0;\n      meta.index = i;\n      meta.label = '' + dataset.label;\n      meta.visible = this.isDatasetVisible(i);\n      if (meta.controller) {\n        meta.controller.updateIndex(i);\n        meta.controller.linkScales();\n      } else {\n        const ControllerClass = registry.getController(type);\n        const {datasetElementType, dataElementType} = defaults.datasets[type];\n        Object.assign(ControllerClass.prototype, {\n          dataElementType: registry.getElement(dataElementType),\n          datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n        });\n        meta.controller = new ControllerClass(this, i);\n        newControllers.push(meta.controller);\n      }\n    }\n    this._updateMetasets();\n    return newControllers;\n  }\n  _resetElements() {\n    each(this.data.datasets, (dataset, datasetIndex) => {\n      this.getDatasetMeta(datasetIndex).controller.reset();\n    }, this);\n  }\n  reset() {\n    this._resetElements();\n    this.notifyPlugins('reset');\n  }\n  update(mode) {\n    const config = this.config;\n    config.update();\n    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    const animsDisabled = this._animationsDisabled = !options.animation;\n    this._updateScales();\n    this._checkEventBindings();\n    this._updateHiddenIndices();\n    this._plugins.invalidate();\n    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n    const newControllers = this.buildOrUpdateControllers();\n    this.notifyPlugins('beforeElementsUpdate');\n    let minPadding = 0;\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {\n      const {controller} = this.getDatasetMeta(i);\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n      controller.buildOrUpdateElements(reset);\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n    }\n    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n    this._updateLayout(minPadding);\n    if (!animsDisabled) {\n      each(newControllers, (controller) => {\n        controller.reset();\n      });\n    }\n    this._updateDatasets(mode);\n    this.notifyPlugins('afterUpdate', {mode});\n    this._layers.sort(compare2Level('z', '_idx'));\n    const {_active, _lastEvent} = this;\n    if (_lastEvent) {\n      this._eventHandler(_lastEvent, true);\n    } else if (_active.length) {\n      this._updateHoverStyles(_active, _active, true);\n    }\n    this.render();\n  }\n  _updateScales() {\n    each(this.scales, (scale) => {\n      layouts.removeBox(this, scale);\n    });\n    this.ensureScalesHaveIDs();\n    this.buildOrUpdateScales();\n  }\n  _checkEventBindings() {\n    const options = this.options;\n    const existingEvents = new Set(Object.keys(this._listeners));\n    const newEvents = new Set(options.events);\n    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n      this.unbindEvents();\n      this.bindEvents();\n    }\n  }\n  _updateHiddenIndices() {\n    const {_hiddenIndices} = this;\n    const changes = this._getUniformDataChanges() || [];\n    for (const {method, start, count} of changes) {\n      const move = method === '_removeElements' ? -count : count;\n      moveNumericKeys(_hiddenIndices, start, move);\n    }\n  }\n  _getUniformDataChanges() {\n    const _dataChanges = this._dataChanges;\n    if (!_dataChanges || !_dataChanges.length) {\n      return;\n    }\n    this._dataChanges = [];\n    const datasetCount = this.data.datasets.length;\n    const makeSet = (idx) => new Set(\n      _dataChanges\n        .filter(c => c[0] === idx)\n        .map((c, i) => i + ',' + c.splice(1).join(','))\n    );\n    const changeSet = makeSet(0);\n    for (let i = 1; i < datasetCount; i++) {\n      if (!setsEqual(changeSet, makeSet(i))) {\n        return;\n      }\n    }\n    return Array.from(changeSet)\n      .map(c => c.split(','))\n      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));\n  }\n  _updateLayout(minPadding) {\n    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\n      return;\n    }\n    layouts.update(this, this.width, this.height, minPadding);\n    const area = this.chartArea;\n    const noArea = area.width <= 0 || area.height <= 0;\n    this._layers = [];\n    each(this.boxes, (box) => {\n      if (noArea && box.position === 'chartArea') {\n        return;\n      }\n      if (box.configure) {\n        box.configure();\n      }\n      this._layers.push(...box._layers());\n    }, this);\n    this._layers.forEach((item, index) => {\n      item._idx = index;\n    });\n    this.notifyPlugins('afterLayout');\n  }\n  _updateDatasets(mode) {\n    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this.getDatasetMeta(i).controller.configure();\n    }\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);\n    }\n    this.notifyPlugins('afterDatasetsUpdate', {mode});\n  }\n  _updateDataset(index, mode) {\n    const meta = this.getDatasetMeta(index);\n    const args = {meta, index, mode, cancelable: true};\n    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n      return;\n    }\n    meta.controller._update(mode);\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetUpdate', args);\n  }\n  render() {\n    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {\n      return;\n    }\n    if (animator.has(this)) {\n      if (this.attached && !animator.running(this)) {\n        animator.start(this);\n      }\n    } else {\n      this.draw();\n      onAnimationsComplete({chart: this});\n    }\n  }\n  draw() {\n    let i;\n    if (this._resizeBeforeDraw) {\n      const {width, height} = this._resizeBeforeDraw;\n      this._resize(width, height);\n      this._resizeBeforeDraw = null;\n    }\n    this.clear();\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\n      return;\n    }\n    const layers = this._layers;\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n    this._drawDatasets();\n    for (; i < layers.length; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n    this.notifyPlugins('afterDraw');\n  }\n  _getSortedDatasetMetas(filterVisible) {\n    const metasets = this._sortedMetasets;\n    const result = [];\n    let i, ilen;\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n      const meta = metasets[i];\n      if (!filterVisible || meta.visible) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n  getSortedVisibleDatasetMetas() {\n    return this._getSortedDatasetMetas(true);\n  }\n  _drawDatasets() {\n    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\n      return;\n    }\n    const metasets = this.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      this._drawDataset(metasets[i]);\n    }\n    this.notifyPlugins('afterDatasetsDraw');\n  }\n  _drawDataset(meta) {\n    const ctx = this.ctx;\n    const clip = meta._clip;\n    const useClip = !clip.disabled;\n    const area = this.chartArea;\n    const args = {\n      meta,\n      index: meta.index,\n      cancelable: true\n    };\n    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n      return;\n    }\n    if (useClip) {\n      clipArea(ctx, {\n        left: clip.left === false ? 0 : area.left - clip.left,\n        right: clip.right === false ? this.width : area.right + clip.right,\n        top: clip.top === false ? 0 : area.top - clip.top,\n        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\n      });\n    }\n    meta.controller.draw();\n    if (useClip) {\n      unclipArea(ctx);\n    }\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetDraw', args);\n  }\n  isPointInArea(point) {\n    return _isPointInArea(point, this.chartArea, this._minPadding);\n  }\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n    const method = Interaction.modes[mode];\n    if (typeof method === 'function') {\n      return method(this, e, options, useFinalPosition);\n    }\n    return [];\n  }\n  getDatasetMeta(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    const metasets = this._metasets;\n    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\n    if (!meta) {\n      meta = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\n        xAxisID: null,\n        yAxisID: null,\n        order: dataset && dataset.order || 0,\n        index: datasetIndex,\n        _dataset: dataset,\n        _parsed: [],\n        _sorted: false\n      };\n      metasets.push(meta);\n    }\n    return meta;\n  }\n  getContext() {\n    return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));\n  }\n  getVisibleDatasetCount() {\n    return this.getSortedVisibleDatasetMetas().length;\n  }\n  isDatasetVisible(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    if (!dataset) {\n      return false;\n    }\n    const meta = this.getDatasetMeta(datasetIndex);\n    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n  }\n  setDatasetVisibility(datasetIndex, visible) {\n    const meta = this.getDatasetMeta(datasetIndex);\n    meta.hidden = !visible;\n  }\n  toggleDataVisibility(index) {\n    this._hiddenIndices[index] = !this._hiddenIndices[index];\n  }\n  getDataVisibility(index) {\n    return !this._hiddenIndices[index];\n  }\n  _updateVisibility(datasetIndex, dataIndex, visible) {\n    const mode = visible ? 'show' : 'hide';\n    const meta = this.getDatasetMeta(datasetIndex);\n    const anims = meta.controller._resolveAnimations(undefined, mode);\n    if (defined(dataIndex)) {\n      meta.data[dataIndex].hidden = !visible;\n      this.update();\n    } else {\n      this.setDatasetVisibility(datasetIndex, visible);\n      anims.update(meta, {visible});\n      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\n    }\n  }\n  hide(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, false);\n  }\n  show(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, true);\n  }\n  _destroyDatasetMeta(datasetIndex) {\n    const meta = this._metasets[datasetIndex];\n    if (meta && meta.controller) {\n      meta.controller._destroy();\n    }\n    delete this._metasets[datasetIndex];\n  }\n  _stop() {\n    let i, ilen;\n    this.stop();\n    animator.remove(this);\n    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._destroyDatasetMeta(i);\n    }\n  }\n  destroy() {\n    this.notifyPlugins('beforeDestroy');\n    const {canvas, ctx} = this;\n    this._stop();\n    this.config.clearCache();\n    if (canvas) {\n      this.unbindEvents();\n      clearCanvas(canvas, ctx);\n      this.platform.releaseContext(ctx);\n      this.canvas = null;\n      this.ctx = null;\n    }\n    this.notifyPlugins('destroy');\n    delete instances[this.id];\n    this.notifyPlugins('afterDestroy');\n  }\n  toBase64Image(...args) {\n    return this.canvas.toDataURL(...args);\n  }\n  bindEvents() {\n    this.bindUserEvents();\n    if (this.options.responsive) {\n      this.bindResponsiveEvents();\n    } else {\n      this.attached = true;\n    }\n  }\n  bindUserEvents() {\n    const listeners = this._listeners;\n    const platform = this.platform;\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const listener = (e, x, y) => {\n      e.offsetX = x;\n      e.offsetY = y;\n      this._eventHandler(e);\n    };\n    each(this.options.events, (type) => _add(type, listener));\n  }\n  bindResponsiveEvents() {\n    if (!this._responsiveListeners) {\n      this._responsiveListeners = {};\n    }\n    const listeners = this._responsiveListeners;\n    const platform = this.platform;\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const _remove = (type, listener) => {\n      if (listeners[type]) {\n        platform.removeEventListener(this, type, listener);\n        delete listeners[type];\n      }\n    };\n    const listener = (width, height) => {\n      if (this.canvas) {\n        this.resize(width, height);\n      }\n    };\n    let detached;\n    const attached = () => {\n      _remove('attach', attached);\n      this.attached = true;\n      this.resize();\n      _add('resize', listener);\n      _add('detach', detached);\n    };\n    detached = () => {\n      this.attached = false;\n      _remove('resize', listener);\n      this._stop();\n      this._resize(0, 0);\n      _add('attach', attached);\n    };\n    if (platform.isAttached(this.canvas)) {\n      attached();\n    } else {\n      detached();\n    }\n  }\n  unbindEvents() {\n    each(this._listeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._listeners = {};\n    each(this._responsiveListeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._responsiveListeners = undefined;\n  }\n  updateHoverStyle(items, mode, enabled) {\n    const prefix = enabled ? 'set' : 'remove';\n    let meta, item, i, ilen;\n    if (mode === 'dataset') {\n      meta = this.getDatasetMeta(items[0].datasetIndex);\n      meta.controller['_' + prefix + 'DatasetHoverStyle']();\n    }\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      item = items[i];\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n      if (controller) {\n        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n      }\n    }\n  }\n  getActiveElements() {\n    return this._active || [];\n  }\n  setActiveElements(activeElements) {\n    const lastActive = this._active || [];\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('No dataset found at index ' + datasetIndex);\n      }\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(active, lastActive);\n    if (changed) {\n      this._active = active;\n      this._lastEvent = null;\n      this._updateHoverStyles(active, lastActive);\n    }\n  }\n  notifyPlugins(hook, args, filter) {\n    return this._plugins.notify(this, hook, args, filter);\n  }\n  _updateHoverStyles(active, lastActive, replay) {\n    const hoverOptions = this.options.hover;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\n    const deactivated = diff(lastActive, active);\n    const activated = replay ? active : diff(active, lastActive);\n    if (deactivated.length) {\n      this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n    }\n    if (activated.length && hoverOptions.mode) {\n      this.updateHoverStyle(activated, hoverOptions.mode, true);\n    }\n  }\n  _eventHandler(e, replay) {\n    const args = {\n      event: e,\n      replay,\n      cancelable: true,\n      inChartArea: this.isPointInArea(e)\n    };\n    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);\n    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n      return;\n    }\n    const changed = this._handleEvent(e, replay, args.inChartArea);\n    args.cancelable = false;\n    this.notifyPlugins('afterEvent', args, eventFilter);\n    if (changed || args.changed) {\n      this.render();\n    }\n    return this;\n  }\n  _handleEvent(e, replay, inChartArea) {\n    const {_active: lastActive = [], options} = this;\n    const useFinalPosition = replay;\n    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n    const isClick = _isClickEvent(e);\n    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n    if (inChartArea) {\n      this._lastEvent = null;\n      callback(options.onHover, [e, active, this], this);\n      if (isClick) {\n        callback(options.onClick, [e, active, this], this);\n      }\n    }\n    const changed = !_elementsEqual(active, lastActive);\n    if (changed || replay) {\n      this._active = active;\n      this._updateHoverStyles(active, lastActive, replay);\n    }\n    this._lastEvent = lastEvent;\n    return changed;\n  }\n  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n    if (e.type === 'mouseout') {\n      return [];\n    }\n    if (!inChartArea) {\n      return lastActive;\n    }\n    const hoverOptions = this.options.hover;\n    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n  }\n}\nconst invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());\nconst enumerable = true;\nObject.defineProperties(Chart, {\n  defaults: {\n    enumerable,\n    value: defaults\n  },\n  instances: {\n    enumerable,\n    value: instances\n  },\n  overrides: {\n    enumerable,\n    value: overrides\n  },\n  registry: {\n    enumerable,\n    value: registry\n  },\n  version: {\n    enumerable,\n    value: version\n  },\n  getChart: {\n    enumerable,\n    value: getChart\n  },\n  register: {\n    enumerable,\n    value: (...items) => {\n      registry.add(...items);\n      invalidatePlugins();\n    }\n  },\n  unregister: {\n    enumerable,\n    value: (...items) => {\n      registry.remove(...items);\n      invalidatePlugins();\n    }\n  }\n});\n\nfunction clipArc(ctx, element, endAngle) {\n  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\n  let angleMargin = pixelMargin / outerRadius;\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n  if (innerRadius > pixelMargin) {\n    angleMargin = pixelMargin / innerRadius;\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n  } else {\n    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n  }\n  ctx.closePath();\n  ctx.clip();\n}\nfunction toRadiusCorners(value) {\n  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\n}\nfunction parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n  const o = toRadiusCorners(arc.options.borderRadius);\n  const halfThickness = (outerRadius - innerRadius) / 2;\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n  const computeOuterLimit = (val) => {\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n  };\n  return {\n    outerStart: computeOuterLimit(o.outerStart),\n    outerEnd: computeOuterLimit(o.outerEnd),\n    innerStart: _limitValue(o.innerStart, 0, innerLimit),\n    innerEnd: _limitValue(o.innerEnd, 0, innerLimit),\n  };\n}\nfunction rThetaToXY(r, theta, x, y) {\n  return {\n    x: x + r * Math.cos(theta),\n    y: y + r * Math.sin(theta),\n  };\n}\nfunction pathArc(ctx, element, offset, spacing, end, circular) {\n  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n  let spacingOffset = 0;\n  const alpha = end - start;\n  if (spacing) {\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;\n    spacingOffset = (alpha - adjustedAngle) / 2;\n  }\n  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n  const angleOffset = (alpha - beta) / 2;\n  const startAngle = start + angleOffset + spacingOffset;\n  const endAngle = end - angleOffset - spacingOffset;\n  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n  const outerStartAdjustedRadius = outerRadius - outerStart;\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n  const innerStartAdjustedRadius = innerRadius + innerStart;\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n  ctx.beginPath();\n  if (circular) {\n    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);\n    if (outerEnd > 0) {\n      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n    }\n    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n    ctx.lineTo(p4.x, p4.y);\n    if (innerEnd > 0) {\n      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n    }\n    ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), startAngle + (innerStart / innerRadius), true);\n    if (innerStart > 0) {\n      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n    }\n    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n    ctx.lineTo(p8.x, p8.y);\n    if (outerStart > 0) {\n      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n    }\n  } else {\n    ctx.moveTo(x, y);\n    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerStartX, outerStartY);\n    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerEndX, outerEndY);\n  }\n  ctx.closePath();\n}\nfunction drawArc(ctx, element, offset, spacing, circular) {\n  const {fullCircles, startAngle, circumference} = element;\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, startAngle + TAU, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.fill();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + circumference % TAU;\n      if (circumference % TAU === 0) {\n        endAngle += TAU;\n      }\n    }\n  }\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\n  ctx.fill();\n  return endAngle;\n}\nfunction drawFullCircleBorders(ctx, element, inner) {\n  const {x, y, startAngle, pixelMargin, fullCircles} = element;\n  const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);\n  const innerRadius = element.innerRadius + pixelMargin;\n  let i;\n  if (inner) {\n    clipArc(ctx, element, startAngle + TAU);\n  }\n  ctx.beginPath();\n  ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);\n  for (i = 0; i < fullCircles; ++i) {\n    ctx.stroke();\n  }\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);\n  for (i = 0; i < fullCircles; ++i) {\n    ctx.stroke();\n  }\n}\nfunction drawBorder(ctx, element, offset, spacing, endAngle, circular) {\n  const {options} = element;\n  const {borderWidth, borderJoinStyle} = options;\n  const inner = options.borderAlign === 'inner';\n  if (!borderWidth) {\n    return;\n  }\n  if (inner) {\n    ctx.lineWidth = borderWidth * 2;\n    ctx.lineJoin = borderJoinStyle || 'round';\n  } else {\n    ctx.lineWidth = borderWidth;\n    ctx.lineJoin = borderJoinStyle || 'bevel';\n  }\n  if (element.fullCircles) {\n    drawFullCircleBorders(ctx, element, inner);\n  }\n  if (inner) {\n    clipArc(ctx, element, endAngle);\n  }\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\n  ctx.stroke();\n}\nclass ArcElement extends Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.circumference = undefined;\n    this.startAngle = undefined;\n    this.endAngle = undefined;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.pixelMargin = 0;\n    this.fullCircles = 0;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  inRange(chartX, chartY, useFinalPosition) {\n    const point = this.getProps(['x', 'y'], useFinalPosition);\n    const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});\n    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference'\n    ], useFinalPosition);\n    const rAdjust = this.options.spacing / 2;\n    const _circumference = valueOrDefault(circumference, endAngle - startAngle);\n    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);\n    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n    return (betweenAngles && withinRadius);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\n      'x',\n      'y',\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference',\n    ], useFinalPosition);\n    const {offset, spacing} = this.options;\n    const halfAngle = (startAngle + endAngle) / 2;\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n    return {\n      x: x + Math.cos(halfAngle) * halfRadius,\n      y: y + Math.sin(halfAngle) * halfRadius\n    };\n  }\n  tooltipPosition(useFinalPosition) {\n    return this.getCenterPoint(useFinalPosition);\n  }\n  draw(ctx) {\n    const {options, circumference} = this;\n    const offset = (options.offset || 0) / 2;\n    const spacing = (options.spacing || 0) / 2;\n    const circular = options.circular;\n    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\n    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n      return;\n    }\n    ctx.save();\n    let radiusOffset = 0;\n    if (offset) {\n      radiusOffset = offset / 2;\n      const halfAngle = (this.startAngle + this.endAngle) / 2;\n      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);\n      if (this.circumference >= PI) {\n        radiusOffset = offset;\n      }\n    }\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    const endAngle = drawArc(ctx, this, radiusOffset, spacing, circular);\n    drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);\n    ctx.restore();\n  }\n}\nArcElement.id = 'arc';\nArcElement.defaults = {\n  borderAlign: 'center',\n  borderColor: '#fff',\n  borderJoinStyle: undefined,\n  borderRadius: 0,\n  borderWidth: 2,\n  offset: 0,\n  spacing: 0,\n  angle: undefined,\n  circular: true,\n};\nArcElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor'\n};\n\nfunction setStyle(ctx, options, style = options) {\n  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\nfunction lineTo(ctx, previous, target) {\n  ctx.lineTo(target.x, target.y);\n}\nfunction getLineMethod(options) {\n  if (options.stepped) {\n    return _steppedLineTo;\n  }\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierCurveTo;\n  }\n  return lineTo;\n}\nfunction pathVars(points, segment, params = {}) {\n  const count = points.length;\n  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;\n  const {start: segmentStart, end: segmentEnd} = segment;\n  const start = Math.max(paramsStart, segmentStart);\n  const end = Math.min(paramsEnd, segmentEnd);\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n  return {\n    count,\n    start,\n    loop: segment.loop,\n    ilen: end < start && !outside ? count + end - start : end - start\n  };\n}\nfunction pathSegment(ctx, line, segment, params) {\n  const {points, options} = line;\n  const {count, start, loop, ilen} = pathVars(points, segment, params);\n  const lineMethod = getLineMethod(options);\n  let {move = true, reverse} = params || {};\n  let i, point, prev;\n  for (i = 0; i <= ilen; ++i) {\n    point = points[(start + (reverse ? ilen - i : i)) % count];\n    if (point.skip) {\n      continue;\n    } else if (move) {\n      ctx.moveTo(point.x, point.y);\n      move = false;\n    } else {\n      lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n    prev = point;\n  }\n  if (loop) {\n    point = points[(start + (reverse ? ilen : 0)) % count];\n    lineMethod(ctx, prev, point, reverse, options.stepped);\n  }\n  return !!loop;\n}\nfunction fastPathSegment(ctx, line, segment, params) {\n  const points = line.points;\n  const {count, start, ilen} = pathVars(points, segment, params);\n  const {move = true, reverse} = params || {};\n  let avgX = 0;\n  let countX = 0;\n  let i, point, prevX, minY, maxY, lastY;\n  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\n  const drawX = () => {\n    if (minY !== maxY) {\n      ctx.lineTo(avgX, maxY);\n      ctx.lineTo(avgX, minY);\n      ctx.lineTo(avgX, lastY);\n    }\n  };\n  if (move) {\n    point = points[pointIndex(0)];\n    ctx.moveTo(point.x, point.y);\n  }\n  for (i = 0; i <= ilen; ++i) {\n    point = points[pointIndex(i)];\n    if (point.skip) {\n      continue;\n    }\n    const x = point.x;\n    const y = point.y;\n    const truncX = x | 0;\n    if (truncX === prevX) {\n      if (y < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n      avgX = (countX * avgX + x) / ++countX;\n    } else {\n      drawX();\n      ctx.lineTo(x, y);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n    }\n    lastY = y;\n  }\n  drawX();\n}\nfunction _getSegmentMethod(line) {\n  const opts = line.options;\n  const borderDash = opts.borderDash && opts.borderDash.length;\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n  return useFastPath ? fastPathSegment : pathSegment;\n}\nfunction _getInterpolationMethod(options) {\n  if (options.stepped) {\n    return _steppedInterpolation;\n  }\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierInterpolation;\n  }\n  return _pointInLine;\n}\nfunction strokePathWithCache(ctx, line, start, count) {\n  let path = line._path;\n  if (!path) {\n    path = line._path = new Path2D();\n    if (line.path(path, start, count)) {\n      path.closePath();\n    }\n  }\n  setStyle(ctx, line.options);\n  ctx.stroke(path);\n}\nfunction strokePathDirect(ctx, line, start, count) {\n  const {segments, options} = line;\n  const segmentMethod = _getSegmentMethod(line);\n  for (const segment of segments) {\n    setStyle(ctx, options, segment.style);\n    ctx.beginPath();\n    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {\n      ctx.closePath();\n    }\n    ctx.stroke();\n  }\n}\nconst usePath2D = typeof Path2D === 'function';\nfunction draw(ctx, line, start, count) {\n  if (usePath2D && !line.options.segment) {\n    strokePathWithCache(ctx, line, start, count);\n  } else {\n    strokePathDirect(ctx, line, start, count);\n  }\n}\nclass LineElement extends Element {\n  constructor(cfg) {\n    super();\n    this.animated = true;\n    this.options = undefined;\n    this._chart = undefined;\n    this._loop = undefined;\n    this._fullLoop = undefined;\n    this._path = undefined;\n    this._points = undefined;\n    this._segments = undefined;\n    this._decimated = false;\n    this._pointsUpdated = false;\n    this._datasetIndex = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  updateControlPoints(chartArea, indexAxis) {\n    const options = this.options;\n    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n      const loop = options.spanGaps ? this._loop : this._fullLoop;\n      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n      this._pointsUpdated = true;\n    }\n  }\n  set points(points) {\n    this._points = points;\n    delete this._segments;\n    delete this._path;\n    this._pointsUpdated = false;\n  }\n  get points() {\n    return this._points;\n  }\n  get segments() {\n    return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n  }\n  first() {\n    const segments = this.segments;\n    const points = this.points;\n    return segments.length && points[segments[0].start];\n  }\n  last() {\n    const segments = this.segments;\n    const points = this.points;\n    const count = segments.length;\n    return count && points[segments[count - 1].end];\n  }\n  interpolate(point, property) {\n    const options = this.options;\n    const value = point[property];\n    const points = this.points;\n    const segments = _boundSegments(this, {property, start: value, end: value});\n    if (!segments.length) {\n      return;\n    }\n    const result = [];\n    const _interpolate = _getInterpolationMethod(options);\n    let i, ilen;\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\n      const {start, end} = segments[i];\n      const p1 = points[start];\n      const p2 = points[end];\n      if (p1 === p2) {\n        result.push(p1);\n        continue;\n      }\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\n      interpolated[property] = point[property];\n      result.push(interpolated);\n    }\n    return result.length === 1 ? result[0] : result;\n  }\n  pathSegment(ctx, segment, params) {\n    const segmentMethod = _getSegmentMethod(this);\n    return segmentMethod(ctx, this, segment, params);\n  }\n  path(ctx, start, count) {\n    const segments = this.segments;\n    const segmentMethod = _getSegmentMethod(this);\n    let loop = this._loop;\n    start = start || 0;\n    count = count || (this.points.length - start);\n    for (const segment of segments) {\n      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});\n    }\n    return !!loop;\n  }\n  draw(ctx, chartArea, start, count) {\n    const options = this.options || {};\n    const points = this.points || [];\n    if (points.length && options.borderWidth) {\n      ctx.save();\n      draw(ctx, this, start, count);\n      ctx.restore();\n    }\n    if (this.animated) {\n      this._pointsUpdated = false;\n      this._path = undefined;\n    }\n  }\n}\nLineElement.id = 'line';\nLineElement.defaults = {\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderWidth: 3,\n  capBezierPoints: true,\n  cubicInterpolationMode: 'default',\n  fill: false,\n  spanGaps: false,\n  stepped: false,\n  tension: 0,\n};\nLineElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\nLineElement.descriptors = {\n  _scriptable: true,\n  _indexable: (name) => name !== 'borderDash' && name !== 'fill',\n};\n\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n  const options = el.options;\n  const {[axis]: value} = el.getProps([axis], useFinalPosition);\n  return (Math.abs(pos - value) < options.radius + options.hitRadius);\n}\nclass PointElement extends Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.parsed = undefined;\n    this.skip = undefined;\n    this.stop = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  inRange(mouseX, mouseY, useFinalPosition) {\n    const options = this.options;\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\n  }\n  inXRange(mouseX, useFinalPosition) {\n    return inRange$1(this, mouseX, 'x', useFinalPosition);\n  }\n  inYRange(mouseY, useFinalPosition) {\n    return inRange$1(this, mouseY, 'y', useFinalPosition);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n  size(options) {\n    options = options || this.options || {};\n    let radius = options.radius || 0;\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\n    const borderWidth = radius && options.borderWidth || 0;\n    return (radius + borderWidth) * 2;\n  }\n  draw(ctx, area) {\n    const options = this.options;\n    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\n      return;\n    }\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.fillStyle = options.backgroundColor;\n    drawPoint(ctx, options, this.x, this.y);\n  }\n  getRange() {\n    const options = this.options || {};\n    return options.radius + options.hitRadius;\n  }\n}\nPointElement.id = 'point';\nPointElement.defaults = {\n  borderWidth: 1,\n  hitRadius: 1,\n  hoverBorderWidth: 1,\n  hoverRadius: 4,\n  pointStyle: 'circle',\n  radius: 3,\n  rotation: 0\n};\nPointElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\n\nfunction getBarBounds(bar, useFinalPosition) {\n  const {x, y, base, width, height} = bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition);\n  let left, right, top, bottom, half;\n  if (bar.horizontal) {\n    half = height / 2;\n    left = Math.min(x, base);\n    right = Math.max(x, base);\n    top = y - half;\n    bottom = y + half;\n  } else {\n    half = width / 2;\n    left = x - half;\n    right = x + half;\n    top = Math.min(y, base);\n    bottom = Math.max(y, base);\n  }\n  return {left, top, right, bottom};\n}\nfunction skipOrLimit(skip, value, min, max) {\n  return skip ? 0 : _limitValue(value, min, max);\n}\nfunction parseBorderWidth(bar, maxW, maxH) {\n  const value = bar.options.borderWidth;\n  const skip = bar.borderSkipped;\n  const o = toTRBL(value);\n  return {\n    t: skipOrLimit(skip.top, o.top, 0, maxH),\n    r: skipOrLimit(skip.right, o.right, 0, maxW),\n    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n    l: skipOrLimit(skip.left, o.left, 0, maxW)\n  };\n}\nfunction parseBorderRadius(bar, maxW, maxH) {\n  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);\n  const value = bar.options.borderRadius;\n  const o = toTRBLCorners(value);\n  const maxR = Math.min(maxW, maxH);\n  const skip = bar.borderSkipped;\n  const enableBorder = enableBorderRadius || isObject(value);\n  return {\n    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n  };\n}\nfunction boundingRects(bar) {\n  const bounds = getBarBounds(bar);\n  const width = bounds.right - bounds.left;\n  const height = bounds.bottom - bounds.top;\n  const border = parseBorderWidth(bar, width / 2, height / 2);\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\n  return {\n    outer: {\n      x: bounds.left,\n      y: bounds.top,\n      w: width,\n      h: height,\n      radius\n    },\n    inner: {\n      x: bounds.left + border.l,\n      y: bounds.top + border.t,\n      w: width - border.l - border.r,\n      h: height - border.t - border.b,\n      radius: {\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\n      }\n    }\n  };\n}\nfunction inRange(bar, x, y, useFinalPosition) {\n  const skipX = x === null;\n  const skipY = y === null;\n  const skipBoth = skipX && skipY;\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n  return bounds\n\t\t&& (skipX || _isBetween(x, bounds.left, bounds.right))\n\t\t&& (skipY || _isBetween(y, bounds.top, bounds.bottom));\n}\nfunction hasRadius(radius) {\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\nfunction addNormalRectPath(ctx, rect) {\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\nfunction inflateRect(rect, amount, refRect = {}) {\n  const x = rect.x !== refRect.x ? -amount : 0;\n  const y = rect.y !== refRect.y ? -amount : 0;\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n  return {\n    x: rect.x + x,\n    y: rect.y + y,\n    w: rect.w + w,\n    h: rect.h + h,\n    radius: rect.radius\n  };\n}\nclass BarElement extends Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.horizontal = undefined;\n    this.base = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.inflateAmount = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  draw(ctx) {\n    const {inflateAmount, options: {borderColor, backgroundColor}} = this;\n    const {inner, outer} = boundingRects(this);\n    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n    ctx.save();\n    if (outer.w !== inner.w || outer.h !== inner.h) {\n      ctx.beginPath();\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n      ctx.clip();\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n      ctx.fillStyle = borderColor;\n      ctx.fill('evenodd');\n    }\n    ctx.beginPath();\n    addRectPath(ctx, inflateRect(inner, inflateAmount));\n    ctx.fillStyle = backgroundColor;\n    ctx.fill();\n    ctx.restore();\n  }\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return inRange(this, mouseX, mouseY, useFinalPosition);\n  }\n  inXRange(mouseX, useFinalPosition) {\n    return inRange(this, mouseX, null, useFinalPosition);\n  }\n  inYRange(mouseY, useFinalPosition) {\n    return inRange(this, null, mouseY, useFinalPosition);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {x, y, base, horizontal} = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);\n    return {\n      x: horizontal ? (x + base) / 2 : x,\n      y: horizontal ? y : (y + base) / 2\n    };\n  }\n  getRange(axis) {\n    return axis === 'x' ? this.width / 2 : this.height / 2;\n  }\n}\nBarElement.id = 'bar';\nBarElement.defaults = {\n  borderSkipped: 'start',\n  borderWidth: 0,\n  borderRadius: 0,\n  inflateAmount: 'auto',\n  pointStyle: undefined\n};\nBarElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\n\nvar elements = /*#__PURE__*/Object.freeze({\n__proto__: null,\nArcElement: ArcElement,\nLineElement: LineElement,\nPointElement: PointElement,\nBarElement: BarElement\n});\n\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n  const samples = options.samples || availableWidth;\n  if (samples >= count) {\n    return data.slice(start, start + count);\n  }\n  const decimated = [];\n  const bucketWidth = (count - 2) / (samples - 2);\n  let sampledIndex = 0;\n  const endIndex = start + count - 1;\n  let a = start;\n  let i, maxAreaPoint, maxArea, area, nextA;\n  decimated[sampledIndex++] = data[a];\n  for (i = 0; i < samples - 2; i++) {\n    let avgX = 0;\n    let avgY = 0;\n    let j;\n    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n    const avgRangeLength = avgRangeEnd - avgRangeStart;\n    for (j = avgRangeStart; j < avgRangeEnd; j++) {\n      avgX += data[j].x;\n      avgY += data[j].y;\n    }\n    avgX /= avgRangeLength;\n    avgY /= avgRangeLength;\n    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n    const {x: pointAx, y: pointAy} = data[a];\n    maxArea = area = -1;\n    for (j = rangeOffs; j < rangeTo; j++) {\n      area = 0.5 * Math.abs(\n        (pointAx - avgX) * (data[j].y - pointAy) -\n        (pointAx - data[j].x) * (avgY - pointAy)\n      );\n      if (area > maxArea) {\n        maxArea = area;\n        maxAreaPoint = data[j];\n        nextA = j;\n      }\n    }\n    decimated[sampledIndex++] = maxAreaPoint;\n    a = nextA;\n  }\n  decimated[sampledIndex++] = data[endIndex];\n  return decimated;\n}\nfunction minMaxDecimation(data, start, count, availableWidth) {\n  let avgX = 0;\n  let countX = 0;\n  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n  const decimated = [];\n  const endIndex = start + count - 1;\n  const xMin = data[start].x;\n  const xMax = data[endIndex].x;\n  const dx = xMax - xMin;\n  for (i = start; i < start + count; ++i) {\n    point = data[i];\n    x = (point.x - xMin) / dx * availableWidth;\n    y = point.y;\n    const truncX = x | 0;\n    if (truncX === prevX) {\n      if (y < minY) {\n        minY = y;\n        minIndex = i;\n      } else if (y > maxY) {\n        maxY = y;\n        maxIndex = i;\n      }\n      avgX = (countX * avgX + point.x) / ++countX;\n    } else {\n      const lastIndex = i - 1;\n      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\n        const intermediateIndex1 = Math.min(minIndex, maxIndex);\n        const intermediateIndex2 = Math.max(minIndex, maxIndex);\n        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex1],\n            x: avgX,\n          });\n        }\n        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex2],\n            x: avgX\n          });\n        }\n      }\n      if (i > 0 && lastIndex !== startIndex) {\n        decimated.push(data[lastIndex]);\n      }\n      decimated.push(point);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n      minIndex = maxIndex = startIndex = i;\n    }\n  }\n  return decimated;\n}\nfunction cleanDecimatedDataset(dataset) {\n  if (dataset._decimated) {\n    const data = dataset._data;\n    delete dataset._decimated;\n    delete dataset._data;\n    Object.defineProperty(dataset, 'data', {value: data});\n  }\n}\nfunction cleanDecimatedData(chart) {\n  chart.data.datasets.forEach((dataset) => {\n    cleanDecimatedDataset(dataset);\n  });\n}\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n  const pointCount = points.length;\n  let start = 0;\n  let count;\n  const {iScale} = meta;\n  const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n  if (minDefined) {\n    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\n  }\n  if (maxDefined) {\n    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n  } else {\n    count = pointCount - start;\n  }\n  return {start, count};\n}\nvar plugin_decimation = {\n  id: 'decimation',\n  defaults: {\n    algorithm: 'min-max',\n    enabled: false,\n  },\n  beforeElementsUpdate: (chart, args, options) => {\n    if (!options.enabled) {\n      cleanDecimatedData(chart);\n      return;\n    }\n    const availableWidth = chart.width;\n    chart.data.datasets.forEach((dataset, datasetIndex) => {\n      const {_data, indexAxis} = dataset;\n      const meta = chart.getDatasetMeta(datasetIndex);\n      const data = _data || dataset.data;\n      if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {\n        return;\n      }\n      if (!meta.controller.supportsDecimation) {\n        return;\n      }\n      const xAxis = chart.scales[meta.xAxisID];\n      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n        return;\n      }\n      if (chart.options.parsing) {\n        return;\n      }\n      let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);\n      const threshold = options.threshold || 4 * availableWidth;\n      if (count <= threshold) {\n        cleanDecimatedDataset(dataset);\n        return;\n      }\n      if (isNullOrUndef(_data)) {\n        dataset._data = data;\n        delete dataset.data;\n        Object.defineProperty(dataset, 'data', {\n          configurable: true,\n          enumerable: true,\n          get: function() {\n            return this._decimated;\n          },\n          set: function(d) {\n            this._data = d;\n          }\n        });\n      }\n      let decimated;\n      switch (options.algorithm) {\n      case 'lttb':\n        decimated = lttbDecimation(data, start, count, availableWidth, options);\n        break;\n      case 'min-max':\n        decimated = minMaxDecimation(data, start, count, availableWidth);\n        break;\n      default:\n        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n      }\n      dataset._decimated = decimated;\n    });\n  },\n  destroy(chart) {\n    cleanDecimatedData(chart);\n  }\n};\n\nfunction _segments(line, target, property) {\n  const segments = line.segments;\n  const points = line.points;\n  const tpoints = target.points;\n  const parts = [];\n  for (const segment of segments) {\n    let {start, end} = segment;\n    end = _findSegmentEnd(start, end, points);\n    const bounds = _getBounds(property, points[start], points[end], segment.loop);\n    if (!target.segments) {\n      parts.push({\n        source: segment,\n        target: bounds,\n        start: points[start],\n        end: points[end]\n      });\n      continue;\n    }\n    const targetSegments = _boundSegments(target, bounds);\n    for (const tgt of targetSegments) {\n      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n      const fillSources = _boundSegment(segment, points, subBounds);\n      for (const fillSource of fillSources) {\n        parts.push({\n          source: fillSource,\n          target: tgt,\n          start: {\n            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n          },\n          end: {\n            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n          }\n        });\n      }\n    }\n  }\n  return parts;\n}\nfunction _getBounds(property, first, last, loop) {\n  if (loop) {\n    return;\n  }\n  let start = first[property];\n  let end = last[property];\n  if (property === 'angle') {\n    start = _normalizeAngle(start);\n    end = _normalizeAngle(end);\n  }\n  return {property, start, end};\n}\nfunction _pointsFromSegments(boundary, line) {\n  const {x = null, y = null} = boundary || {};\n  const linePoints = line.points;\n  const points = [];\n  line.segments.forEach(({start, end}) => {\n    end = _findSegmentEnd(start, end, linePoints);\n    const first = linePoints[start];\n    const last = linePoints[end];\n    if (y !== null) {\n      points.push({x: first.x, y});\n      points.push({x: last.x, y});\n    } else if (x !== null) {\n      points.push({x, y: first.y});\n      points.push({x, y: last.y});\n    }\n  });\n  return points;\n}\nfunction _findSegmentEnd(start, end, points) {\n  for (;end > start; end--) {\n    const point = points[end];\n    if (!isNaN(point.x) && !isNaN(point.y)) {\n      break;\n    }\n  }\n  return end;\n}\nfunction _getEdge(a, b, prop, fn) {\n  if (a && b) {\n    return fn(a[prop], b[prop]);\n  }\n  return a ? a[prop] : b ? b[prop] : 0;\n}\n\nfunction _createBoundaryLine(boundary, line) {\n  let points = [];\n  let _loop = false;\n  if (isArray(boundary)) {\n    _loop = true;\n    points = boundary;\n  } else {\n    points = _pointsFromSegments(boundary, line);\n  }\n  return points.length ? new LineElement({\n    points,\n    options: {tension: 0},\n    _loop,\n    _fullLoop: _loop\n  }) : null;\n}\nfunction _shouldApplyFill(source) {\n  return source && source.fill !== false;\n}\n\nfunction _resolveTarget(sources, index, propagate) {\n  const source = sources[index];\n  let fill = source.fill;\n  const visited = [index];\n  let target;\n  if (!propagate) {\n    return fill;\n  }\n  while (fill !== false && visited.indexOf(fill) === -1) {\n    if (!isNumberFinite(fill)) {\n      return fill;\n    }\n    target = sources[fill];\n    if (!target) {\n      return false;\n    }\n    if (target.visible) {\n      return fill;\n    }\n    visited.push(fill);\n    fill = target.fill;\n  }\n  return false;\n}\nfunction _decodeFill(line, index, count) {\n  const fill = parseFillOption(line);\n  if (isObject(fill)) {\n    return isNaN(fill.value) ? false : fill;\n  }\n  let target = parseFloat(fill);\n  if (isNumberFinite(target) && Math.floor(target) === target) {\n    return decodeTargetIndex(fill[0], index, target, count);\n  }\n  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;\n}\nfunction decodeTargetIndex(firstCh, index, target, count) {\n  if (firstCh === '-' || firstCh === '+') {\n    target = index + target;\n  }\n  if (target === index || target < 0 || target >= count) {\n    return false;\n  }\n  return target;\n}\nfunction _getTargetPixel(fill, scale) {\n  let pixel = null;\n  if (fill === 'start') {\n    pixel = scale.bottom;\n  } else if (fill === 'end') {\n    pixel = scale.top;\n  } else if (isObject(fill)) {\n    pixel = scale.getPixelForValue(fill.value);\n  } else if (scale.getBasePixel) {\n    pixel = scale.getBasePixel();\n  }\n  return pixel;\n}\nfunction _getTargetValue(fill, scale, startValue) {\n  let value;\n  if (fill === 'start') {\n    value = startValue;\n  } else if (fill === 'end') {\n    value = scale.options.reverse ? scale.min : scale.max;\n  } else if (isObject(fill)) {\n    value = fill.value;\n  } else {\n    value = scale.getBaseValue();\n  }\n  return value;\n}\nfunction parseFillOption(line) {\n  const options = line.options;\n  const fillOption = options.fill;\n  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\n  if (fill === undefined) {\n    fill = !!options.backgroundColor;\n  }\n  if (fill === false || fill === null) {\n    return false;\n  }\n  if (fill === true) {\n    return 'origin';\n  }\n  return fill;\n}\n\nfunction _buildStackLine(source) {\n  const {scale, index, line} = source;\n  const points = [];\n  const segments = line.segments;\n  const sourcePoints = line.points;\n  const linesBelow = getLinesBelow(scale, index);\n  linesBelow.push(_createBoundaryLine({x: null, y: scale.bottom}, line));\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    for (let j = segment.start; j <= segment.end; j++) {\n      addPointsBelow(points, sourcePoints[j], linesBelow);\n    }\n  }\n  return new LineElement({points, options: {}});\n}\nfunction getLinesBelow(scale, index) {\n  const below = [];\n  const metas = scale.getMatchingVisibleMetas('line');\n  for (let i = 0; i < metas.length; i++) {\n    const meta = metas[i];\n    if (meta.index === index) {\n      break;\n    }\n    if (!meta.hidden) {\n      below.unshift(meta.dataset);\n    }\n  }\n  return below;\n}\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n  const postponed = [];\n  for (let j = 0; j < linesBelow.length; j++) {\n    const line = linesBelow[j];\n    const {first, last, point} = findPoint(line, sourcePoint, 'x');\n    if (!point || (first && last)) {\n      continue;\n    }\n    if (first) {\n      postponed.unshift(point);\n    } else {\n      points.push(point);\n      if (!last) {\n        break;\n      }\n    }\n  }\n  points.push(...postponed);\n}\nfunction findPoint(line, sourcePoint, property) {\n  const point = line.interpolate(sourcePoint, property);\n  if (!point) {\n    return {};\n  }\n  const pointValue = point[property];\n  const segments = line.segments;\n  const linePoints = line.points;\n  let first = false;\n  let last = false;\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const firstValue = linePoints[segment.start][property];\n    const lastValue = linePoints[segment.end][property];\n    if (_isBetween(pointValue, firstValue, lastValue)) {\n      first = pointValue === firstValue;\n      last = pointValue === lastValue;\n      break;\n    }\n  }\n  return {first, last, point};\n}\n\nclass simpleArc {\n  constructor(opts) {\n    this.x = opts.x;\n    this.y = opts.y;\n    this.radius = opts.radius;\n  }\n  pathSegment(ctx, bounds, opts) {\n    const {x, y, radius} = this;\n    bounds = bounds || {start: 0, end: TAU};\n    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n    return !opts.bounds;\n  }\n  interpolate(point) {\n    const {x, y, radius} = this;\n    const angle = point.angle;\n    return {\n      x: x + Math.cos(angle) * radius,\n      y: y + Math.sin(angle) * radius,\n      angle\n    };\n  }\n}\n\nfunction _getTarget(source) {\n  const {chart, fill, line} = source;\n  if (isNumberFinite(fill)) {\n    return getLineByIndex(chart, fill);\n  }\n  if (fill === 'stack') {\n    return _buildStackLine(source);\n  }\n  if (fill === 'shape') {\n    return true;\n  }\n  const boundary = computeBoundary(source);\n  if (boundary instanceof simpleArc) {\n    return boundary;\n  }\n  return _createBoundaryLine(boundary, line);\n}\nfunction getLineByIndex(chart, index) {\n  const meta = chart.getDatasetMeta(index);\n  const visible = meta && chart.isDatasetVisible(index);\n  return visible ? meta.dataset : null;\n}\nfunction computeBoundary(source) {\n  const scale = source.scale || {};\n  if (scale.getPointPositionForValue) {\n    return computeCircularBoundary(source);\n  }\n  return computeLinearBoundary(source);\n}\nfunction computeLinearBoundary(source) {\n  const {scale = {}, fill} = source;\n  const pixel = _getTargetPixel(fill, scale);\n  if (isNumberFinite(pixel)) {\n    const horizontal = scale.isHorizontal();\n    return {\n      x: horizontal ? pixel : null,\n      y: horizontal ? null : pixel\n    };\n  }\n  return null;\n}\nfunction computeCircularBoundary(source) {\n  const {scale, fill} = source;\n  const options = scale.options;\n  const length = scale.getLabels().length;\n  const start = options.reverse ? scale.max : scale.min;\n  const value = _getTargetValue(fill, scale, start);\n  const target = [];\n  if (options.grid.circular) {\n    const center = scale.getPointPositionForValue(0, start);\n    return new simpleArc({\n      x: center.x,\n      y: center.y,\n      radius: scale.getDistanceFromCenterForValue(value)\n    });\n  }\n  for (let i = 0; i < length; ++i) {\n    target.push(scale.getPointPositionForValue(i, value));\n  }\n  return target;\n}\n\nfunction _drawfill(ctx, source, area) {\n  const target = _getTarget(source);\n  const {line, scale, axis} = source;\n  const lineOpts = line.options;\n  const fillOption = lineOpts.fill;\n  const color = lineOpts.backgroundColor;\n  const {above = color, below = color} = fillOption || {};\n  if (target && line.points.length) {\n    clipArea(ctx, area);\n    doFill(ctx, {line, target, above, below, area, scale, axis});\n    unclipArea(ctx);\n  }\n}\nfunction doFill(ctx, cfg) {\n  const {line, target, above, below, area, scale} = cfg;\n  const property = line._loop ? 'angle' : cfg.axis;\n  ctx.save();\n  if (property === 'x' && below !== above) {\n    clipVertical(ctx, target, area.top);\n    fill(ctx, {line, target, color: above, scale, property});\n    ctx.restore();\n    ctx.save();\n    clipVertical(ctx, target, area.bottom);\n  }\n  fill(ctx, {line, target, color: below, scale, property});\n  ctx.restore();\n}\nfunction clipVertical(ctx, target, clipY) {\n  const {segments, points} = target;\n  let first = true;\n  let lineLoop = false;\n  ctx.beginPath();\n  for (const segment of segments) {\n    const {start, end} = segment;\n    const firstPoint = points[start];\n    const lastPoint = points[_findSegmentEnd(start, end, points)];\n    if (first) {\n      ctx.moveTo(firstPoint.x, firstPoint.y);\n      first = false;\n    } else {\n      ctx.lineTo(firstPoint.x, clipY);\n      ctx.lineTo(firstPoint.x, firstPoint.y);\n    }\n    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});\n    if (lineLoop) {\n      ctx.closePath();\n    } else {\n      ctx.lineTo(lastPoint.x, clipY);\n    }\n  }\n  ctx.lineTo(target.first().x, clipY);\n  ctx.closePath();\n  ctx.clip();\n}\nfunction fill(ctx, cfg) {\n  const {line, target, property, color, scale} = cfg;\n  const segments = _segments(line, target, property);\n  for (const {source: src, target: tgt, start, end} of segments) {\n    const {style: {backgroundColor = color} = {}} = src;\n    const notShape = target !== true;\n    ctx.save();\n    ctx.fillStyle = backgroundColor;\n    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));\n    ctx.beginPath();\n    const lineLoop = !!line.pathSegment(ctx, src);\n    let loop;\n    if (notShape) {\n      if (lineLoop) {\n        ctx.closePath();\n      } else {\n        interpolatedLineTo(ctx, target, end, property);\n      }\n      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\n      loop = lineLoop && targetLoop;\n      if (!loop) {\n        interpolatedLineTo(ctx, target, start, property);\n      }\n    }\n    ctx.closePath();\n    ctx.fill(loop ? 'evenodd' : 'nonzero');\n    ctx.restore();\n  }\n}\nfunction clipBounds(ctx, scale, bounds) {\n  const {top, bottom} = scale.chart.chartArea;\n  const {property, start, end} = bounds || {};\n  if (property === 'x') {\n    ctx.beginPath();\n    ctx.rect(start, top, end - start, bottom - top);\n    ctx.clip();\n  }\n}\nfunction interpolatedLineTo(ctx, target, point, property) {\n  const interpolatedPoint = target.interpolate(point, property);\n  if (interpolatedPoint) {\n    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n  }\n}\n\nvar index = {\n  id: 'filler',\n  afterDatasetsUpdate(chart, _args, options) {\n    const count = (chart.data.datasets || []).length;\n    const sources = [];\n    let meta, i, line, source;\n    for (i = 0; i < count; ++i) {\n      meta = chart.getDatasetMeta(i);\n      line = meta.dataset;\n      source = null;\n      if (line && line.options && line instanceof LineElement) {\n        source = {\n          visible: chart.isDatasetVisible(i),\n          index: i,\n          fill: _decodeFill(line, i, count),\n          chart,\n          axis: meta.controller.options.indexAxis,\n          scale: meta.vScale,\n          line,\n        };\n      }\n      meta.$filler = source;\n      sources.push(source);\n    }\n    for (i = 0; i < count; ++i) {\n      source = sources[i];\n      if (!source || source.fill === false) {\n        continue;\n      }\n      source.fill = _resolveTarget(sources, i, options.propagate);\n    }\n  },\n  beforeDraw(chart, _args, options) {\n    const draw = options.drawTime === 'beforeDraw';\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const area = chart.chartArea;\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (!source) {\n        continue;\n      }\n      source.line.updateControlPoints(area, source.axis);\n      if (draw && source.fill) {\n        _drawfill(chart.ctx, source, area);\n      }\n    }\n  },\n  beforeDatasetsDraw(chart, _args, options) {\n    if (options.drawTime !== 'beforeDatasetsDraw') {\n      return;\n    }\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (_shouldApplyFill(source)) {\n        _drawfill(chart.ctx, source, chart.chartArea);\n      }\n    }\n  },\n  beforeDatasetDraw(chart, args, options) {\n    const source = args.meta.$filler;\n    if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\n      return;\n    }\n    _drawfill(chart.ctx, source, chart.chartArea);\n  },\n  defaults: {\n    propagate: true,\n    drawTime: 'beforeDatasetDraw'\n  }\n};\n\nconst getBoxSize = (labelOpts, fontSize) => {\n  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\n  if (labelOpts.usePointStyle) {\n    boxHeight = Math.min(boxHeight, fontSize);\n    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n  }\n  return {\n    boxWidth,\n    boxHeight,\n    itemHeight: Math.max(fontSize, boxHeight)\n  };\n};\nconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\nclass Legend extends Element {\n  constructor(config) {\n    super();\n    this._added = false;\n    this.legendHitBoxes = [];\n    this._hoveredItem = null;\n    this.doughnutMode = false;\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this.legendItems = undefined;\n    this.columnSizes = undefined;\n    this.lineWidths = undefined;\n    this.maxHeight = undefined;\n    this.maxWidth = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this._margins = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n  update(maxWidth, maxHeight, margins) {\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins;\n    this.setDimensions();\n    this.buildLabels();\n    this.fit();\n  }\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = this._margins.left;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = this._margins.top;\n      this.bottom = this.height;\n    }\n  }\n  buildLabels() {\n    const labelOpts = this.options.labels || {};\n    let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];\n    if (labelOpts.filter) {\n      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));\n    }\n    if (labelOpts.sort) {\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));\n    }\n    if (this.options.reverse) {\n      legendItems.reverse();\n    }\n    this.legendItems = legendItems;\n  }\n  fit() {\n    const {options, ctx} = this;\n    if (!options.display) {\n      this.width = this.height = 0;\n      return;\n    }\n    const labelOpts = options.labels;\n    const labelFont = toFont(labelOpts.font);\n    const fontSize = labelFont.size;\n    const titleHeight = this._computeTitleHeight();\n    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\n    let width, height;\n    ctx.font = labelFont.string;\n    if (this.isHorizontal()) {\n      width = this.maxWidth;\n      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    } else {\n      height = this.maxHeight;\n      width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    }\n    this.width = Math.min(width, options.maxWidth || this.maxWidth);\n    this.height = Math.min(height, options.maxHeight || this.maxHeight);\n  }\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxWidth, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const lineWidths = this.lineWidths = [0];\n    const lineHeight = itemHeight + padding;\n    let totalHeight = titleHeight;\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'middle';\n    let row = -1;\n    let top = -lineHeight;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n        totalHeight += lineHeight;\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n        top += lineHeight;\n        row++;\n      }\n      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\n    });\n    return totalHeight;\n  }\n  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxHeight, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const columnSizes = this.columnSizes = [];\n    const heightLimit = maxHeight - titleHeight;\n    let totalWidth = padding;\n    let currentColWidth = 0;\n    let currentColHeight = 0;\n    let left = 0;\n    let col = 0;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n        totalWidth += currentColWidth + padding;\n        columnSizes.push({width: currentColWidth, height: currentColHeight});\n        left += currentColWidth + padding;\n        col++;\n        currentColWidth = currentColHeight = 0;\n      }\n      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};\n      currentColWidth = Math.max(currentColWidth, itemWidth);\n      currentColHeight += itemHeight + padding;\n    });\n    totalWidth += currentColWidth;\n    columnSizes.push({width: currentColWidth, height: currentColHeight});\n    return totalWidth;\n  }\n  adjustHitBoxes() {\n    if (!this.options.display) {\n      return;\n    }\n    const titleHeight = this._computeTitleHeight();\n    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;\n    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\n    if (this.isHorizontal()) {\n      let row = 0;\n      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n      for (const hitbox of hitboxes) {\n        if (row !== hitbox.row) {\n          row = hitbox.row;\n          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n        }\n        hitbox.top += this.top + titleHeight + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n        left += hitbox.width + padding;\n      }\n    } else {\n      let col = 0;\n      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n      for (const hitbox of hitboxes) {\n        if (hitbox.col !== col) {\n          col = hitbox.col;\n          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n        }\n        hitbox.top = top;\n        hitbox.left += this.left + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n        top += hitbox.height + padding;\n      }\n    }\n  }\n  isHorizontal() {\n    return this.options.position === 'top' || this.options.position === 'bottom';\n  }\n  draw() {\n    if (this.options.display) {\n      const ctx = this.ctx;\n      clipArea(ctx, this);\n      this._draw();\n      unclipArea(ctx);\n    }\n  }\n  _draw() {\n    const {options: opts, columnSizes, lineWidths, ctx} = this;\n    const {align, labels: labelOpts} = opts;\n    const defaultColor = defaults.color;\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const labelFont = toFont(labelOpts.font);\n    const {color: fontColor, padding} = labelOpts;\n    const fontSize = labelFont.size;\n    const halfFontSize = fontSize / 2;\n    let cursor;\n    this.drawTitle();\n    ctx.textAlign = rtlHelper.textAlign('left');\n    ctx.textBaseline = 'middle';\n    ctx.lineWidth = 0.5;\n    ctx.font = labelFont.string;\n    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\n    const drawLegendBox = function(x, y, legendItem) {\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n        return;\n      }\n      ctx.save();\n      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n      if (labelOpts.usePointStyle) {\n        const drawOptions = {\n          radius: boxHeight * Math.SQRT2 / 2,\n          pointStyle: legendItem.pointStyle,\n          rotation: legendItem.rotation,\n          borderWidth: lineWidth\n        };\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n        const centerY = y + halfFontSize;\n        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n      } else {\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n        const borderRadius = toTRBLCorners(legendItem.borderRadius);\n        ctx.beginPath();\n        if (Object.values(borderRadius).some(v => v !== 0)) {\n          addRoundedRectPath(ctx, {\n            x: xBoxLeft,\n            y: yBoxTop,\n            w: boxWidth,\n            h: boxHeight,\n            radius: borderRadius,\n          });\n        } else {\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n        }\n        ctx.fill();\n        if (lineWidth !== 0) {\n          ctx.stroke();\n        }\n      }\n      ctx.restore();\n    };\n    const fillText = function(x, y, legendItem) {\n      renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\n        strikethrough: legendItem.hidden,\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\n      });\n    };\n    const isHorizontal = this.isHorizontal();\n    const titleHeight = this._computeTitleHeight();\n    if (isHorizontal) {\n      cursor = {\n        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n        y: this.top + padding + titleHeight,\n        line: 0\n      };\n    } else {\n      cursor = {\n        x: this.left + padding,\n        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n        line: 0\n      };\n    }\n    overrideTextDirection(this.ctx, opts.textDirection);\n    const lineHeight = itemHeight + padding;\n    this.legendItems.forEach((legendItem, i) => {\n      ctx.strokeStyle = legendItem.fontColor || fontColor;\n      ctx.fillStyle = legendItem.fontColor || fontColor;\n      const textWidth = ctx.measureText(legendItem.text).width;\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n      const width = boxWidth + halfFontSize + textWidth;\n      let x = cursor.x;\n      let y = cursor.y;\n      rtlHelper.setWidth(this.width);\n      if (isHorizontal) {\n        if (i > 0 && x + width + padding > this.right) {\n          y = cursor.y += lineHeight;\n          cursor.line++;\n          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n        }\n      } else if (i > 0 && y + lineHeight > this.bottom) {\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\n        cursor.line++;\n        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n      }\n      const realX = rtlHelper.x(x);\n      drawLegendBox(realX, y, legendItem);\n      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n      fillText(rtlHelper.x(x), y, legendItem);\n      if (isHorizontal) {\n        cursor.x += width + padding;\n      } else {\n        cursor.y += lineHeight;\n      }\n    });\n    restoreTextDirection(this.ctx, opts.textDirection);\n  }\n  drawTitle() {\n    const opts = this.options;\n    const titleOpts = opts.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    if (!titleOpts.display) {\n      return;\n    }\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const ctx = this.ctx;\n    const position = titleOpts.position;\n    const halfFontSize = titleFont.size / 2;\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n    let y;\n    let left = this.left;\n    let maxWidth = this.width;\n    if (this.isHorizontal()) {\n      maxWidth = Math.max(...this.lineWidths);\n      y = this.top + topPaddingPlusHalfFontSize;\n      left = _alignStartEnd(opts.align, left, this.right - maxWidth);\n    } else {\n      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\n      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n    }\n    const x = _alignStartEnd(position, left, left + maxWidth);\n    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n    ctx.textBaseline = 'middle';\n    ctx.strokeStyle = titleOpts.color;\n    ctx.fillStyle = titleOpts.color;\n    ctx.font = titleFont.string;\n    renderText(ctx, titleOpts.text, x, y, titleFont);\n  }\n  _computeTitleHeight() {\n    const titleOpts = this.options.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n  }\n  _getLegendItemAt(x, y) {\n    let i, hitBox, lh;\n    if (_isBetween(x, this.left, this.right)\n      && _isBetween(y, this.top, this.bottom)) {\n      lh = this.legendHitBoxes;\n      for (i = 0; i < lh.length; ++i) {\n        hitBox = lh[i];\n        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width)\n          && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n          return this.legendItems[i];\n        }\n      }\n    }\n    return null;\n  }\n  handleEvent(e) {\n    const opts = this.options;\n    if (!isListened(e.type, opts)) {\n      return;\n    }\n    const hoveredItem = this._getLegendItemAt(e.x, e.y);\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\n      const previous = this._hoveredItem;\n      const sameItem = itemsEqual(previous, hoveredItem);\n      if (previous && !sameItem) {\n        callback(opts.onLeave, [e, previous, this], this);\n      }\n      this._hoveredItem = hoveredItem;\n      if (hoveredItem && !sameItem) {\n        callback(opts.onHover, [e, hoveredItem, this], this);\n      }\n    } else if (hoveredItem) {\n      callback(opts.onClick, [e, hoveredItem, this], this);\n    }\n  }\n}\nfunction isListened(type, opts) {\n  if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\n    return true;\n  }\n  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n    return true;\n  }\n  return false;\n}\nvar plugin_legend = {\n  id: 'legend',\n  _element: Legend,\n  start(chart, _args, options) {\n    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\n    layouts.configure(chart, legend, options);\n    layouts.addBox(chart, legend);\n  },\n  stop(chart) {\n    layouts.removeBox(chart, chart.legend);\n    delete chart.legend;\n  },\n  beforeUpdate(chart, _args, options) {\n    const legend = chart.legend;\n    layouts.configure(chart, legend, options);\n    legend.options = options;\n  },\n  afterUpdate(chart) {\n    const legend = chart.legend;\n    legend.buildLabels();\n    legend.adjustHitBoxes();\n  },\n  afterEvent(chart, args) {\n    if (!args.replay) {\n      chart.legend.handleEvent(args.event);\n    }\n  },\n  defaults: {\n    display: true,\n    position: 'top',\n    align: 'center',\n    fullSize: true,\n    reverse: false,\n    weight: 1000,\n    onClick(e, legendItem, legend) {\n      const index = legendItem.datasetIndex;\n      const ci = legend.chart;\n      if (ci.isDatasetVisible(index)) {\n        ci.hide(index);\n        legendItem.hidden = true;\n      } else {\n        ci.show(index);\n        legendItem.hidden = false;\n      }\n    },\n    onHover: null,\n    onLeave: null,\n    labels: {\n      color: (ctx) => ctx.chart.options.color,\n      boxWidth: 40,\n      padding: 10,\n      generateLabels(chart) {\n        const datasets = chart.data.datasets;\n        const {labels: {usePointStyle, pointStyle, textAlign, color}} = chart.legend.options;\n        return chart._getSortedDatasetMetas().map((meta) => {\n          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n          const borderWidth = toPadding(style.borderWidth);\n          return {\n            text: datasets[meta.index].label,\n            fillStyle: style.backgroundColor,\n            fontColor: color,\n            hidden: !meta.visible,\n            lineCap: style.borderCapStyle,\n            lineDash: style.borderDash,\n            lineDashOffset: style.borderDashOffset,\n            lineJoin: style.borderJoinStyle,\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\n            strokeStyle: style.borderColor,\n            pointStyle: pointStyle || style.pointStyle,\n            rotation: style.rotation,\n            textAlign: textAlign || style.textAlign,\n            borderRadius: 0,\n            datasetIndex: meta.index\n          };\n        }, this);\n      }\n    },\n    title: {\n      color: (ctx) => ctx.chart.options.color,\n      display: false,\n      position: 'center',\n      text: '',\n    }\n  },\n  descriptors: {\n    _scriptable: (name) => !name.startsWith('on'),\n    labels: {\n      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\n    }\n  },\n};\n\nclass Title extends Element {\n  constructor(config) {\n    super();\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this._padding = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n  update(maxWidth, maxHeight) {\n    const opts = this.options;\n    this.left = 0;\n    this.top = 0;\n    if (!opts.display) {\n      this.width = this.height = this.right = this.bottom = 0;\n      return;\n    }\n    this.width = this.right = maxWidth;\n    this.height = this.bottom = maxHeight;\n    const lineCount = isArray(opts.text) ? opts.text.length : 1;\n    this._padding = toPadding(opts.padding);\n    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\n    if (this.isHorizontal()) {\n      this.height = textSize;\n    } else {\n      this.width = textSize;\n    }\n  }\n  isHorizontal() {\n    const pos = this.options.position;\n    return pos === 'top' || pos === 'bottom';\n  }\n  _drawArgs(offset) {\n    const {top, left, bottom, right, options} = this;\n    const align = options.align;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n    if (this.isHorizontal()) {\n      titleX = _alignStartEnd(align, left, right);\n      titleY = top + offset;\n      maxWidth = right - left;\n    } else {\n      if (options.position === 'left') {\n        titleX = left + offset;\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = PI * -0.5;\n      } else {\n        titleX = right - offset;\n        titleY = _alignStartEnd(align, top, bottom);\n        rotation = PI * 0.5;\n      }\n      maxWidth = bottom - top;\n    }\n    return {titleX, titleY, maxWidth, rotation};\n  }\n  draw() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    if (!opts.display) {\n      return;\n    }\n    const fontOpts = toFont(opts.font);\n    const lineHeight = fontOpts.lineHeight;\n    const offset = lineHeight / 2 + this._padding.top;\n    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);\n    renderText(ctx, opts.text, 0, 0, fontOpts, {\n      color: opts.color,\n      maxWidth,\n      rotation,\n      textAlign: _toLeftRightCenter(opts.align),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n}\nfunction createTitle(chart, titleOpts) {\n  const title = new Title({\n    ctx: chart.ctx,\n    options: titleOpts,\n    chart\n  });\n  layouts.configure(chart, title, titleOpts);\n  layouts.addBox(chart, title);\n  chart.titleBlock = title;\n}\nvar plugin_title = {\n  id: 'title',\n  _element: Title,\n  start(chart, _args, options) {\n    createTitle(chart, options);\n  },\n  stop(chart) {\n    const titleBlock = chart.titleBlock;\n    layouts.removeBox(chart, titleBlock);\n    delete chart.titleBlock;\n  },\n  beforeUpdate(chart, _args, options) {\n    const title = chart.titleBlock;\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'bold',\n    },\n    fullSize: true,\n    padding: 10,\n    position: 'top',\n    text: '',\n    weight: 2000\n  },\n  defaultRoutes: {\n    color: 'color'\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n\nconst map = new WeakMap();\nvar plugin_subtitle = {\n  id: 'subtitle',\n  start(chart, _args, options) {\n    const title = new Title({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n    layouts.configure(chart, title, options);\n    layouts.addBox(chart, title);\n    map.set(chart, title);\n  },\n  stop(chart) {\n    layouts.removeBox(chart, map.get(chart));\n    map.delete(chart);\n  },\n  beforeUpdate(chart, _args, options) {\n    const title = map.get(chart);\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'normal',\n    },\n    fullSize: true,\n    padding: 0,\n    position: 'top',\n    text: '',\n    weight: 1500\n  },\n  defaultRoutes: {\n    color: 'color'\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n\nconst positioners = {\n  average(items) {\n    if (!items.length) {\n      return false;\n    }\n    let i, len;\n    let x = 0;\n    let y = 0;\n    let count = 0;\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const pos = el.tooltipPosition();\n        x += pos.x;\n        y += pos.y;\n        ++count;\n      }\n    }\n    return {\n      x: x / count,\n      y: y / count\n    };\n  },\n  nearest(items, eventPosition) {\n    if (!items.length) {\n      return false;\n    }\n    let x = eventPosition.x;\n    let y = eventPosition.y;\n    let minDistance = Number.POSITIVE_INFINITY;\n    let i, len, nearestElement;\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const center = el.getCenterPoint();\n        const d = distanceBetweenPoints(eventPosition, center);\n        if (d < minDistance) {\n          minDistance = d;\n          nearestElement = el;\n        }\n      }\n    }\n    if (nearestElement) {\n      const tp = nearestElement.tooltipPosition();\n      x = tp.x;\n      y = tp.y;\n    }\n    return {\n      x,\n      y\n    };\n  }\n};\nfunction pushOrConcat(base, toPush) {\n  if (toPush) {\n    if (isArray(toPush)) {\n      Array.prototype.push.apply(base, toPush);\n    } else {\n      base.push(toPush);\n    }\n  }\n  return base;\n}\nfunction splitNewlines(str) {\n  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n    return str.split('\\n');\n  }\n  return str;\n}\nfunction createTooltipItem(chart, item) {\n  const {element, datasetIndex, index} = item;\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\n  const {label, value} = controller.getLabelAndValue(index);\n  return {\n    chart,\n    label,\n    parsed: controller.getParsed(index),\n    raw: chart.data.datasets[datasetIndex].data[index],\n    formattedValue: value,\n    dataset: controller.getDataset(),\n    dataIndex: index,\n    datasetIndex,\n    element\n  };\n}\nfunction getTooltipSize(tooltip, options) {\n  const ctx = tooltip.chart.ctx;\n  const {body, footer, title} = tooltip;\n  const {boxWidth, boxHeight} = options;\n  const bodyFont = toFont(options.bodyFont);\n  const titleFont = toFont(options.titleFont);\n  const footerFont = toFont(options.footerFont);\n  const titleLineCount = title.length;\n  const footerLineCount = footer.length;\n  const bodyLineItemCount = body.length;\n  const padding = toPadding(options.padding);\n  let height = padding.height;\n  let width = 0;\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n  if (titleLineCount) {\n    height += titleLineCount * titleFont.lineHeight\n\t\t\t+ (titleLineCount - 1) * options.titleSpacing\n\t\t\t+ options.titleMarginBottom;\n  }\n  if (combinedBodyLength) {\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n    height += bodyLineItemCount * bodyLineHeight\n\t\t\t+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\n\t\t\t+ (combinedBodyLength - 1) * options.bodySpacing;\n  }\n  if (footerLineCount) {\n    height += options.footerMarginTop\n\t\t\t+ footerLineCount * footerFont.lineHeight\n\t\t\t+ (footerLineCount - 1) * options.footerSpacing;\n  }\n  let widthPadding = 0;\n  const maxLineWidth = function(line) {\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\n  };\n  ctx.save();\n  ctx.font = titleFont.string;\n  each(tooltip.title, maxLineWidth);\n  ctx.font = bodyFont.string;\n  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;\n  each(body, (bodyItem) => {\n    each(bodyItem.before, maxLineWidth);\n    each(bodyItem.lines, maxLineWidth);\n    each(bodyItem.after, maxLineWidth);\n  });\n  widthPadding = 0;\n  ctx.font = footerFont.string;\n  each(tooltip.footer, maxLineWidth);\n  ctx.restore();\n  width += padding.width;\n  return {width, height};\n}\nfunction determineYAlign(chart, size) {\n  const {y, height} = size;\n  if (y < height / 2) {\n    return 'top';\n  } else if (y > (chart.height - height / 2)) {\n    return 'bottom';\n  }\n  return 'center';\n}\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n  const {x, width} = size;\n  const caret = options.caretSize + options.caretPadding;\n  if (xAlign === 'left' && x + width + caret > chart.width) {\n    return true;\n  }\n  if (xAlign === 'right' && x - width - caret < 0) {\n    return true;\n  }\n}\nfunction determineXAlign(chart, options, size, yAlign) {\n  const {x, width} = size;\n  const {width: chartWidth, chartArea: {left, right}} = chart;\n  let xAlign = 'center';\n  if (yAlign === 'center') {\n    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n  } else if (x <= width / 2) {\n    xAlign = 'left';\n  } else if (x >= chartWidth - width / 2) {\n    xAlign = 'right';\n  }\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n    xAlign = 'center';\n  }\n  return xAlign;\n}\nfunction determineAlignment(chart, options, size) {\n  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n  return {\n    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n    yAlign\n  };\n}\nfunction alignX(size, xAlign) {\n  let {x, width} = size;\n  if (xAlign === 'right') {\n    x -= width;\n  } else if (xAlign === 'center') {\n    x -= (width / 2);\n  }\n  return x;\n}\nfunction alignY(size, yAlign, paddingAndSize) {\n  let {y, height} = size;\n  if (yAlign === 'top') {\n    y += paddingAndSize;\n  } else if (yAlign === 'bottom') {\n    y -= height + paddingAndSize;\n  } else {\n    y -= (height / 2);\n  }\n  return y;\n}\nfunction getBackgroundPoint(options, size, alignment, chart) {\n  const {caretSize, caretPadding, cornerRadius} = options;\n  const {xAlign, yAlign} = alignment;\n  const paddingAndSize = caretSize + caretPadding;\n  const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n  let x = alignX(size, xAlign);\n  const y = alignY(size, yAlign, paddingAndSize);\n  if (yAlign === 'center') {\n    if (xAlign === 'left') {\n      x += paddingAndSize;\n    } else if (xAlign === 'right') {\n      x -= paddingAndSize;\n    }\n  } else if (xAlign === 'left') {\n    x -= Math.max(topLeft, bottomLeft) + caretSize;\n  } else if (xAlign === 'right') {\n    x += Math.max(topRight, bottomRight) + caretSize;\n  }\n  return {\n    x: _limitValue(x, 0, chart.width - size.width),\n    y: _limitValue(y, 0, chart.height - size.height)\n  };\n}\nfunction getAlignedX(tooltip, align, options) {\n  const padding = toPadding(options.padding);\n  return align === 'center'\n    ? tooltip.x + tooltip.width / 2\n    : align === 'right'\n      ? tooltip.x + tooltip.width - padding.right\n      : tooltip.x + padding.left;\n}\nfunction getBeforeAfterBodyLines(callback) {\n  return pushOrConcat([], splitNewlines(callback));\n}\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n  return createContext(parent, {\n    tooltip,\n    tooltipItems,\n    type: 'tooltip'\n  });\n}\nfunction overrideCallbacks(callbacks, context) {\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n  return override ? callbacks.override(override) : callbacks;\n}\nclass Tooltip extends Element {\n  constructor(config) {\n    super();\n    this.opacity = 0;\n    this._active = [];\n    this._eventPosition = undefined;\n    this._size = undefined;\n    this._cachedAnimations = undefined;\n    this._tooltipItems = [];\n    this.$animations = undefined;\n    this.$context = undefined;\n    this.chart = config.chart || config._chart;\n    this._chart = this.chart;\n    this.options = config.options;\n    this.dataPoints = undefined;\n    this.title = undefined;\n    this.beforeBody = undefined;\n    this.body = undefined;\n    this.afterBody = undefined;\n    this.footer = undefined;\n    this.xAlign = undefined;\n    this.yAlign = undefined;\n    this.x = undefined;\n    this.y = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.caretX = undefined;\n    this.caretY = undefined;\n    this.labelColors = undefined;\n    this.labelPointStyles = undefined;\n    this.labelTextColors = undefined;\n  }\n  initialize(options) {\n    this.options = options;\n    this._cachedAnimations = undefined;\n    this.$context = undefined;\n  }\n  _resolveAnimations() {\n    const cached = this._cachedAnimations;\n    if (cached) {\n      return cached;\n    }\n    const chart = this.chart;\n    const options = this.options.setContext(this.getContext());\n    const opts = options.enabled && chart.options.animation && options.animations;\n    const animations = new Animations(this.chart, opts);\n    if (opts._cacheable) {\n      this._cachedAnimations = Object.freeze(animations);\n    }\n    return animations;\n  }\n  getContext() {\n    return this.$context ||\n\t\t\t(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n  }\n  getTitle(context, options) {\n    const {callbacks} = options;\n    const beforeTitle = callbacks.beforeTitle.apply(this, [context]);\n    const title = callbacks.title.apply(this, [context]);\n    const afterTitle = callbacks.afterTitle.apply(this, [context]);\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n    lines = pushOrConcat(lines, splitNewlines(title));\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\n    return lines;\n  }\n  getBeforeBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));\n  }\n  getBody(tooltipItems, options) {\n    const {callbacks} = options;\n    const bodyItems = [];\n    each(tooltipItems, (context) => {\n      const bodyItem = {\n        before: [],\n        lines: [],\n        after: []\n      };\n      const scoped = overrideCallbacks(callbacks, context);\n      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));\n      pushOrConcat(bodyItem.lines, scoped.label.call(this, context));\n      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));\n      bodyItems.push(bodyItem);\n    });\n    return bodyItems;\n  }\n  getAfterBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));\n  }\n  getFooter(tooltipItems, options) {\n    const {callbacks} = options;\n    const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);\n    const footer = callbacks.footer.apply(this, [tooltipItems]);\n    const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n    lines = pushOrConcat(lines, splitNewlines(footer));\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\n    return lines;\n  }\n  _createItems(options) {\n    const active = this._active;\n    const data = this.chart.data;\n    const labelColors = [];\n    const labelPointStyles = [];\n    const labelTextColors = [];\n    let tooltipItems = [];\n    let i, len;\n    for (i = 0, len = active.length; i < len; ++i) {\n      tooltipItems.push(createTooltipItem(this.chart, active[i]));\n    }\n    if (options.filter) {\n      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\n    }\n    if (options.itemSort) {\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\n    }\n    each(tooltipItems, (context) => {\n      const scoped = overrideCallbacks(options.callbacks, context);\n      labelColors.push(scoped.labelColor.call(this, context));\n      labelPointStyles.push(scoped.labelPointStyle.call(this, context));\n      labelTextColors.push(scoped.labelTextColor.call(this, context));\n    });\n    this.labelColors = labelColors;\n    this.labelPointStyles = labelPointStyles;\n    this.labelTextColors = labelTextColors;\n    this.dataPoints = tooltipItems;\n    return tooltipItems;\n  }\n  update(changed, replay) {\n    const options = this.options.setContext(this.getContext());\n    const active = this._active;\n    let properties;\n    let tooltipItems = [];\n    if (!active.length) {\n      if (this.opacity !== 0) {\n        properties = {\n          opacity: 0\n        };\n      }\n    } else {\n      const position = positioners[options.position].call(this, active, this._eventPosition);\n      tooltipItems = this._createItems(options);\n      this.title = this.getTitle(tooltipItems, options);\n      this.beforeBody = this.getBeforeBody(tooltipItems, options);\n      this.body = this.getBody(tooltipItems, options);\n      this.afterBody = this.getAfterBody(tooltipItems, options);\n      this.footer = this.getFooter(tooltipItems, options);\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, size);\n      const alignment = determineAlignment(this.chart, options, positionAndSize);\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n      this.xAlign = alignment.xAlign;\n      this.yAlign = alignment.yAlign;\n      properties = {\n        opacity: 1,\n        x: backgroundPoint.x,\n        y: backgroundPoint.y,\n        width: size.width,\n        height: size.height,\n        caretX: position.x,\n        caretY: position.y\n      };\n    }\n    this._tooltipItems = tooltipItems;\n    this.$context = undefined;\n    if (properties) {\n      this._resolveAnimations().update(this, properties);\n    }\n    if (changed && options.external) {\n      options.external.call(this, {chart: this.chart, tooltip: this, replay});\n    }\n  }\n  drawCaret(tooltipPoint, ctx, size, options) {\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\n  }\n  getCaretPosition(tooltipPoint, size, options) {\n    const {xAlign, yAlign} = this;\n    const {caretSize, cornerRadius} = options;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n    const {x: ptX, y: ptY} = tooltipPoint;\n    const {width, height} = size;\n    let x1, x2, x3, y1, y2, y3;\n    if (yAlign === 'center') {\n      y2 = ptY + (height / 2);\n      if (xAlign === 'left') {\n        x1 = ptX;\n        x2 = x1 - caretSize;\n        y1 = y2 + caretSize;\n        y3 = y2 - caretSize;\n      } else {\n        x1 = ptX + width;\n        x2 = x1 + caretSize;\n        y1 = y2 - caretSize;\n        y3 = y2 + caretSize;\n      }\n      x3 = x1;\n    } else {\n      if (xAlign === 'left') {\n        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);\n      } else if (xAlign === 'right') {\n        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n      } else {\n        x2 = this.caretX;\n      }\n      if (yAlign === 'top') {\n        y1 = ptY;\n        y2 = y1 - caretSize;\n        x1 = x2 - caretSize;\n        x3 = x2 + caretSize;\n      } else {\n        y1 = ptY + height;\n        y2 = y1 + caretSize;\n        x1 = x2 + caretSize;\n        x3 = x2 - caretSize;\n      }\n      y3 = y1;\n    }\n    return {x1, x2, x3, y1, y2, y3};\n  }\n  drawTitle(pt, ctx, options) {\n    const title = this.title;\n    const length = title.length;\n    let titleFont, titleSpacing, i;\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n      pt.x = getAlignedX(this, options.titleAlign, options);\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n      ctx.textBaseline = 'middle';\n      titleFont = toFont(options.titleFont);\n      titleSpacing = options.titleSpacing;\n      ctx.fillStyle = options.titleColor;\n      ctx.font = titleFont.string;\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n        pt.y += titleFont.lineHeight + titleSpacing;\n        if (i + 1 === length) {\n          pt.y += options.titleMarginBottom - titleSpacing;\n        }\n      }\n    }\n  }\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\n    const labelColors = this.labelColors[i];\n    const labelPointStyle = this.labelPointStyles[i];\n    const {boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = toFont(options.bodyFont);\n    const colorX = getAlignedX(this, 'left', options);\n    const rtlColorX = rtlHelper.x(colorX);\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n    const colorY = pt.y + yOffSet;\n    if (options.usePointStyle) {\n      const drawOptions = {\n        radius: Math.min(boxWidth, boxHeight) / 2,\n        pointStyle: labelPointStyle.pointStyle,\n        rotation: labelPointStyle.rotation,\n        borderWidth: 1\n      };\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n      const centerY = colorY + boxHeight / 2;\n      ctx.strokeStyle = options.multiKeyBackground;\n      ctx.fillStyle = options.multiKeyBackground;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n      ctx.strokeStyle = labelColors.borderColor;\n      ctx.fillStyle = labelColors.backgroundColor;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n    } else {\n      ctx.lineWidth = isObject(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : (labelColors.borderWidth || 1);\n      ctx.strokeStyle = labelColors.borderColor;\n      ctx.setLineDash(labelColors.borderDash || []);\n      ctx.lineDashOffset = labelColors.borderDashOffset || 0;\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);\n      const borderRadius = toTRBLCorners(labelColors.borderRadius);\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        ctx.fillStyle = options.multiKeyBackground;\n        addRoundedRectPath(ctx, {\n          x: outerX,\n          y: colorY,\n          w: boxWidth,\n          h: boxHeight,\n          radius: borderRadius,\n        });\n        ctx.fill();\n        ctx.stroke();\n        ctx.fillStyle = labelColors.backgroundColor;\n        ctx.beginPath();\n        addRoundedRectPath(ctx, {\n          x: innerX,\n          y: colorY + 1,\n          w: boxWidth - 2,\n          h: boxHeight - 2,\n          radius: borderRadius,\n        });\n        ctx.fill();\n      } else {\n        ctx.fillStyle = options.multiKeyBackground;\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.fillStyle = labelColors.backgroundColor;\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n      }\n    }\n    ctx.fillStyle = this.labelTextColors[i];\n  }\n  drawBody(pt, ctx, options) {\n    const {body} = this;\n    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = toFont(options.bodyFont);\n    let bodyLineHeight = bodyFont.lineHeight;\n    let xLinePadding = 0;\n    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n    const fillLineOfText = function(line) {\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n      pt.y += bodyLineHeight + bodySpacing;\n    };\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = 'middle';\n    ctx.font = bodyFont.string;\n    pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n    ctx.fillStyle = options.bodyColor;\n    each(this.beforeBody, fillLineOfText);\n    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\n      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)\n      : 0;\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\n      bodyItem = body[i];\n      textColor = this.labelTextColors[i];\n      ctx.fillStyle = textColor;\n      each(bodyItem.before, fillLineOfText);\n      lines = bodyItem.lines;\n      if (displayColors && lines.length) {\n        this._drawColorBox(ctx, pt, i, rtlHelper, options);\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n      }\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\n        fillLineOfText(lines[j]);\n        bodyLineHeight = bodyFont.lineHeight;\n      }\n      each(bodyItem.after, fillLineOfText);\n    }\n    xLinePadding = 0;\n    bodyLineHeight = bodyFont.lineHeight;\n    each(this.afterBody, fillLineOfText);\n    pt.y -= bodySpacing;\n  }\n  drawFooter(pt, ctx, options) {\n    const footer = this.footer;\n    const length = footer.length;\n    let footerFont, i;\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n      pt.x = getAlignedX(this, options.footerAlign, options);\n      pt.y += options.footerMarginTop;\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n      ctx.textBaseline = 'middle';\n      footerFont = toFont(options.footerFont);\n      ctx.fillStyle = options.footerColor;\n      ctx.font = footerFont.string;\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n        pt.y += footerFont.lineHeight + options.footerSpacing;\n      }\n    }\n  }\n  drawBackground(pt, ctx, tooltipSize, options) {\n    const {xAlign, yAlign} = this;\n    const {x, y} = pt;\n    const {width, height} = tooltipSize;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.beginPath();\n    ctx.moveTo(x + topLeft, y);\n    if (yAlign === 'top') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width - topRight, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n    if (yAlign === 'center' && xAlign === 'right') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width, y + height - bottomRight);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n    if (yAlign === 'bottom') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + bottomLeft, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n    if (yAlign === 'center' && xAlign === 'left') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x, y + topLeft);\n    ctx.quadraticCurveTo(x, y, x + topLeft, y);\n    ctx.closePath();\n    ctx.fill();\n    if (options.borderWidth > 0) {\n      ctx.stroke();\n    }\n  }\n  _updateAnimationTarget(options) {\n    const chart = this.chart;\n    const anims = this.$animations;\n    const animX = anims && anims.x;\n    const animY = anims && anims.y;\n    if (animX || animY) {\n      const position = positioners[options.position].call(this, this._active, this._eventPosition);\n      if (!position) {\n        return;\n      }\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, this._size);\n      const alignment = determineAlignment(chart, options, positionAndSize);\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n      if (animX._to !== point.x || animY._to !== point.y) {\n        this.xAlign = alignment.xAlign;\n        this.yAlign = alignment.yAlign;\n        this.width = size.width;\n        this.height = size.height;\n        this.caretX = position.x;\n        this.caretY = position.y;\n        this._resolveAnimations().update(this, point);\n      }\n    }\n  }\n  _willRender() {\n    return !!this.opacity;\n  }\n  draw(ctx) {\n    const options = this.options.setContext(this.getContext());\n    let opacity = this.opacity;\n    if (!opacity) {\n      return;\n    }\n    this._updateAnimationTarget(options);\n    const tooltipSize = {\n      width: this.width,\n      height: this.height\n    };\n    const pt = {\n      x: this.x,\n      y: this.y\n    };\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n    const padding = toPadding(options.padding);\n    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n    if (options.enabled && hasTooltipContent) {\n      ctx.save();\n      ctx.globalAlpha = opacity;\n      this.drawBackground(pt, ctx, tooltipSize, options);\n      overrideTextDirection(ctx, options.textDirection);\n      pt.y += padding.top;\n      this.drawTitle(pt, ctx, options);\n      this.drawBody(pt, ctx, options);\n      this.drawFooter(pt, ctx, options);\n      restoreTextDirection(ctx, options.textDirection);\n      ctx.restore();\n    }\n  }\n  getActiveElements() {\n    return this._active || [];\n  }\n  setActiveElements(activeElements, eventPosition) {\n    const lastActive = this._active;\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.chart.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('Cannot find a dataset at index ' + datasetIndex);\n      }\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(lastActive, active);\n    const positionChanged = this._positionChanged(active, eventPosition);\n    if (changed || positionChanged) {\n      this._active = active;\n      this._eventPosition = eventPosition;\n      this._ignoreReplayEvents = true;\n      this.update(true);\n    }\n  }\n  handleEvent(e, replay, inChartArea = true) {\n    if (replay && this._ignoreReplayEvents) {\n      return false;\n    }\n    this._ignoreReplayEvents = false;\n    const options = this.options;\n    const lastActive = this._active || [];\n    const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n    const positionChanged = this._positionChanged(active, e);\n    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n    if (changed) {\n      this._active = active;\n      if (options.enabled || options.external) {\n        this._eventPosition = {\n          x: e.x,\n          y: e.y\n        };\n        this.update(true, replay);\n      }\n    }\n    return changed;\n  }\n  _getActiveElements(e, lastActive, replay, inChartArea) {\n    const options = this.options;\n    if (e.type === 'mouseout') {\n      return [];\n    }\n    if (!inChartArea) {\n      return lastActive;\n    }\n    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n    if (options.reverse) {\n      active.reverse();\n    }\n    return active;\n  }\n  _positionChanged(active, e) {\n    const {caretX, caretY, options} = this;\n    const position = positioners[options.position].call(this, active, e);\n    return position !== false && (caretX !== position.x || caretY !== position.y);\n  }\n}\nTooltip.positioners = positioners;\nvar plugin_tooltip = {\n  id: 'tooltip',\n  _element: Tooltip,\n  positioners,\n  afterInit(chart, _args, options) {\n    if (options) {\n      chart.tooltip = new Tooltip({chart, options});\n    }\n  },\n  beforeUpdate(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n  reset(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n  afterDraw(chart) {\n    const tooltip = chart.tooltip;\n    if (tooltip && tooltip._willRender()) {\n      const args = {\n        tooltip\n      };\n      if (chart.notifyPlugins('beforeTooltipDraw', args) === false) {\n        return;\n      }\n      tooltip.draw(chart.ctx);\n      chart.notifyPlugins('afterTooltipDraw', args);\n    }\n  },\n  afterEvent(chart, args) {\n    if (chart.tooltip) {\n      const useFinalPosition = args.replay;\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n        args.changed = true;\n      }\n    }\n  },\n  defaults: {\n    enabled: true,\n    external: null,\n    position: 'average',\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    titleColor: '#fff',\n    titleFont: {\n      weight: 'bold',\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: 'left',\n    bodyColor: '#fff',\n    bodySpacing: 2,\n    bodyFont: {\n    },\n    bodyAlign: 'left',\n    footerColor: '#fff',\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: 'bold',\n    },\n    footerAlign: 'left',\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\n    multiKeyBackground: '#fff',\n    displayColors: true,\n    boxPadding: 0,\n    borderColor: 'rgba(0,0,0,0)',\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: 'easeOutQuart',\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\n      },\n      opacity: {\n        easing: 'linear',\n        duration: 200\n      }\n    },\n    callbacks: {\n      beforeTitle: noop,\n      title(tooltipItems) {\n        if (tooltipItems.length > 0) {\n          const item = tooltipItems[0];\n          const labels = item.chart.data.labels;\n          const labelCount = labels ? labels.length : 0;\n          if (this && this.options && this.options.mode === 'dataset') {\n            return item.dataset.label || '';\n          } else if (item.label) {\n            return item.label;\n          } else if (labelCount > 0 && item.dataIndex < labelCount) {\n            return labels[item.dataIndex];\n          }\n        }\n        return '';\n      },\n      afterTitle: noop,\n      beforeBody: noop,\n      beforeLabel: noop,\n      label(tooltipItem) {\n        if (this && this.options && this.options.mode === 'dataset') {\n          return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n        }\n        let label = tooltipItem.dataset.label || '';\n        if (label) {\n          label += ': ';\n        }\n        const value = tooltipItem.formattedValue;\n        if (!isNullOrUndef(value)) {\n          label += value;\n        }\n        return label;\n      },\n      labelColor(tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n          borderColor: options.borderColor,\n          backgroundColor: options.backgroundColor,\n          borderWidth: options.borderWidth,\n          borderDash: options.borderDash,\n          borderDashOffset: options.borderDashOffset,\n          borderRadius: 0,\n        };\n      },\n      labelTextColor() {\n        return this.options.bodyColor;\n      },\n      labelPointStyle(tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n          pointStyle: options.pointStyle,\n          rotation: options.rotation,\n        };\n      },\n      afterLabel: noop,\n      afterBody: noop,\n      beforeFooter: noop,\n      footer: noop,\n      afterFooter: noop\n    }\n  },\n  defaultRoutes: {\n    bodyFont: 'font',\n    footerFont: 'font',\n    titleFont: 'font'\n  },\n  descriptors: {\n    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\n    _indexable: false,\n    callbacks: {\n      _scriptable: false,\n      _indexable: false,\n    },\n    animation: {\n      _fallback: false\n    },\n    animations: {\n      _fallback: 'animation'\n    }\n  },\n  additionalOptionScopes: ['interaction']\n};\n\nvar plugins = /*#__PURE__*/Object.freeze({\n__proto__: null,\nDecimation: plugin_decimation,\nFiller: index,\nLegend: plugin_legend,\nSubTitle: plugin_subtitle,\nTitle: plugin_title,\nTooltip: plugin_tooltip\n});\n\nconst addIfString = (labels, raw, index, addedLabels) => {\n  if (typeof raw === 'string') {\n    index = labels.push(raw) - 1;\n    addedLabels.unshift({index, label: raw});\n  } else if (isNaN(raw)) {\n    index = null;\n  }\n  return index;\n};\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n  const first = labels.indexOf(raw);\n  if (first === -1) {\n    return addIfString(labels, raw, index, addedLabels);\n  }\n  const last = labels.lastIndexOf(raw);\n  return first !== last ? index : first;\n}\nconst validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\nclass CategoryScale extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this._startValue = undefined;\n    this._valueRange = 0;\n    this._addedLabels = [];\n  }\n  init(scaleOptions) {\n    const added = this._addedLabels;\n    if (added.length) {\n      const labels = this.getLabels();\n      for (const {index, label} of added) {\n        if (labels[index] === label) {\n          labels.splice(index, 1);\n        }\n      }\n      this._addedLabels = [];\n    }\n    super.init(scaleOptions);\n  }\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    const labels = this.getLabels();\n    index = isFinite(index) && labels[index] === raw ? index\n      : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\n    return validIndex(index, labels.length - 1);\n  }\n  determineDataLimits() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this.getMinMax(true);\n    if (this.options.bounds === 'ticks') {\n      if (!minDefined) {\n        min = 0;\n      }\n      if (!maxDefined) {\n        max = this.getLabels().length - 1;\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n  buildTicks() {\n    const min = this.min;\n    const max = this.max;\n    const offset = this.options.offset;\n    const ticks = [];\n    let labels = this.getLabels();\n    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\n    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n    this._startValue = this.min - (offset ? 0.5 : 0);\n    for (let value = min; value <= max; value++) {\n      ticks.push({value});\n    }\n    return ticks;\n  }\n  getLabelForValue(value) {\n    const labels = this.getLabels();\n    if (value >= 0 && value < labels.length) {\n      return labels[value];\n    }\n    return value;\n  }\n  configure() {\n    super.configure();\n    if (!this.isHorizontal()) {\n      this._reversePixels = !this._reversePixels;\n    }\n  }\n  getPixelForValue(value) {\n    if (typeof value !== 'number') {\n      value = this.parse(value);\n    }\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n  getValueForPixel(pixel) {\n    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n  }\n  getBasePixel() {\n    return this.bottom;\n  }\n}\nCategoryScale.id = 'category';\nCategoryScale.defaults = {\n  ticks: {\n    callback: CategoryScale.prototype.getLabelForValue\n  }\n};\n\nfunction generateTicks$1(generationOptions, dataRange) {\n  const ticks = [];\n  const MIN_SPACING = 1e-14;\n  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;\n  const unit = step || 1;\n  const maxSpaces = maxTicks - 1;\n  const {min: rmin, max: rmax} = dataRange;\n  const minDefined = !isNullOrUndef(min);\n  const maxDefined = !isNullOrUndef(max);\n  const countDefined = !isNullOrUndef(count);\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\n  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n  let factor, niceMin, niceMax, numSpaces;\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n    return [{value: rmin}, {value: rmax}];\n  }\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n  if (numSpaces > maxSpaces) {\n    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n  }\n  if (!isNullOrUndef(precision)) {\n    factor = Math.pow(10, precision);\n    spacing = Math.ceil(spacing * factor) / factor;\n  }\n  if (bounds === 'ticks') {\n    niceMin = Math.floor(rmin / spacing) * spacing;\n    niceMax = Math.ceil(rmax / spacing) * spacing;\n  } else {\n    niceMin = rmin;\n    niceMax = rmax;\n  }\n  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n    spacing = (max - min) / numSpaces;\n    niceMin = min;\n    niceMax = max;\n  } else if (countDefined) {\n    niceMin = minDefined ? min : niceMin;\n    niceMax = maxDefined ? max : niceMax;\n    numSpaces = count - 1;\n    spacing = (niceMax - niceMin) / numSpaces;\n  } else {\n    numSpaces = (niceMax - niceMin) / spacing;\n    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n      numSpaces = Math.round(numSpaces);\n    } else {\n      numSpaces = Math.ceil(numSpaces);\n    }\n  }\n  const decimalPlaces = Math.max(\n    _decimalPlaces(spacing),\n    _decimalPlaces(niceMin)\n  );\n  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n  niceMin = Math.round(niceMin * factor) / factor;\n  niceMax = Math.round(niceMax * factor) / factor;\n  let j = 0;\n  if (minDefined) {\n    if (includeBounds && niceMin !== min) {\n      ticks.push({value: min});\n      if (niceMin < min) {\n        j++;\n      }\n      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n        j++;\n      }\n    } else if (niceMin < min) {\n      j++;\n    }\n  }\n  for (; j < numSpaces; ++j) {\n    ticks.push({value: Math.round((niceMin + j * spacing) * factor) / factor});\n  }\n  if (maxDefined && includeBounds && niceMax !== max) {\n    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n      ticks[ticks.length - 1].value = max;\n    } else {\n      ticks.push({value: max});\n    }\n  } else if (!maxDefined || niceMax === max) {\n    ticks.push({value: niceMax});\n  }\n  return ticks;\n}\nfunction relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {\n  const rad = toRadians(minRotation);\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n  const length = 0.75 * minSpacing * ('' + value).length;\n  return Math.min(minSpacing / ratio, length);\n}\nclass LinearScaleBase extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this.start = undefined;\n    this.end = undefined;\n    this._startValue = undefined;\n    this._endValue = undefined;\n    this._valueRange = 0;\n  }\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n      return null;\n    }\n    return +raw;\n  }\n  handleTickRangeOptions() {\n    const {beginAtZero} = this.options;\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this;\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n    if (beginAtZero) {\n      const minSign = sign(min);\n      const maxSign = sign(max);\n      if (minSign < 0 && maxSign < 0) {\n        setMax(0);\n      } else if (minSign > 0 && maxSign > 0) {\n        setMin(0);\n      }\n    }\n    if (min === max) {\n      let offset = 1;\n      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {\n        offset = Math.abs(max * 0.05);\n      }\n      setMax(max + offset);\n      if (!beginAtZero) {\n        setMin(min - offset);\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n  getTickLimit() {\n    const tickOpts = this.options.ticks;\n    let {maxTicksLimit, stepSize} = tickOpts;\n    let maxTicks;\n    if (stepSize) {\n      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n      if (maxTicks > 1000) {\n        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n        maxTicks = 1000;\n      }\n    } else {\n      maxTicks = this.computeTickLimit();\n      maxTicksLimit = maxTicksLimit || 11;\n    }\n    if (maxTicksLimit) {\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\n    }\n    return maxTicks;\n  }\n  computeTickLimit() {\n    return Number.POSITIVE_INFINITY;\n  }\n  buildTicks() {\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n    let maxTicks = this.getTickLimit();\n    maxTicks = Math.max(2, maxTicks);\n    const numericGeneratorOptions = {\n      maxTicks,\n      bounds: opts.bounds,\n      min: opts.min,\n      max: opts.max,\n      precision: tickOpts.precision,\n      step: tickOpts.stepSize,\n      count: tickOpts.count,\n      maxDigits: this._maxDigits(),\n      horizontal: this.isHorizontal(),\n      minRotation: tickOpts.minRotation || 0,\n      includeBounds: tickOpts.includeBounds !== false\n    };\n    const dataRange = this._range || this;\n    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n    if (opts.reverse) {\n      ticks.reverse();\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n    return ticks;\n  }\n  configure() {\n    const ticks = this.ticks;\n    let start = this.min;\n    let end = this.max;\n    super.configure();\n    if (this.options.offset && ticks.length) {\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n      start -= offset;\n      end += offset;\n    }\n    this._startValue = start;\n    this._endValue = end;\n    this._valueRange = end - start;\n  }\n  getLabelForValue(value) {\n    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n}\n\nclass LinearScale extends LinearScaleBase {\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n    this.min = isNumberFinite(min) ? min : 0;\n    this.max = isNumberFinite(max) ? max : 1;\n    this.handleTickRangeOptions();\n  }\n  computeTickLimit() {\n    const horizontal = this.isHorizontal();\n    const length = horizontal ? this.width : this.height;\n    const minRotation = toRadians(this.options.ticks.minRotation);\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n    const tickFont = this._resolveTickFontOptions(0);\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n  }\n  getPixelForValue(value) {\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n  getValueForPixel(pixel) {\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n  }\n}\nLinearScale.id = 'linear';\nLinearScale.defaults = {\n  ticks: {\n    callback: Ticks.formatters.numeric\n  }\n};\n\nfunction isMajor(tickVal) {\n  const remain = tickVal / (Math.pow(10, Math.floor(log10(tickVal))));\n  return remain === 1;\n}\nfunction generateTicks(generationOptions, dataRange) {\n  const endExp = Math.floor(log10(dataRange.max));\n  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n  const ticks = [];\n  let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));\n  let exp = Math.floor(log10(tickVal));\n  let significand = Math.floor(tickVal / Math.pow(10, exp));\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n  do {\n    ticks.push({value: tickVal, major: isMajor(tickVal)});\n    ++significand;\n    if (significand === 10) {\n      significand = 1;\n      ++exp;\n      precision = exp >= 0 ? 1 : precision;\n    }\n    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n  } while (exp < endExp || (exp === endExp && significand < endSignificand));\n  const lastTick = finiteOrDefault(generationOptions.max, tickVal);\n  ticks.push({value: lastTick, major: isMajor(tickVal)});\n  return ticks;\n}\nclass LogarithmicScale extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this.start = undefined;\n    this.end = undefined;\n    this._startValue = undefined;\n    this._valueRange = 0;\n  }\n  parse(raw, index) {\n    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\n    if (value === 0) {\n      this._zero = true;\n      return undefined;\n    }\n    return isNumberFinite(value) && value > 0 ? value : null;\n  }\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n    this.min = isNumberFinite(min) ? Math.max(0, min) : null;\n    this.max = isNumberFinite(max) ? Math.max(0, max) : null;\n    if (this.options.beginAtZero) {\n      this._zero = true;\n    }\n    this.handleTickRangeOptions();\n  }\n  handleTickRangeOptions() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let min = this.min;\n    let max = this.max;\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n    const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);\n    if (min === max) {\n      if (min <= 0) {\n        setMin(1);\n        setMax(10);\n      } else {\n        setMin(exp(min, -1));\n        setMax(exp(max, +1));\n      }\n    }\n    if (min <= 0) {\n      setMin(exp(max, -1));\n    }\n    if (max <= 0) {\n      setMax(exp(min, +1));\n    }\n    if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {\n      setMin(exp(min, -1));\n    }\n    this.min = min;\n    this.max = max;\n  }\n  buildTicks() {\n    const opts = this.options;\n    const generationOptions = {\n      min: this._userMin,\n      max: this._userMax\n    };\n    const ticks = generateTicks(generationOptions, this);\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n    if (opts.reverse) {\n      ticks.reverse();\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n    return ticks;\n  }\n  getLabelForValue(value) {\n    return value === undefined\n      ? '0'\n      : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n  configure() {\n    const start = this.min;\n    super.configure();\n    this._startValue = log10(start);\n    this._valueRange = log10(this.max) - log10(start);\n  }\n  getPixelForValue(value) {\n    if (value === undefined || value === 0) {\n      value = this.min;\n    }\n    if (value === null || isNaN(value)) {\n      return NaN;\n    }\n    return this.getPixelForDecimal(value === this.min\n      ? 0\n      : (log10(value) - this._startValue) / this._valueRange);\n  }\n  getValueForPixel(pixel) {\n    const decimal = this.getDecimalForPixel(pixel);\n    return Math.pow(10, this._startValue + decimal * this._valueRange);\n  }\n}\nLogarithmicScale.id = 'logarithmic';\nLogarithmicScale.defaults = {\n  ticks: {\n    callback: Ticks.formatters.logarithmic,\n    major: {\n      enabled: true\n    }\n  }\n};\n\nfunction getTickBackdropHeight(opts) {\n  const tickOpts = opts.ticks;\n  if (tickOpts.display && opts.display) {\n    const padding = toPadding(tickOpts.backdropPadding);\n    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n  }\n  return 0;\n}\nfunction measureLabelSize(ctx, font, label) {\n  label = isArray(label) ? label : [label];\n  return {\n    w: _longestText(ctx, font.string, label),\n    h: label.length * font.lineHeight\n  };\n}\nfunction determineLimits(angle, pos, size, min, max) {\n  if (angle === min || angle === max) {\n    return {\n      start: pos - (size / 2),\n      end: pos + (size / 2)\n    };\n  } else if (angle < min || angle > max) {\n    return {\n      start: pos - size,\n      end: pos\n    };\n  }\n  return {\n    start: pos,\n    end: pos + size\n  };\n}\nfunction fitWithPointLabels(scale) {\n  const orig = {\n    l: scale.left + scale._padding.left,\n    r: scale.right - scale._padding.right,\n    t: scale.top + scale._padding.top,\n    b: scale.bottom - scale._padding.bottom\n  };\n  const limits = Object.assign({}, orig);\n  const labelSizes = [];\n  const padding = [];\n  const valueCount = scale._pointLabels.length;\n  const pointLabelOpts = scale.options.pointLabels;\n  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\n  for (let i = 0; i < valueCount; i++) {\n    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n    padding[i] = opts.padding;\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n    const plFont = toFont(opts.font);\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n    labelSizes[i] = textSize;\n    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\n    const angle = Math.round(toDegrees(angleRadians));\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n    updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n  }\n  scale.setCenterPoint(\n    orig.l - limits.l,\n    limits.r - orig.r,\n    orig.t - limits.t,\n    limits.b - orig.b\n  );\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n  const sin = Math.abs(Math.sin(angle));\n  const cos = Math.abs(Math.cos(angle));\n  let x = 0;\n  let y = 0;\n  if (hLimits.start < orig.l) {\n    x = (orig.l - hLimits.start) / sin;\n    limits.l = Math.min(limits.l, orig.l - x);\n  } else if (hLimits.end > orig.r) {\n    x = (hLimits.end - orig.r) / sin;\n    limits.r = Math.max(limits.r, orig.r + x);\n  }\n  if (vLimits.start < orig.t) {\n    y = (orig.t - vLimits.start) / cos;\n    limits.t = Math.min(limits.t, orig.t - y);\n  } else if (vLimits.end > orig.b) {\n    y = (vLimits.end - orig.b) / cos;\n    limits.b = Math.max(limits.b, orig.b + y);\n  }\n}\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n  const items = [];\n  const valueCount = scale._pointLabels.length;\n  const opts = scale.options;\n  const extra = getTickBackdropHeight(opts) / 2;\n  const outerDistance = scale.drawingArea;\n  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;\n  for (let i = 0; i < valueCount; i++) {\n    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);\n    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\n    const size = labelSizes[i];\n    const y = yForAngle(pointLabelPosition.y, size.h, angle);\n    const textAlign = getTextAlignForAngle(angle);\n    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n    items.push({\n      x: pointLabelPosition.x,\n      y,\n      textAlign,\n      left,\n      top: y,\n      right: left + size.w,\n      bottom: y + size.h\n    });\n  }\n  return items;\n}\nfunction getTextAlignForAngle(angle) {\n  if (angle === 0 || angle === 180) {\n    return 'center';\n  } else if (angle < 180) {\n    return 'left';\n  }\n  return 'right';\n}\nfunction leftForTextAlign(x, w, align) {\n  if (align === 'right') {\n    x -= w;\n  } else if (align === 'center') {\n    x -= (w / 2);\n  }\n  return x;\n}\nfunction yForAngle(y, h, angle) {\n  if (angle === 90 || angle === 270) {\n    y -= (h / 2);\n  } else if (angle > 270 || angle < 90) {\n    y -= h;\n  }\n  return y;\n}\nfunction drawPointLabels(scale, labelCount) {\n  const {ctx, options: {pointLabels}} = scale;\n  for (let i = labelCount - 1; i >= 0; i--) {\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n    const plFont = toFont(optsAtIndex.font);\n    const {x, y, textAlign, left, top, right, bottom} = scale._pointLabelItems[i];\n    const {backdropColor} = optsAtIndex;\n    if (!isNullOrUndef(backdropColor)) {\n      const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);\n      const padding = toPadding(optsAtIndex.backdropPadding);\n      ctx.fillStyle = backdropColor;\n      const backdropLeft = left - padding.left;\n      const backdropTop = top - padding.top;\n      const backdropWidth = right - left + padding.width;\n      const backdropHeight = bottom - top + padding.height;\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        addRoundedRectPath(ctx, {\n          x: backdropLeft,\n          y: backdropTop,\n          w: backdropWidth,\n          h: backdropHeight,\n          radius: borderRadius,\n        });\n        ctx.fill();\n      } else {\n        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n      }\n    }\n    renderText(\n      ctx,\n      scale._pointLabels[i],\n      x,\n      y + (plFont.lineHeight / 2),\n      plFont,\n      {\n        color: optsAtIndex.color,\n        textAlign: textAlign,\n        textBaseline: 'middle'\n      }\n    );\n  }\n}\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n  const {ctx} = scale;\n  if (circular) {\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n  } else {\n    let pointPosition = scale.getPointPosition(0, radius);\n    ctx.moveTo(pointPosition.x, pointPosition.y);\n    for (let i = 1; i < labelCount; i++) {\n      pointPosition = scale.getPointPosition(i, radius);\n      ctx.lineTo(pointPosition.x, pointPosition.y);\n    }\n  }\n}\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount) {\n  const ctx = scale.ctx;\n  const circular = gridLineOpts.circular;\n  const {color, lineWidth} = gridLineOpts;\n  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\n    return;\n  }\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = lineWidth;\n  ctx.setLineDash(gridLineOpts.borderDash);\n  ctx.lineDashOffset = gridLineOpts.borderDashOffset;\n  ctx.beginPath();\n  pathRadiusLine(scale, radius, circular, labelCount);\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\nfunction createPointLabelContext(parent, index, label) {\n  return createContext(parent, {\n    label,\n    index,\n    type: 'pointLabel'\n  });\n}\nclass RadialLinearScale extends LinearScaleBase {\n  constructor(cfg) {\n    super(cfg);\n    this.xCenter = undefined;\n    this.yCenter = undefined;\n    this.drawingArea = undefined;\n    this._pointLabels = [];\n    this._pointLabelItems = [];\n  }\n  setDimensions() {\n    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\n    const w = this.width = this.maxWidth - padding.width;\n    const h = this.height = this.maxHeight - padding.height;\n    this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n    this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n    this.drawingArea = Math.floor(Math.min(w, h) / 2);\n  }\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(false);\n    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;\n    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;\n    this.handleTickRangeOptions();\n  }\n  computeTickLimit() {\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n  }\n  generateTickLabels(ticks) {\n    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n    this._pointLabels = this.getLabels()\n      .map((value, index) => {\n        const label = callback(this.options.pointLabels.callback, [value, index], this);\n        return label || label === 0 ? label : '';\n      })\n      .filter((v, i) => this.chart.getDataVisibility(i));\n  }\n  fit() {\n    const opts = this.options;\n    if (opts.display && opts.pointLabels.display) {\n      fitWithPointLabels(this);\n    } else {\n      this.setCenterPoint(0, 0, 0, 0);\n    }\n  }\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n  }\n  getIndexAngle(index) {\n    const angleMultiplier = TAU / (this._pointLabels.length || 1);\n    const startAngle = this.options.startAngle || 0;\n    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n  }\n  getDistanceFromCenterForValue(value) {\n    if (isNullOrUndef(value)) {\n      return NaN;\n    }\n    const scalingFactor = this.drawingArea / (this.max - this.min);\n    if (this.options.reverse) {\n      return (this.max - value) * scalingFactor;\n    }\n    return (value - this.min) * scalingFactor;\n  }\n  getValueForDistanceFromCenter(distance) {\n    if (isNullOrUndef(distance)) {\n      return NaN;\n    }\n    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n  }\n  getPointLabelContext(index) {\n    const pointLabels = this._pointLabels || [];\n    if (index >= 0 && index < pointLabels.length) {\n      const pointLabel = pointLabels[index];\n      return createPointLabelContext(this.getContext(), index, pointLabel);\n    }\n  }\n  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\n    return {\n      x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n      y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n      angle\n    };\n  }\n  getPointPositionForValue(index, value) {\n    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n  }\n  getBasePosition(index) {\n    return this.getPointPositionForValue(index || 0, this.getBaseValue());\n  }\n  getPointLabelPosition(index) {\n    const {left, top, right, bottom} = this._pointLabelItems[index];\n    return {\n      left,\n      top,\n      right,\n      bottom,\n    };\n  }\n  drawBackground() {\n    const {backgroundColor, grid: {circular}} = this.options;\n    if (backgroundColor) {\n      const ctx = this.ctx;\n      ctx.save();\n      ctx.beginPath();\n      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n      ctx.closePath();\n      ctx.fillStyle = backgroundColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n  drawGrid() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const {angleLines, grid} = opts;\n    const labelCount = this._pointLabels.length;\n    let i, offset, position;\n    if (opts.pointLabels.display) {\n      drawPointLabels(this, labelCount);\n    }\n    if (grid.display) {\n      this.ticks.forEach((tick, index) => {\n        if (index !== 0) {\n          offset = this.getDistanceFromCenterForValue(tick.value);\n          const optsAtIndex = grid.setContext(this.getContext(index - 1));\n          drawRadiusLine(this, optsAtIndex, offset, labelCount);\n        }\n      });\n    }\n    if (angleLines.display) {\n      ctx.save();\n      for (i = labelCount - 1; i >= 0; i--) {\n        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n        const {color, lineWidth} = optsAtIndex;\n        if (!lineWidth || !color) {\n          continue;\n        }\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = color;\n        ctx.setLineDash(optsAtIndex.borderDash);\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);\n        position = this.getPointPosition(i, offset);\n        ctx.beginPath();\n        ctx.moveTo(this.xCenter, this.yCenter);\n        ctx.lineTo(position.x, position.y);\n        ctx.stroke();\n      }\n      ctx.restore();\n    }\n  }\n  drawBorder() {}\n  drawLabels() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n    if (!tickOpts.display) {\n      return;\n    }\n    const startAngle = this.getIndexAngle(0);\n    let offset, width;\n    ctx.save();\n    ctx.translate(this.xCenter, this.yCenter);\n    ctx.rotate(startAngle);\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    this.ticks.forEach((tick, index) => {\n      if (index === 0 && !opts.reverse) {\n        return;\n      }\n      const optsAtIndex = tickOpts.setContext(this.getContext(index));\n      const tickFont = toFont(optsAtIndex.font);\n      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n      if (optsAtIndex.showLabelBackdrop) {\n        ctx.font = tickFont.string;\n        width = ctx.measureText(tick.label).width;\n        ctx.fillStyle = optsAtIndex.backdropColor;\n        const padding = toPadding(optsAtIndex.backdropPadding);\n        ctx.fillRect(\n          -width / 2 - padding.left,\n          -offset - tickFont.size / 2 - padding.top,\n          width + padding.width,\n          tickFont.size + padding.height\n        );\n      }\n      renderText(ctx, tick.label, 0, -offset, tickFont, {\n        color: optsAtIndex.color,\n      });\n    });\n    ctx.restore();\n  }\n  drawTitle() {}\n}\nRadialLinearScale.id = 'radialLinear';\nRadialLinearScale.defaults = {\n  display: true,\n  animate: true,\n  position: 'chartArea',\n  angleLines: {\n    display: true,\n    lineWidth: 1,\n    borderDash: [],\n    borderDashOffset: 0.0\n  },\n  grid: {\n    circular: false\n  },\n  startAngle: 0,\n  ticks: {\n    showLabelBackdrop: true,\n    callback: Ticks.formatters.numeric\n  },\n  pointLabels: {\n    backdropColor: undefined,\n    backdropPadding: 2,\n    display: true,\n    font: {\n      size: 10\n    },\n    callback(label) {\n      return label;\n    },\n    padding: 5,\n    centerPointLabels: false\n  }\n};\nRadialLinearScale.defaultRoutes = {\n  'angleLines.color': 'borderColor',\n  'pointLabels.color': 'color',\n  'ticks.color': 'color'\n};\nRadialLinearScale.descriptors = {\n  angleLines: {\n    _fallback: 'grid'\n  }\n};\n\nconst INTERVALS = {\n  millisecond: {common: true, size: 1, steps: 1000},\n  second: {common: true, size: 1000, steps: 60},\n  minute: {common: true, size: 60000, steps: 60},\n  hour: {common: true, size: 3600000, steps: 24},\n  day: {common: true, size: 86400000, steps: 30},\n  week: {common: false, size: 604800000, steps: 4},\n  month: {common: true, size: 2.628e9, steps: 12},\n  quarter: {common: false, size: 7.884e9, steps: 4},\n  year: {common: true, size: 3.154e10}\n};\nconst UNITS = (Object.keys(INTERVALS));\nfunction sorter(a, b) {\n  return a - b;\n}\nfunction parse(scale, input) {\n  if (isNullOrUndef(input)) {\n    return null;\n  }\n  const adapter = scale._adapter;\n  const {parser, round, isoWeekday} = scale._parseOpts;\n  let value = input;\n  if (typeof parser === 'function') {\n    value = parser(value);\n  }\n  if (!isNumberFinite(value)) {\n    value = typeof parser === 'string'\n      ? adapter.parse(value, parser)\n      : adapter.parse(value);\n  }\n  if (value === null) {\n    return null;\n  }\n  if (round) {\n    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)\n      ? adapter.startOf(value, 'isoWeek', isoWeekday)\n      : adapter.startOf(value, round);\n  }\n  return +value;\n}\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const ilen = UNITS.length;\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const interval = INTERVALS[UNITS[i]];\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n  return UNITS[ilen - 1];\n}\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n    const unit = UNITS[i];\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n      return unit;\n    }\n  }\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {lo, hi} = _lookup(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n  const adapter = scale._adapter;\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\n  const last = ticks[ticks.length - 1].value;\n  let major, index;\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n    index = map[major];\n    if (index >= 0) {\n      ticks[index].major = true;\n    }\n  }\n  return ticks;\n}\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n  const ticks = [];\n  const map = {};\n  const ilen = values.length;\n  let i, value;\n  for (i = 0; i < ilen; ++i) {\n    value = values[i];\n    map[value] = i;\n    ticks.push({\n      value,\n      major: false\n    });\n  }\n  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\nclass TimeScale extends Scale {\n  constructor(props) {\n    super(props);\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n    this._unit = 'day';\n    this._majorUnit = undefined;\n    this._offsets = {};\n    this._normalized = false;\n    this._parseOpts = undefined;\n  }\n  init(scaleOpts, opts) {\n    const time = scaleOpts.time || (scaleOpts.time = {});\n    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n    adapter.init(opts);\n    mergeIf(time.displayFormats, adapter.formats());\n    this._parseOpts = {\n      parser: time.parser,\n      round: time.round,\n      isoWeekday: time.isoWeekday\n    };\n    super.init(scaleOpts);\n    this._normalized = opts.normalized;\n  }\n  parse(raw, index) {\n    if (raw === undefined) {\n      return null;\n    }\n    return parse(this, raw);\n  }\n  beforeLayout() {\n    super.beforeLayout();\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n  }\n  determineDataLimits() {\n    const options = this.options;\n    const adapter = this._adapter;\n    const unit = options.time.unit || 'day';\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    function _applyBounds(bounds) {\n      if (!minDefined && !isNaN(bounds.min)) {\n        min = Math.min(min, bounds.min);\n      }\n      if (!maxDefined && !isNaN(bounds.max)) {\n        max = Math.max(max, bounds.max);\n      }\n    }\n    if (!minDefined || !maxDefined) {\n      _applyBounds(this._getLabelBounds());\n      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n        _applyBounds(this.getMinMax(false));\n      }\n    }\n    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n    this.min = Math.min(min, max - 1);\n    this.max = Math.max(min + 1, max);\n  }\n  _getLabelBounds() {\n    const arr = this.getLabelTimestamps();\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n    if (arr.length) {\n      min = arr[0];\n      max = arr[arr.length - 1];\n    }\n    return {min, max};\n  }\n  buildTicks() {\n    const options = this.options;\n    const timeOpts = options.time;\n    const tickOpts = options.ticks;\n    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n    if (options.bounds === 'ticks' && timestamps.length) {\n      this.min = this._userMin || timestamps[0];\n      this.max = this._userMax || timestamps[timestamps.length - 1];\n    }\n    const min = this.min;\n    const max = this.max;\n    const ticks = _filterBetween(timestamps, min, max);\n    this._unit = timeOpts.unit || (tickOpts.autoSkip\n      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))\n      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined\n      : determineMajorUnit(this._unit);\n    this.initOffsets(timestamps);\n    if (options.reverse) {\n      ticks.reverse();\n    }\n    return ticksFromTimestamps(this, ticks, this._majorUnit);\n  }\n  afterAutoSkip() {\n    if (this.options.offsetAfterAutoskip) {\n      this.initOffsets(this.ticks.map(tick => +tick.value));\n    }\n  }\n  initOffsets(timestamps) {\n    let start = 0;\n    let end = 0;\n    let first, last;\n    if (this.options.offset && timestamps.length) {\n      first = this.getDecimalForValue(timestamps[0]);\n      if (timestamps.length === 1) {\n        start = 1 - first;\n      } else {\n        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n      }\n      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n      if (timestamps.length === 1) {\n        end = last;\n      } else {\n        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n      }\n    }\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\n    start = _limitValue(start, 0, limit);\n    end = _limitValue(end, 0, limit);\n    this._offsets = {start, end, factor: 1 / (start + 1 + end)};\n  }\n  _generate() {\n    const adapter = this._adapter;\n    const min = this.min;\n    const max = this.max;\n    const options = this.options;\n    const timeOpts = options.time;\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n    const stepSize = valueOrDefault(timeOpts.stepSize, 1);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const ticks = {};\n    let first = min;\n    let time, count;\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n    if (time === max || options.bounds === 'ticks' || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\n  }\n  getLabelForValue(value) {\n    const adapter = this._adapter;\n    const timeOpts = this.options.time;\n    if (timeOpts.tooltipFormat) {\n      return adapter.format(value, timeOpts.tooltipFormat);\n    }\n    return adapter.format(value, timeOpts.displayFormats.datetime);\n  }\n  _tickFormatFunction(time, index, ticks, format) {\n    const options = this.options;\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const majorUnit = this._majorUnit;\n    const minorFormat = unit && formats[unit];\n    const majorFormat = majorUnit && formats[majorUnit];\n    const tick = ticks[index];\n    const major = majorUnit && majorFormat && tick && tick.major;\n    const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n    const formatter = options.ticks.callback;\n    return formatter ? callback(formatter, [label, index, ticks], this) : label;\n  }\n  generateTickLabels(ticks) {\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\n    }\n  }\n  getDecimalForValue(value) {\n    return value === null ? NaN : (value - this.min) / (this.max - this.min);\n  }\n  getPixelForValue(value) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForValue(value);\n    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n  }\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return this.min + pos * (this.max - this.min);\n  }\n  _getLabelSize(label) {\n    const ticksOpts = this.options.ticks;\n    const tickLabelWidth = this.ctx.measureText(label).width;\n    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n    const cosRotation = Math.cos(angle);\n    const sinRotation = Math.sin(angle);\n    const tickFontSize = this._resolveTickFontOptions(0).size;\n    return {\n      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\n      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\n    };\n  }\n  _getLabelCapacity(exampleTime) {\n    const timeOpts = this.options.time;\n    const displayFormats = timeOpts.displayFormats;\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);\n    const size = this._getLabelSize(exampleLabel);\n    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n    return capacity > 0 ? capacity : 1;\n  }\n  getDataTimestamps() {\n    let timestamps = this._cache.data || [];\n    let i, ilen;\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const metas = this.getMatchingVisibleMetas();\n    if (this._normalized && metas.length) {\n      return (this._cache.data = metas[0].controller.getAllParsedValues(this));\n    }\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n    }\n    return (this._cache.data = this.normalize(timestamps));\n  }\n  getLabelTimestamps() {\n    const timestamps = this._cache.labels || [];\n    let i, ilen;\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const labels = this.getLabels();\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      timestamps.push(parse(this, labels[i]));\n    }\n    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));\n  }\n  normalize(values) {\n    return _arrayUnique(values.sort(sorter));\n  }\n}\nTimeScale.id = 'time';\nTimeScale.defaults = {\n  bounds: 'data',\n  adapters: {},\n  time: {\n    parser: false,\n    unit: false,\n    round: false,\n    isoWeekday: false,\n    minUnit: 'millisecond',\n    displayFormats: {}\n  },\n  ticks: {\n    source: 'auto',\n    major: {\n      enabled: false\n    }\n  }\n};\n\nfunction interpolate(table, val, reverse) {\n  let lo = 0;\n  let hi = table.length - 1;\n  let prevSource, nextSource, prevTarget, nextTarget;\n  if (reverse) {\n    if (val >= table[lo].pos && val <= table[hi].pos) {\n      ({lo, hi} = _lookupByKey(table, 'pos', val));\n    }\n    ({pos: prevSource, time: prevTarget} = table[lo]);\n    ({pos: nextSource, time: nextTarget} = table[hi]);\n  } else {\n    if (val >= table[lo].time && val <= table[hi].time) {\n      ({lo, hi} = _lookupByKey(table, 'time', val));\n    }\n    ({time: prevSource, pos: prevTarget} = table[lo]);\n    ({time: nextSource, pos: nextTarget} = table[hi]);\n  }\n  const span = nextSource - prevSource;\n  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\nclass TimeSeriesScale extends TimeScale {\n  constructor(props) {\n    super(props);\n    this._table = [];\n    this._minPos = undefined;\n    this._tableRange = undefined;\n  }\n  initOffsets() {\n    const timestamps = this._getTimestampsForTable();\n    const table = this._table = this.buildLookupTable(timestamps);\n    this._minPos = interpolate(table, this.min);\n    this._tableRange = interpolate(table, this.max) - this._minPos;\n    super.initOffsets(timestamps);\n  }\n  buildLookupTable(timestamps) {\n    const {min, max} = this;\n    const items = [];\n    const table = [];\n    let i, ilen, prev, curr, next;\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n      curr = timestamps[i];\n      if (curr >= min && curr <= max) {\n        items.push(curr);\n      }\n    }\n    if (items.length < 2) {\n      return [\n        {time: min, pos: 0},\n        {time: max, pos: 1}\n      ];\n    }\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      next = items[i + 1];\n      prev = items[i - 1];\n      curr = items[i];\n      if (Math.round((next + prev) / 2) !== curr) {\n        table.push({time: curr, pos: i / (ilen - 1)});\n      }\n    }\n    return table;\n  }\n  _getTimestampsForTable() {\n    let timestamps = this._cache.all || [];\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const data = this.getDataTimestamps();\n    const label = this.getLabelTimestamps();\n    if (data.length && label.length) {\n      timestamps = this.normalize(data.concat(label));\n    } else {\n      timestamps = data.length ? data : label;\n    }\n    timestamps = this._cache.all = timestamps;\n    return timestamps;\n  }\n  getDecimalForValue(value) {\n    return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n  }\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n  }\n}\nTimeSeriesScale.id = 'timeseries';\nTimeSeriesScale.defaults = TimeScale.defaults;\n\nvar scales = /*#__PURE__*/Object.freeze({\n__proto__: null,\nCategoryScale: CategoryScale,\nLinearScale: LinearScale,\nLogarithmicScale: LogarithmicScale,\nRadialLinearScale: RadialLinearScale,\nTimeScale: TimeScale,\nTimeSeriesScale: TimeSeriesScale\n});\n\nconst registerables = [\n  controllers,\n  elements,\n  plugins,\n  scales,\n];\n\nexport { Animation, Animations, ArcElement, BarController, BarElement, BasePlatform, BasicPlatform, BubbleController, CategoryScale, Chart, DatasetController, plugin_decimation as Decimation, DomPlatform, DoughnutController, Element, index as Filler, Interaction, plugin_legend as Legend, LineController, LineElement, LinearScale, LogarithmicScale, PieController, PointElement, PolarAreaController, RadarController, RadialLinearScale, Scale, ScatterController, plugin_subtitle as SubTitle, Ticks, TimeScale, TimeSeriesScale, plugin_title as Title, plugin_tooltip as Tooltip, adapters as _adapters, _detectPlatform, animator, controllers, elements, layouts, plugins, registerables, registry, scales };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}