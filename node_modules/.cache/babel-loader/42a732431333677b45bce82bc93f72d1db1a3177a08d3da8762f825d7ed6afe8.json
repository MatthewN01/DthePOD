{"ast":null,"code":"import { m as g, i as p, t as q, r as f, d as J, a as K, v as V, c as z, e as Y, A as Q, P as Z, B as ee, b as re } from \"./chart.es.js\";\n/*!\n * chartjs-plugin-datalabels v2.2.0\n * https://chartjs-plugin-datalabels.netlify.app\n * (c) 2017-2022 chartjs-plugin-datalabels contributors\n * Released under the MIT license\n */\nvar D = function () {\n    if (typeof window < \"u\") {\n      if (window.devicePixelRatio) return window.devicePixelRatio;\n      var e = window.screen;\n      if (e) return (e.deviceXDPI || 1) / (e.logicalXDPI || 1);\n    }\n    return 1;\n  }(),\n  m = {\n    // @todo move this in Chart.helpers.toTextLines\n    toTextLines: function toTextLines(e) {\n      var t = [],\n        r;\n      for (e = [].concat(e); e.length;) r = e.pop(), typeof r == \"string\" ? t.unshift.apply(t, r.split(\"\\n\")) : Array.isArray(r) ? e.push.apply(e, r) : p(e) || t.unshift(\"\" + r);\n      return t;\n    },\n    // @todo move this in Chart.helpers.canvas.textSize\n    // @todo cache calls of measureText if font doesn't change?!\n    textSize: function textSize(e, t, r) {\n      var a = [].concat(t),\n        i = a.length,\n        n = e.font,\n        o = 0,\n        s;\n      for (e.font = r.string, s = 0; s < i; ++s) o = Math.max(e.measureText(a[s]).width, o);\n      return e.font = n, {\n        height: i * r.lineHeight,\n        width: o\n      };\n    },\n    /**\n     * Returns value bounded by min and max. This is equivalent to max(min, min(value, max)).\n     * @todo move this method in Chart.helpers.bound\n     * https://doc.qt.io/qt-5/qtglobal.html#qBound\n     */\n    bound: function bound(e, t, r) {\n      return Math.max(e, Math.min(t, r));\n    },\n    /**\n     * Returns an array of pair [value, state] where state is:\n     * * -1: value is only in a0 (removed)\n     * *  1: value is only in a1 (added)\n     */\n    arrayDiff: function arrayDiff(e, t) {\n      var r = e.slice(),\n        a = [],\n        i,\n        n,\n        o,\n        s;\n      for (i = 0, o = t.length; i < o; ++i) s = t[i], n = r.indexOf(s), n === -1 ? a.push([s, 1]) : r.splice(n, 1);\n      for (i = 0, o = r.length; i < o; ++i) a.push([r[i], -1]);\n      return a;\n    },\n    /**\n     * https://github.com/chartjs/chartjs-plugin-datalabels/issues/70\n     */\n    rasterize: function rasterize(e) {\n      return Math.round(e * D) / D;\n    }\n  };\nfunction A(e, t) {\n  var r = t.x,\n    a = t.y;\n  if (r === null) return {\n    x: 0,\n    y: -1\n  };\n  if (a === null) return {\n    x: 1,\n    y: 0\n  };\n  var i = e.x - r,\n    n = e.y - a,\n    o = Math.sqrt(i * i + n * n);\n  return {\n    x: o ? i / o : 0,\n    y: o ? n / o : -1\n  };\n}\nfunction ae(e, t, r, a, i) {\n  switch (i) {\n    case \"center\":\n      r = a = 0;\n      break;\n    case \"bottom\":\n      r = 0, a = 1;\n      break;\n    case \"right\":\n      r = 1, a = 0;\n      break;\n    case \"left\":\n      r = -1, a = 0;\n      break;\n    case \"top\":\n      r = 0, a = -1;\n      break;\n    case \"start\":\n      r = -r, a = -a;\n      break;\n    case \"end\":\n      break;\n    default:\n      i *= Math.PI / 180, r = Math.cos(i), a = Math.sin(i);\n      break;\n  }\n  return {\n    x: e,\n    y: t,\n    vx: r,\n    vy: a\n  };\n}\nvar te = 0,\n  j = 1,\n  N = 2,\n  O = 4,\n  F = 8;\nfunction M(e, t, r) {\n  var a = te;\n  return e < r.left ? a |= j : e > r.right && (a |= N), t < r.top ? a |= F : t > r.bottom && (a |= O), a;\n}\nfunction ie(e, t) {\n  for (var r = e.x0, a = e.y0, i = e.x1, n = e.y1, o = M(r, a, t), s = M(i, n, t), l, u, v; !(!(o | s) || o & s);) l = o || s, l & F ? (u = r + (i - r) * (t.top - a) / (n - a), v = t.top) : l & O ? (u = r + (i - r) * (t.bottom - a) / (n - a), v = t.bottom) : l & N ? (v = a + (n - a) * (t.right - r) / (i - r), u = t.right) : l & j && (v = a + (n - a) * (t.left - r) / (i - r), u = t.left), l === o ? (r = u, a = v, o = M(r, a, t)) : (i = u, n = v, s = M(i, n, t));\n  return {\n    x0: r,\n    x1: i,\n    y0: a,\n    y1: n\n  };\n}\nfunction P(e, t) {\n  var r = t.anchor,\n    a = e,\n    i,\n    n;\n  return t.clamp && (a = ie(a, t.area)), r === \"start\" ? (i = a.x0, n = a.y0) : r === \"end\" ? (i = a.x1, n = a.y1) : (i = (a.x0 + a.x1) / 2, n = (a.y0 + a.y1) / 2), ae(i, n, e.vx, e.vy, t.align);\n}\nvar E = {\n    arc: function arc(e, t) {\n      var r = (e.startAngle + e.endAngle) / 2,\n        a = Math.cos(r),\n        i = Math.sin(r),\n        n = e.innerRadius,\n        o = e.outerRadius;\n      return P({\n        x0: e.x + a * n,\n        y0: e.y + i * n,\n        x1: e.x + a * o,\n        y1: e.y + i * o,\n        vx: a,\n        vy: i\n      }, t);\n    },\n    point: function point(e, t) {\n      var r = A(e, t.origin),\n        a = r.x * e.options.radius,\n        i = r.y * e.options.radius;\n      return P({\n        x0: e.x - a,\n        y0: e.y - i,\n        x1: e.x + a,\n        y1: e.y + i,\n        vx: r.x,\n        vy: r.y\n      }, t);\n    },\n    bar: function bar(e, t) {\n      var r = A(e, t.origin),\n        a = e.x,\n        i = e.y,\n        n = 0,\n        o = 0;\n      return e.horizontal ? (a = Math.min(e.x, e.base), n = Math.abs(e.base - e.x)) : (i = Math.min(e.y, e.base), o = Math.abs(e.base - e.y)), P({\n        x0: a,\n        y0: i + o,\n        x1: a + n,\n        y1: i,\n        vx: r.x,\n        vy: r.y\n      }, t);\n    },\n    fallback: function fallback(e, t) {\n      var r = A(e, t.origin);\n      return P({\n        x0: e.x,\n        y0: e.y,\n        x1: e.x + (e.width || 0),\n        y1: e.y + (e.height || 0),\n        vx: r.x,\n        vy: r.y\n      }, t);\n    }\n  },\n  x = m.rasterize;\nfunction ne(e) {\n  var t = e.borderWidth || 0,\n    r = e.padding,\n    a = e.size.height,\n    i = e.size.width,\n    n = -i / 2,\n    o = -a / 2;\n  return {\n    frame: {\n      x: n - r.left - t,\n      y: o - r.top - t,\n      w: i + r.width + t * 2,\n      h: a + r.height + t * 2\n    },\n    text: {\n      x: n,\n      y: o,\n      w: i,\n      h: a\n    }\n  };\n}\nfunction oe(e, t) {\n  var r = t.chart.getDatasetMeta(t.datasetIndex).vScale;\n  if (!r) return null;\n  if (r.xCenter !== void 0 && r.yCenter !== void 0) return {\n    x: r.xCenter,\n    y: r.yCenter\n  };\n  var a = r.getBasePixel();\n  return e.horizontal ? {\n    x: a,\n    y: null\n  } : {\n    x: null,\n    y: a\n  };\n}\nfunction se(e) {\n  return e instanceof Q ? E.arc : e instanceof Z ? E.point : e instanceof ee ? E.bar : E.fallback;\n}\nfunction le(e, t, r, a, i, n) {\n  var o = Math.PI / 2;\n  if (n) {\n    var s = Math.min(n, i / 2, a / 2),\n      l = t + s,\n      u = r + s,\n      v = t + a - s,\n      d = r + i - s;\n    e.moveTo(t, u), l < v && u < d ? (e.arc(l, u, s, -Math.PI, -o), e.arc(v, u, s, -o, 0), e.arc(v, d, s, 0, o), e.arc(l, d, s, o, Math.PI)) : l < v ? (e.moveTo(l, r), e.arc(v, u, s, -o, o), e.arc(l, u, s, o, Math.PI + o)) : u < d ? (e.arc(l, u, s, -Math.PI, 0), e.arc(l, d, s, 0, Math.PI)) : e.arc(l, u, s, -Math.PI, Math.PI), e.closePath(), e.moveTo(t, r);\n  } else e.rect(t, r, a, i);\n}\nfunction ue(e, t, r) {\n  var a = r.backgroundColor,\n    i = r.borderColor,\n    n = r.borderWidth;\n  !a && (!i || !n) || (e.beginPath(), le(e, x(t.x) + n / 2, x(t.y) + n / 2, x(t.w) - n, x(t.h) - n, r.borderRadius), e.closePath(), a && (e.fillStyle = a, e.fill()), i && n && (e.strokeStyle = i, e.lineWidth = n, e.lineJoin = \"miter\", e.stroke()));\n}\nfunction ve(e, t, r) {\n  var a = r.lineHeight,\n    i = e.w,\n    n = e.x,\n    o = e.y + a / 2;\n  return t === \"center\" ? n += i / 2 : (t === \"end\" || t === \"right\") && (n += i), {\n    h: a,\n    w: i,\n    x: n,\n    y: o\n  };\n}\nfunction de(e, t, r) {\n  var a = e.shadowBlur,\n    i = r.stroked,\n    n = x(r.x),\n    o = x(r.y),\n    s = x(r.w);\n  i && e.strokeText(t, n, o, s), r.filled && (a && i && (e.shadowBlur = 0), e.fillText(t, n, o, s), a && i && (e.shadowBlur = a));\n}\nfunction fe(e, t, r, a) {\n  var i = a.textAlign,\n    n = a.color,\n    o = !!n,\n    s = a.font,\n    l = t.length,\n    u = a.textStrokeColor,\n    v = a.textStrokeWidth,\n    d = u && v,\n    y;\n  if (!(!l || !o && !d)) for (r = ve(r, i, s), e.font = s.string, e.textAlign = i, e.textBaseline = \"middle\", e.shadowBlur = a.textShadowBlur, e.shadowColor = a.textShadowColor, o && (e.fillStyle = n), d && (e.lineJoin = \"round\", e.lineWidth = v, e.strokeStyle = u), y = 0, l = t.length; y < l; ++y) de(e, t[y], {\n    stroked: d,\n    filled: o,\n    w: r.w,\n    x: r.x,\n    y: r.y + r.h * y\n  });\n}\nvar L = function L(e, t, r, a) {\n  var i = this;\n  i._config = e, i._index = a, i._model = null, i._rects = null, i._ctx = t, i._el = r;\n};\ng(L.prototype, {\n  /**\n   * @private\n   */\n  _modelize: function _modelize(e, t, r, a) {\n    var i = this,\n      n = i._index,\n      o = q(f([r.font, {}], a, n)),\n      s = f([r.color, J.color], a, n);\n    return {\n      align: f([r.align, \"center\"], a, n),\n      anchor: f([r.anchor, \"center\"], a, n),\n      area: a.chart.chartArea,\n      backgroundColor: f([r.backgroundColor, null], a, n),\n      borderColor: f([r.borderColor, null], a, n),\n      borderRadius: f([r.borderRadius, 0], a, n),\n      borderWidth: f([r.borderWidth, 0], a, n),\n      clamp: f([r.clamp, !1], a, n),\n      clip: f([r.clip, !1], a, n),\n      color: s,\n      display: e,\n      font: o,\n      lines: t,\n      offset: f([r.offset, 4], a, n),\n      opacity: f([r.opacity, 1], a, n),\n      origin: oe(i._el, a),\n      padding: K(f([r.padding, 4], a, n)),\n      positioner: se(i._el),\n      rotation: f([r.rotation, 0], a, n) * (Math.PI / 180),\n      size: m.textSize(i._ctx, t, o),\n      textAlign: f([r.textAlign, \"start\"], a, n),\n      textShadowBlur: f([r.textShadowBlur, 0], a, n),\n      textShadowColor: f([r.textShadowColor, s], a, n),\n      textStrokeColor: f([r.textStrokeColor, s], a, n),\n      textStrokeWidth: f([r.textStrokeWidth, 0], a, n)\n    };\n  },\n  update: function update(e) {\n    var t = this,\n      r = null,\n      a = null,\n      i = t._index,\n      n = t._config,\n      o,\n      s,\n      l,\n      u = f([n.display, !0], e, i);\n    u && (o = e.dataset.data[i], s = V(z(n.formatter, [o, e]), o), l = p(s) ? [] : m.toTextLines(s), l.length && (r = t._modelize(u, l, n, e), a = ne(r))), t._model = r, t._rects = a;\n  },\n  geometry: function geometry() {\n    return this._rects ? this._rects.frame : {};\n  },\n  rotation: function rotation() {\n    return this._model ? this._model.rotation : 0;\n  },\n  visible: function visible() {\n    return this._model && this._model.opacity;\n  },\n  model: function model() {\n    return this._model;\n  },\n  draw: function draw(e, t) {\n    var r = this,\n      a = e.ctx,\n      i = r._model,\n      n = r._rects,\n      o;\n    this.visible() && (a.save(), i.clip && (o = i.area, a.beginPath(), a.rect(o.left, o.top, o.right - o.left, o.bottom - o.top), a.clip()), a.globalAlpha = m.bound(0, i.opacity, 1), a.translate(x(t.x), x(t.y)), a.rotate(i.rotation), ue(a, n.frame, i), fe(a, i.lines, n.text, i), a.restore());\n  }\n});\nvar he = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  ye = Number.MAX_SAFE_INTEGER || 9007199254740991;\nfunction b(e, t, r) {\n  var a = Math.cos(r),\n    i = Math.sin(r),\n    n = t.x,\n    o = t.y;\n  return {\n    x: n + a * (e.x - n) - i * (e.y - o),\n    y: o + i * (e.x - n) + a * (e.y - o)\n  };\n}\nfunction W(e, t) {\n  var r = ye,\n    a = he,\n    i = t.origin,\n    n,\n    o,\n    s,\n    l,\n    u;\n  for (n = 0; n < e.length; ++n) o = e[n], s = o.x - i.x, l = o.y - i.y, u = t.vx * s + t.vy * l, r = Math.min(r, u), a = Math.max(a, u);\n  return {\n    min: r,\n    max: a\n  };\n}\nfunction I(e, t) {\n  var r = t.x - e.x,\n    a = t.y - e.y,\n    i = Math.sqrt(r * r + a * a);\n  return {\n    vx: (t.x - e.x) / i,\n    vy: (t.y - e.y) / i,\n    origin: e,\n    ln: i\n  };\n}\nvar G = function G() {\n  this._rotation = 0, this._rect = {\n    x: 0,\n    y: 0,\n    w: 0,\n    h: 0\n  };\n};\ng(G.prototype, {\n  center: function center() {\n    var e = this._rect;\n    return {\n      x: e.x + e.w / 2,\n      y: e.y + e.h / 2\n    };\n  },\n  update: function update(e, t, r) {\n    this._rotation = r, this._rect = {\n      x: t.x + e.x,\n      y: t.y + e.y,\n      w: t.w,\n      h: t.h\n    };\n  },\n  contains: function contains(e) {\n    var t = this,\n      r = 1,\n      a = t._rect;\n    return e = b(e, t.center(), -t._rotation), !(e.x < a.x - r || e.y < a.y - r || e.x > a.x + a.w + r * 2 || e.y > a.y + a.h + r * 2);\n  },\n  // Separating Axis Theorem\n  // https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169\n  intersects: function intersects(e) {\n    var t = this._points(),\n      r = e._points(),\n      a = [I(t[0], t[1]), I(t[0], t[3])],\n      i,\n      n,\n      o;\n    for (this._rotation !== e._rotation && a.push(I(r[0], r[1]), I(r[0], r[3])), i = 0; i < a.length; ++i) if (n = W(t, a[i]), o = W(r, a[i]), n.max < o.min || o.max < n.min) return !1;\n    return !0;\n  },\n  /**\n   * @private\n   */\n  _points: function _points() {\n    var e = this,\n      t = e._rect,\n      r = e._rotation,\n      a = e.center();\n    return [b({\n      x: t.x,\n      y: t.y\n    }, a, r), b({\n      x: t.x + t.w,\n      y: t.y\n    }, a, r), b({\n      x: t.x + t.w,\n      y: t.y + t.h\n    }, a, r), b({\n      x: t.x,\n      y: t.y + t.h\n    }, a, r)];\n  }\n});\nfunction H(e, t, r) {\n  var a = t.positioner(e, t),\n    i = a.vx,\n    n = a.vy;\n  if (!i && !n) return {\n    x: a.x,\n    y: a.y\n  };\n  var o = r.w,\n    s = r.h,\n    l = t.rotation,\n    u = Math.abs(o / 2 * Math.cos(l)) + Math.abs(s / 2 * Math.sin(l)),\n    v = Math.abs(o / 2 * Math.sin(l)) + Math.abs(s / 2 * Math.cos(l)),\n    d = 1 / Math.max(Math.abs(i), Math.abs(n));\n  return u *= i * d, v *= n * d, u += t.offset * i, v += t.offset * n, {\n    x: a.x + u,\n    y: a.y + v\n  };\n}\nfunction xe(e, t) {\n  var r, a, i, n;\n  for (r = e.length - 1; r >= 0; --r) for (i = e[r].$layout, a = r - 1; a >= 0 && i._visible; --a) n = e[a].$layout, n._visible && i._box.intersects(n._box) && t(i, n);\n  return e;\n}\nfunction _e(e) {\n  var t, r, a, i, n, o, s;\n  for (t = 0, r = e.length; t < r; ++t) a = e[t], i = a.$layout, i._visible && (s = new Proxy(a._el, {\n    get: function get(l, u) {\n      return l.getProps([u], !0)[u];\n    }\n  }), n = a.geometry(), o = H(s, a.model(), n), i._box.update(o, n, a.rotation()));\n  return xe(e, function (l, u) {\n    var v = l._hidable,\n      d = u._hidable;\n    v && d || d ? u._visible = !1 : v && (l._visible = !1);\n  });\n}\nvar w = {\n    prepare: function prepare(e) {\n      var t = [],\n        r,\n        a,\n        i,\n        n,\n        o;\n      for (r = 0, i = e.length; r < i; ++r) for (a = 0, n = e[r].length; a < n; ++a) o = e[r][a], t.push(o), o.$layout = {\n        _box: new G(),\n        _hidable: !1,\n        _visible: !0,\n        _set: r,\n        _idx: o._index\n      };\n      return t.sort(function (s, l) {\n        var u = s.$layout,\n          v = l.$layout;\n        return u._idx === v._idx ? v._set - u._set : v._idx - u._idx;\n      }), this.update(t), t;\n    },\n    update: function update(e) {\n      var t = !1,\n        r,\n        a,\n        i,\n        n,\n        o;\n      for (r = 0, a = e.length; r < a; ++r) i = e[r], n = i.model(), o = i.$layout, o._hidable = n && n.display === \"auto\", o._visible = i.visible(), t |= o._hidable;\n      t && _e(e);\n    },\n    lookup: function lookup(e, t) {\n      var r, a;\n      for (r = e.length - 1; r >= 0; --r) if (a = e[r].$layout, a && a._visible && a._box.contains(t)) return e[r];\n      return null;\n    },\n    draw: function draw(e, t) {\n      var r, a, i, n, o, s;\n      for (r = 0, a = t.length; r < a; ++r) i = t[r], n = i.$layout, n._visible && (o = i.geometry(), s = H(i._el, i.model(), o), n._box.update(s, o, i.rotation()), i.draw(e, s));\n    }\n  },\n  ce = function ce(e) {\n    if (p(e)) return null;\n    var t = e,\n      r,\n      a,\n      i;\n    if (re(e)) if (!p(e.label)) t = e.label;else if (!p(e.r)) t = e.r;else for (t = \"\", r = Object.keys(e), i = 0, a = r.length; i < a; ++i) t += (i !== 0 ? \", \" : \"\") + r[i] + \": \" + e[r[i]];\n    return \"\" + t;\n  },\n  be = {\n    align: \"center\",\n    anchor: \"center\",\n    backgroundColor: null,\n    borderColor: null,\n    borderRadius: 0,\n    borderWidth: 0,\n    clamp: !1,\n    clip: !1,\n    color: void 0,\n    display: !0,\n    font: {\n      family: void 0,\n      lineHeight: 1.2,\n      size: void 0,\n      style: void 0,\n      weight: null\n    },\n    formatter: ce,\n    labels: void 0,\n    listeners: {},\n    offset: 4,\n    opacity: 1,\n    padding: {\n      top: 4,\n      right: 4,\n      bottom: 4,\n      left: 4\n    },\n    rotation: 0,\n    textAlign: \"start\",\n    textStrokeColor: void 0,\n    textStrokeWidth: 0,\n    textShadowBlur: 0,\n    textShadowColor: void 0\n  },\n  h = \"$datalabels\",\n  U = \"$default\";\nfunction pe(e, t) {\n  var r = e.datalabels,\n    a = {},\n    i = [],\n    n,\n    o;\n  return r === !1 ? null : (r === !0 && (r = {}), t = g({}, [t, r]), n = t.labels || {}, o = Object.keys(n), delete t.labels, o.length ? o.forEach(function (s) {\n    n[s] && i.push(g({}, [t, n[s], {\n      _key: s\n    }]));\n  }) : i.push(t), a = i.reduce(function (s, l) {\n    return Y(l.listeners || {}, function (u, v) {\n      s[v] = s[v] || {}, s[v][l._key || U] = u;\n    }), delete l.listeners, s;\n  }, {}), {\n    labels: i,\n    listeners: a\n  });\n}\nfunction R(e, t, r, a) {\n  if (t) {\n    var i = r.$context,\n      n = r.$groups,\n      o;\n    t[n._set] && (o = t[n._set][n._key], o && z(o, [i, a]) === !0 && (e[h]._dirty = !0, r.update(i)));\n  }\n}\nfunction me(e, t, r, a, i) {\n  var n, o;\n  !r && !a || (r ? a ? r !== a && (o = n = !0) : o = !0 : n = !0, o && R(e, t.leave, r, i), n && R(e, t.enter, a, i));\n}\nfunction we(e, t) {\n  var r = e[h],\n    a = r._listeners,\n    i,\n    n;\n  if (!(!a.enter && !a.leave)) {\n    if (t.type === \"mousemove\") n = w.lookup(r._labels, t);else if (t.type !== \"mouseout\") return;\n    i = r._hovered, r._hovered = n, me(e, a, i, n, t);\n  }\n}\nfunction ge(e, t) {\n  var r = e[h],\n    a = r._listeners.click,\n    i = a && w.lookup(r._labels, t);\n  i && R(e, a, i, t);\n}\nvar Me = {\n  id: \"datalabels\",\n  defaults: be,\n  beforeInit: function beforeInit(e) {\n    e[h] = {\n      _actives: []\n    };\n  },\n  beforeUpdate: function beforeUpdate(e) {\n    var t = e[h];\n    t._listened = !1, t._listeners = {}, t._datasets = [], t._labels = [];\n  },\n  afterDatasetUpdate: function afterDatasetUpdate(e, t, r) {\n    var a = t.index,\n      i = e[h],\n      n = i._datasets[a] = [],\n      o = e.isDatasetVisible(a),\n      s = e.data.datasets[a],\n      l = pe(s, r),\n      u = t.meta.data || [],\n      v = e.ctx,\n      d,\n      y,\n      $,\n      T,\n      S,\n      B,\n      c,\n      _;\n    for (v.save(), d = 0, $ = u.length; d < $; ++d) if (c = u[d], c[h] = [], o && c && e.getDataVisibility(d) && !c.skip) for (y = 0, T = l.labels.length; y < T; ++y) S = l.labels[y], B = S._key, _ = new L(S, v, c, d), _.$groups = {\n      _set: a,\n      _key: B || U\n    }, _.$context = {\n      active: !1,\n      chart: e,\n      dataIndex: d,\n      dataset: s,\n      datasetIndex: a\n    }, _.update(_.$context), c[h].push(_), n.push(_);\n    v.restore(), g(i._listeners, l.listeners, {\n      merger: function merger(k, C, X) {\n        C[k] = C[k] || {}, C[k][t.index] = X[k], i._listened = !0;\n      }\n    });\n  },\n  afterUpdate: function afterUpdate(e) {\n    e[h]._labels = w.prepare(e[h]._datasets);\n  },\n  // Draw labels on top of all dataset elements\n  // https://github.com/chartjs/chartjs-plugin-datalabels/issues/29\n  // https://github.com/chartjs/chartjs-plugin-datalabels/issues/32\n  afterDatasetsDraw: function afterDatasetsDraw(e) {\n    w.draw(e, e[h]._labels);\n  },\n  beforeEvent: function beforeEvent(e, t) {\n    if (e[h]._listened) {\n      var r = t.event;\n      switch (r.type) {\n        case \"mousemove\":\n        case \"mouseout\":\n          we(e, r);\n          break;\n        case \"click\":\n          ge(e, r);\n          break;\n      }\n    }\n  },\n  afterEvent: function afterEvent(e) {\n    var t = e[h],\n      r = t._actives,\n      a = t._actives = e.getActiveElements(),\n      i = m.arrayDiff(r, a),\n      n,\n      o,\n      s,\n      l,\n      u,\n      v,\n      d;\n    for (n = 0, o = i.length; n < o; ++n) if (u = i[n], u[1]) for (d = u[0].element[h] || [], s = 0, l = d.length; s < l; ++s) v = d[s], v.$context.active = u[1] === 1, v.update(v.$context);\n    (t._dirty || i.length) && (w.update(t._labels), e.render()), delete t._dirty;\n  }\n};\nexport { Me as default };","map":{"version":3,"names":["D","window","devicePixelRatio","e","screen","deviceXDPI","logicalXDPI","m","toTextLines","t","r","concat","length","pop","unshift","apply","split","Array","isArray","push","p","textSize","a","i","n","font","o","s","string","Math","max","measureText","width","height","lineHeight","bound","min","arrayDiff","slice","indexOf","splice","rasterize","round","A","x","y","sqrt","ae","PI","cos","sin","vx","vy","te","j","N","O","F","M","left","right","top","bottom","ie","x0","y0","x1","y1","l","u","v","P","anchor","clamp","area","align","E","arc","startAngle","endAngle","innerRadius","outerRadius","point","origin","options","radius","bar","horizontal","base","abs","fallback","ne","borderWidth","padding","size","frame","w","h","text","oe","chart","getDatasetMeta","datasetIndex","vScale","xCenter","yCenter","getBasePixel","se","Q","Z","ee","le","d","moveTo","closePath","rect","ue","backgroundColor","borderColor","beginPath","borderRadius","fillStyle","fill","strokeStyle","lineWidth","lineJoin","stroke","ve","de","shadowBlur","stroked","strokeText","filled","fillText","fe","textAlign","color","textStrokeColor","textStrokeWidth","textBaseline","textShadowBlur","shadowColor","textShadowColor","L","_config","_index","_model","_rects","_ctx","_el","g","prototype","_modelize","q","f","J","chartArea","clip","display","lines","offset","opacity","K","positioner","rotation","update","dataset","data","V","z","formatter","geometry","visible","model","draw","ctx","save","globalAlpha","translate","rotate","restore","he","Number","MIN_SAFE_INTEGER","ye","MAX_SAFE_INTEGER","b","W","I","ln","G","_rotation","_rect","center","contains","intersects","_points","H","xe","$layout","_visible","_box","_e","Proxy","get","getProps","_hidable","prepare","_set","_idx","sort","lookup","ce","re","label","Object","keys","be","family","style","weight","labels","listeners","U","pe","datalabels","forEach","_key","reduce","Y","R","$context","$groups","_dirty","me","leave","enter","we","_listeners","type","_labels","_hovered","ge","click","Me","id","defaults","beforeInit","_actives","beforeUpdate","_listened","_datasets","afterDatasetUpdate","index","isDatasetVisible","datasets","meta","$","T","S","B","c","_","getDataVisibility","skip","active","dataIndex","merger","k","C","X","afterUpdate","afterDatasetsDraw","beforeEvent","event","afterEvent","getActiveElements","element","render"],"sources":["C:\\Users\\Matt\\node_modules\\tw-elements\\node_modules\\chartjs-plugin-datalabels\\dist\\chartjs-plugin-datalabels.esm.js"],"sourcesContent":["/*!\n * chartjs-plugin-datalabels v2.2.0\n * https://chartjs-plugin-datalabels.netlify.app\n * (c) 2017-2022 chartjs-plugin-datalabels contributors\n * Released under the MIT license\n */\nimport { isNullOrUndef, merge, toFont, resolve, toPadding, valueOrDefault, callback, isObject, each } from 'chart.js/helpers';\nimport { defaults as defaults$1, ArcElement, PointElement, BarElement } from 'chart.js';\n\nvar devicePixelRatio = (function() {\n  if (typeof window !== 'undefined') {\n    if (window.devicePixelRatio) {\n      return window.devicePixelRatio;\n    }\n\n    // devicePixelRatio is undefined on IE10\n    // https://stackoverflow.com/a/20204180/8837887\n    // https://github.com/chartjs/chartjs-plugin-datalabels/issues/85\n    var screen = window.screen;\n    if (screen) {\n      return (screen.deviceXDPI || 1) / (screen.logicalXDPI || 1);\n    }\n  }\n\n  return 1;\n}());\n\nvar utils = {\n  // @todo move this in Chart.helpers.toTextLines\n  toTextLines: function(inputs) {\n    var lines = [];\n    var input;\n\n    inputs = [].concat(inputs);\n    while (inputs.length) {\n      input = inputs.pop();\n      if (typeof input === 'string') {\n        lines.unshift.apply(lines, input.split('\\n'));\n      } else if (Array.isArray(input)) {\n        inputs.push.apply(inputs, input);\n      } else if (!isNullOrUndef(inputs)) {\n        lines.unshift('' + input);\n      }\n    }\n\n    return lines;\n  },\n\n  // @todo move this in Chart.helpers.canvas.textSize\n  // @todo cache calls of measureText if font doesn't change?!\n  textSize: function(ctx, lines, font) {\n    var items = [].concat(lines);\n    var ilen = items.length;\n    var prev = ctx.font;\n    var width = 0;\n    var i;\n\n    ctx.font = font.string;\n\n    for (i = 0; i < ilen; ++i) {\n      width = Math.max(ctx.measureText(items[i]).width, width);\n    }\n\n    ctx.font = prev;\n\n    return {\n      height: ilen * font.lineHeight,\n      width: width\n    };\n  },\n\n  /**\n   * Returns value bounded by min and max. This is equivalent to max(min, min(value, max)).\n   * @todo move this method in Chart.helpers.bound\n   * https://doc.qt.io/qt-5/qtglobal.html#qBound\n   */\n  bound: function(min, value, max) {\n    return Math.max(min, Math.min(value, max));\n  },\n\n  /**\n   * Returns an array of pair [value, state] where state is:\n   * * -1: value is only in a0 (removed)\n   * *  1: value is only in a1 (added)\n   */\n  arrayDiff: function(a0, a1) {\n    var prev = a0.slice();\n    var updates = [];\n    var i, j, ilen, v;\n\n    for (i = 0, ilen = a1.length; i < ilen; ++i) {\n      v = a1[i];\n      j = prev.indexOf(v);\n\n      if (j === -1) {\n        updates.push([v, 1]);\n      } else {\n        prev.splice(j, 1);\n      }\n    }\n\n    for (i = 0, ilen = prev.length; i < ilen; ++i) {\n      updates.push([prev[i], -1]);\n    }\n\n    return updates;\n  },\n\n  /**\n   * https://github.com/chartjs/chartjs-plugin-datalabels/issues/70\n   */\n  rasterize: function(v) {\n    return Math.round(v * devicePixelRatio) / devicePixelRatio;\n  }\n};\n\nfunction orient(point, origin) {\n  var x0 = origin.x;\n  var y0 = origin.y;\n\n  if (x0 === null) {\n    return {x: 0, y: -1};\n  }\n  if (y0 === null) {\n    return {x: 1, y: 0};\n  }\n\n  var dx = point.x - x0;\n  var dy = point.y - y0;\n  var ln = Math.sqrt(dx * dx + dy * dy);\n\n  return {\n    x: ln ? dx / ln : 0,\n    y: ln ? dy / ln : -1\n  };\n}\n\nfunction aligned(x, y, vx, vy, align) {\n  switch (align) {\n  case 'center':\n    vx = vy = 0;\n    break;\n  case 'bottom':\n    vx = 0;\n    vy = 1;\n    break;\n  case 'right':\n    vx = 1;\n    vy = 0;\n    break;\n  case 'left':\n    vx = -1;\n    vy = 0;\n    break;\n  case 'top':\n    vx = 0;\n    vy = -1;\n    break;\n  case 'start':\n    vx = -vx;\n    vy = -vy;\n    break;\n  case 'end':\n    // keep natural orientation\n    break;\n  default:\n    // clockwise rotation (in degree)\n    align *= (Math.PI / 180);\n    vx = Math.cos(align);\n    vy = Math.sin(align);\n    break;\n  }\n\n  return {\n    x: x,\n    y: y,\n    vx: vx,\n    vy: vy\n  };\n}\n\n// Line clipping (Cohen–Sutherland algorithm)\n// https://en.wikipedia.org/wiki/Cohen–Sutherland_algorithm\n\nvar R_INSIDE = 0;\nvar R_LEFT = 1;\nvar R_RIGHT = 2;\nvar R_BOTTOM = 4;\nvar R_TOP = 8;\n\nfunction region(x, y, rect) {\n  var res = R_INSIDE;\n\n  if (x < rect.left) {\n    res |= R_LEFT;\n  } else if (x > rect.right) {\n    res |= R_RIGHT;\n  }\n  if (y < rect.top) {\n    res |= R_TOP;\n  } else if (y > rect.bottom) {\n    res |= R_BOTTOM;\n  }\n\n  return res;\n}\n\nfunction clipped(segment, area) {\n  var x0 = segment.x0;\n  var y0 = segment.y0;\n  var x1 = segment.x1;\n  var y1 = segment.y1;\n  var r0 = region(x0, y0, area);\n  var r1 = region(x1, y1, area);\n  var r, x, y;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (!(r0 | r1) || (r0 & r1)) {\n      // both points inside or on the same side: no clipping\n      break;\n    }\n\n    // at least one point is outside\n    r = r0 || r1;\n\n    if (r & R_TOP) {\n      x = x0 + (x1 - x0) * (area.top - y0) / (y1 - y0);\n      y = area.top;\n    } else if (r & R_BOTTOM) {\n      x = x0 + (x1 - x0) * (area.bottom - y0) / (y1 - y0);\n      y = area.bottom;\n    } else if (r & R_RIGHT) {\n      y = y0 + (y1 - y0) * (area.right - x0) / (x1 - x0);\n      x = area.right;\n    } else if (r & R_LEFT) {\n      y = y0 + (y1 - y0) * (area.left - x0) / (x1 - x0);\n      x = area.left;\n    }\n\n    if (r === r0) {\n      x0 = x;\n      y0 = y;\n      r0 = region(x0, y0, area);\n    } else {\n      x1 = x;\n      y1 = y;\n      r1 = region(x1, y1, area);\n    }\n  }\n\n  return {\n    x0: x0,\n    x1: x1,\n    y0: y0,\n    y1: y1\n  };\n}\n\nfunction compute$1(range, config) {\n  var anchor = config.anchor;\n  var segment = range;\n  var x, y;\n\n  if (config.clamp) {\n    segment = clipped(segment, config.area);\n  }\n\n  if (anchor === 'start') {\n    x = segment.x0;\n    y = segment.y0;\n  } else if (anchor === 'end') {\n    x = segment.x1;\n    y = segment.y1;\n  } else {\n    x = (segment.x0 + segment.x1) / 2;\n    y = (segment.y0 + segment.y1) / 2;\n  }\n\n  return aligned(x, y, range.vx, range.vy, config.align);\n}\n\nvar positioners = {\n  arc: function(el, config) {\n    var angle = (el.startAngle + el.endAngle) / 2;\n    var vx = Math.cos(angle);\n    var vy = Math.sin(angle);\n    var r0 = el.innerRadius;\n    var r1 = el.outerRadius;\n\n    return compute$1({\n      x0: el.x + vx * r0,\n      y0: el.y + vy * r0,\n      x1: el.x + vx * r1,\n      y1: el.y + vy * r1,\n      vx: vx,\n      vy: vy\n    }, config);\n  },\n\n  point: function(el, config) {\n    var v = orient(el, config.origin);\n    var rx = v.x * el.options.radius;\n    var ry = v.y * el.options.radius;\n\n    return compute$1({\n      x0: el.x - rx,\n      y0: el.y - ry,\n      x1: el.x + rx,\n      y1: el.y + ry,\n      vx: v.x,\n      vy: v.y\n    }, config);\n  },\n\n  bar: function(el, config) {\n    var v = orient(el, config.origin);\n    var x = el.x;\n    var y = el.y;\n    var sx = 0;\n    var sy = 0;\n\n    if (el.horizontal) {\n      x = Math.min(el.x, el.base);\n      sx = Math.abs(el.base - el.x);\n    } else {\n      y = Math.min(el.y, el.base);\n      sy = Math.abs(el.base - el.y);\n    }\n\n    return compute$1({\n      x0: x,\n      y0: y + sy,\n      x1: x + sx,\n      y1: y,\n      vx: v.x,\n      vy: v.y\n    }, config);\n  },\n\n  fallback: function(el, config) {\n    var v = orient(el, config.origin);\n\n    return compute$1({\n      x0: el.x,\n      y0: el.y,\n      x1: el.x + (el.width || 0),\n      y1: el.y + (el.height || 0),\n      vx: v.x,\n      vy: v.y\n    }, config);\n  }\n};\n\nvar rasterize = utils.rasterize;\n\nfunction boundingRects(model) {\n  var borderWidth = model.borderWidth || 0;\n  var padding = model.padding;\n  var th = model.size.height;\n  var tw = model.size.width;\n  var tx = -tw / 2;\n  var ty = -th / 2;\n\n  return {\n    frame: {\n      x: tx - padding.left - borderWidth,\n      y: ty - padding.top - borderWidth,\n      w: tw + padding.width + borderWidth * 2,\n      h: th + padding.height + borderWidth * 2\n    },\n    text: {\n      x: tx,\n      y: ty,\n      w: tw,\n      h: th\n    }\n  };\n}\n\nfunction getScaleOrigin(el, context) {\n  var scale = context.chart.getDatasetMeta(context.datasetIndex).vScale;\n\n  if (!scale) {\n    return null;\n  }\n\n  if (scale.xCenter !== undefined && scale.yCenter !== undefined) {\n    return {x: scale.xCenter, y: scale.yCenter};\n  }\n\n  var pixel = scale.getBasePixel();\n  return el.horizontal ?\n    {x: pixel, y: null} :\n    {x: null, y: pixel};\n}\n\nfunction getPositioner(el) {\n  if (el instanceof ArcElement) {\n    return positioners.arc;\n  }\n  if (el instanceof PointElement) {\n    return positioners.point;\n  }\n  if (el instanceof BarElement) {\n    return positioners.bar;\n  }\n  return positioners.fallback;\n}\n\nfunction drawRoundedRect(ctx, x, y, w, h, radius) {\n  var HALF_PI = Math.PI / 2;\n\n  if (radius) {\n    var r = Math.min(radius, h / 2, w / 2);\n    var left = x + r;\n    var top = y + r;\n    var right = x + w - r;\n    var bottom = y + h - r;\n\n    ctx.moveTo(x, top);\n    if (left < right && top < bottom) {\n      ctx.arc(left, top, r, -Math.PI, -HALF_PI);\n      ctx.arc(right, top, r, -HALF_PI, 0);\n      ctx.arc(right, bottom, r, 0, HALF_PI);\n      ctx.arc(left, bottom, r, HALF_PI, Math.PI);\n    } else if (left < right) {\n      ctx.moveTo(left, y);\n      ctx.arc(right, top, r, -HALF_PI, HALF_PI);\n      ctx.arc(left, top, r, HALF_PI, Math.PI + HALF_PI);\n    } else if (top < bottom) {\n      ctx.arc(left, top, r, -Math.PI, 0);\n      ctx.arc(left, bottom, r, 0, Math.PI);\n    } else {\n      ctx.arc(left, top, r, -Math.PI, Math.PI);\n    }\n    ctx.closePath();\n    ctx.moveTo(x, y);\n  } else {\n    ctx.rect(x, y, w, h);\n  }\n}\n\nfunction drawFrame(ctx, rect, model) {\n  var bgColor = model.backgroundColor;\n  var borderColor = model.borderColor;\n  var borderWidth = model.borderWidth;\n\n  if (!bgColor && (!borderColor || !borderWidth)) {\n    return;\n  }\n\n  ctx.beginPath();\n\n  drawRoundedRect(\n    ctx,\n    rasterize(rect.x) + borderWidth / 2,\n    rasterize(rect.y) + borderWidth / 2,\n    rasterize(rect.w) - borderWidth,\n    rasterize(rect.h) - borderWidth,\n    model.borderRadius);\n\n  ctx.closePath();\n\n  if (bgColor) {\n    ctx.fillStyle = bgColor;\n    ctx.fill();\n  }\n\n  if (borderColor && borderWidth) {\n    ctx.strokeStyle = borderColor;\n    ctx.lineWidth = borderWidth;\n    ctx.lineJoin = 'miter';\n    ctx.stroke();\n  }\n}\n\nfunction textGeometry(rect, align, font) {\n  var h = font.lineHeight;\n  var w = rect.w;\n  var x = rect.x;\n  var y = rect.y + h / 2;\n\n  if (align === 'center') {\n    x += w / 2;\n  } else if (align === 'end' || align === 'right') {\n    x += w;\n  }\n\n  return {\n    h: h,\n    w: w,\n    x: x,\n    y: y\n  };\n}\n\nfunction drawTextLine(ctx, text, cfg) {\n  var shadow = ctx.shadowBlur;\n  var stroked = cfg.stroked;\n  var x = rasterize(cfg.x);\n  var y = rasterize(cfg.y);\n  var w = rasterize(cfg.w);\n\n  if (stroked) {\n    ctx.strokeText(text, x, y, w);\n  }\n\n  if (cfg.filled) {\n    if (shadow && stroked) {\n      // Prevent drawing shadow on both the text stroke and fill, so\n      // if the text is stroked, remove the shadow for the text fill.\n      ctx.shadowBlur = 0;\n    }\n\n    ctx.fillText(text, x, y, w);\n\n    if (shadow && stroked) {\n      ctx.shadowBlur = shadow;\n    }\n  }\n}\n\nfunction drawText(ctx, lines, rect, model) {\n  var align = model.textAlign;\n  var color = model.color;\n  var filled = !!color;\n  var font = model.font;\n  var ilen = lines.length;\n  var strokeColor = model.textStrokeColor;\n  var strokeWidth = model.textStrokeWidth;\n  var stroked = strokeColor && strokeWidth;\n  var i;\n\n  if (!ilen || (!filled && !stroked)) {\n    return;\n  }\n\n  // Adjust coordinates based on text alignment and line height\n  rect = textGeometry(rect, align, font);\n\n  ctx.font = font.string;\n  ctx.textAlign = align;\n  ctx.textBaseline = 'middle';\n  ctx.shadowBlur = model.textShadowBlur;\n  ctx.shadowColor = model.textShadowColor;\n\n  if (filled) {\n    ctx.fillStyle = color;\n  }\n  if (stroked) {\n    ctx.lineJoin = 'round';\n    ctx.lineWidth = strokeWidth;\n    ctx.strokeStyle = strokeColor;\n  }\n\n  for (i = 0, ilen = lines.length; i < ilen; ++i) {\n    drawTextLine(ctx, lines[i], {\n      stroked: stroked,\n      filled: filled,\n      w: rect.w,\n      x: rect.x,\n      y: rect.y + rect.h * i\n    });\n  }\n}\n\nvar Label = function(config, ctx, el, index) {\n  var me = this;\n\n  me._config = config;\n  me._index = index;\n  me._model = null;\n  me._rects = null;\n  me._ctx = ctx;\n  me._el = el;\n};\n\nmerge(Label.prototype, {\n  /**\n   * @private\n   */\n  _modelize: function(display, lines, config, context) {\n    var me = this;\n    var index = me._index;\n    var font = toFont(resolve([config.font, {}], context, index));\n    var color = resolve([config.color, defaults$1.color], context, index);\n\n    return {\n      align: resolve([config.align, 'center'], context, index),\n      anchor: resolve([config.anchor, 'center'], context, index),\n      area: context.chart.chartArea,\n      backgroundColor: resolve([config.backgroundColor, null], context, index),\n      borderColor: resolve([config.borderColor, null], context, index),\n      borderRadius: resolve([config.borderRadius, 0], context, index),\n      borderWidth: resolve([config.borderWidth, 0], context, index),\n      clamp: resolve([config.clamp, false], context, index),\n      clip: resolve([config.clip, false], context, index),\n      color: color,\n      display: display,\n      font: font,\n      lines: lines,\n      offset: resolve([config.offset, 4], context, index),\n      opacity: resolve([config.opacity, 1], context, index),\n      origin: getScaleOrigin(me._el, context),\n      padding: toPadding(resolve([config.padding, 4], context, index)),\n      positioner: getPositioner(me._el),\n      rotation: resolve([config.rotation, 0], context, index) * (Math.PI / 180),\n      size: utils.textSize(me._ctx, lines, font),\n      textAlign: resolve([config.textAlign, 'start'], context, index),\n      textShadowBlur: resolve([config.textShadowBlur, 0], context, index),\n      textShadowColor: resolve([config.textShadowColor, color], context, index),\n      textStrokeColor: resolve([config.textStrokeColor, color], context, index),\n      textStrokeWidth: resolve([config.textStrokeWidth, 0], context, index)\n    };\n  },\n\n  update: function(context) {\n    var me = this;\n    var model = null;\n    var rects = null;\n    var index = me._index;\n    var config = me._config;\n    var value, label, lines;\n\n    // We first resolve the display option (separately) to avoid computing\n    // other options in case the label is hidden (i.e. display: false).\n    var display = resolve([config.display, true], context, index);\n\n    if (display) {\n      value = context.dataset.data[index];\n      label = valueOrDefault(callback(config.formatter, [value, context]), value);\n      lines = isNullOrUndef(label) ? [] : utils.toTextLines(label);\n\n      if (lines.length) {\n        model = me._modelize(display, lines, config, context);\n        rects = boundingRects(model);\n      }\n    }\n\n    me._model = model;\n    me._rects = rects;\n  },\n\n  geometry: function() {\n    return this._rects ? this._rects.frame : {};\n  },\n\n  rotation: function() {\n    return this._model ? this._model.rotation : 0;\n  },\n\n  visible: function() {\n    return this._model && this._model.opacity;\n  },\n\n  model: function() {\n    return this._model;\n  },\n\n  draw: function(chart, center) {\n    var me = this;\n    var ctx = chart.ctx;\n    var model = me._model;\n    var rects = me._rects;\n    var area;\n\n    if (!this.visible()) {\n      return;\n    }\n\n    ctx.save();\n\n    if (model.clip) {\n      area = model.area;\n      ctx.beginPath();\n      ctx.rect(\n        area.left,\n        area.top,\n        area.right - area.left,\n        area.bottom - area.top);\n      ctx.clip();\n    }\n\n    ctx.globalAlpha = utils.bound(0, model.opacity, 1);\n    ctx.translate(rasterize(center.x), rasterize(center.y));\n    ctx.rotate(model.rotation);\n\n    drawFrame(ctx, rects.frame, model);\n    drawText(ctx, model.lines, rects.text, model);\n\n    ctx.restore();\n  }\n});\n\nvar MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991; // eslint-disable-line es/no-number-minsafeinteger\nvar MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;  // eslint-disable-line es/no-number-maxsafeinteger\n\nfunction rotated(point, center, angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  var cx = center.x;\n  var cy = center.y;\n\n  return {\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n  };\n}\n\nfunction projected(points, axis) {\n  var min = MAX_INTEGER;\n  var max = MIN_INTEGER;\n  var origin = axis.origin;\n  var i, pt, vx, vy, dp;\n\n  for (i = 0; i < points.length; ++i) {\n    pt = points[i];\n    vx = pt.x - origin.x;\n    vy = pt.y - origin.y;\n    dp = axis.vx * vx + axis.vy * vy;\n    min = Math.min(min, dp);\n    max = Math.max(max, dp);\n  }\n\n  return {\n    min: min,\n    max: max\n  };\n}\n\nfunction toAxis(p0, p1) {\n  var vx = p1.x - p0.x;\n  var vy = p1.y - p0.y;\n  var ln = Math.sqrt(vx * vx + vy * vy);\n\n  return {\n    vx: (p1.x - p0.x) / ln,\n    vy: (p1.y - p0.y) / ln,\n    origin: p0,\n    ln: ln\n  };\n}\n\nvar HitBox = function() {\n  this._rotation = 0;\n  this._rect = {\n    x: 0,\n    y: 0,\n    w: 0,\n    h: 0\n  };\n};\n\nmerge(HitBox.prototype, {\n  center: function() {\n    var r = this._rect;\n    return {\n      x: r.x + r.w / 2,\n      y: r.y + r.h / 2\n    };\n  },\n\n  update: function(center, rect, rotation) {\n    this._rotation = rotation;\n    this._rect = {\n      x: rect.x + center.x,\n      y: rect.y + center.y,\n      w: rect.w,\n      h: rect.h\n    };\n  },\n\n  contains: function(point) {\n    var me = this;\n    var margin = 1;\n    var rect = me._rect;\n\n    point = rotated(point, me.center(), -me._rotation);\n\n    return !(point.x < rect.x - margin\n      || point.y < rect.y - margin\n      || point.x > rect.x + rect.w + margin * 2\n      || point.y > rect.y + rect.h + margin * 2);\n  },\n\n  // Separating Axis Theorem\n  // https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169\n  intersects: function(other) {\n    var r0 = this._points();\n    var r1 = other._points();\n    var axes = [\n      toAxis(r0[0], r0[1]),\n      toAxis(r0[0], r0[3])\n    ];\n    var i, pr0, pr1;\n\n    if (this._rotation !== other._rotation) {\n      // Only separate with r1 axis if the rotation is different,\n      // else it's enough to separate r0 and r1 with r0 axis only!\n      axes.push(\n        toAxis(r1[0], r1[1]),\n        toAxis(r1[0], r1[3])\n      );\n    }\n\n    for (i = 0; i < axes.length; ++i) {\n      pr0 = projected(r0, axes[i]);\n      pr1 = projected(r1, axes[i]);\n\n      if (pr0.max < pr1.min || pr1.max < pr0.min) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\n   * @private\n   */\n  _points: function() {\n    var me = this;\n    var rect = me._rect;\n    var angle = me._rotation;\n    var center = me.center();\n\n    return [\n      rotated({x: rect.x, y: rect.y}, center, angle),\n      rotated({x: rect.x + rect.w, y: rect.y}, center, angle),\n      rotated({x: rect.x + rect.w, y: rect.y + rect.h}, center, angle),\n      rotated({x: rect.x, y: rect.y + rect.h}, center, angle)\n    ];\n  }\n});\n\nfunction coordinates(el, model, geometry) {\n  var point = model.positioner(el, model);\n  var vx = point.vx;\n  var vy = point.vy;\n\n  if (!vx && !vy) {\n    // if aligned center, we don't want to offset the center point\n    return {x: point.x, y: point.y};\n  }\n\n  var w = geometry.w;\n  var h = geometry.h;\n\n  // take in account the label rotation\n  var rotation = model.rotation;\n  var dx = Math.abs(w / 2 * Math.cos(rotation)) + Math.abs(h / 2 * Math.sin(rotation));\n  var dy = Math.abs(w / 2 * Math.sin(rotation)) + Math.abs(h / 2 * Math.cos(rotation));\n\n  // scale the unit vector (vx, vy) to get at least dx or dy equal to\n  // w or h respectively (else we would calculate the distance to the\n  // ellipse inscribed in the bounding rect)\n  var vs = 1 / Math.max(Math.abs(vx), Math.abs(vy));\n  dx *= vx * vs;\n  dy *= vy * vs;\n\n  // finally, include the explicit offset\n  dx += model.offset * vx;\n  dy += model.offset * vy;\n\n  return {\n    x: point.x + dx,\n    y: point.y + dy\n  };\n}\n\nfunction collide(labels, collider) {\n  var i, j, s0, s1;\n\n  // IMPORTANT Iterate in the reverse order since items at the end of the\n  // list have an higher weight/priority and thus should be less impacted\n  // by the overlapping strategy.\n\n  for (i = labels.length - 1; i >= 0; --i) {\n    s0 = labels[i].$layout;\n\n    for (j = i - 1; j >= 0 && s0._visible; --j) {\n      s1 = labels[j].$layout;\n\n      if (s1._visible && s0._box.intersects(s1._box)) {\n        collider(s0, s1);\n      }\n    }\n  }\n\n  return labels;\n}\n\nfunction compute(labels) {\n  var i, ilen, label, state, geometry, center, proxy;\n\n  // Initialize labels for overlap detection\n  for (i = 0, ilen = labels.length; i < ilen; ++i) {\n    label = labels[i];\n    state = label.$layout;\n\n    if (state._visible) {\n      // Chart.js 3 removed el._model in favor of getProps(), making harder to\n      // abstract reading values in positioners. Also, using string arrays to\n      // read values (i.e. var {a,b,c} = el.getProps([\"a\",\"b\",\"c\"])) would make\n      // positioners inefficient in the normal case (i.e. not the final values)\n      // and the code a bit ugly, so let's use a Proxy instead.\n      proxy = new Proxy(label._el, {get: (el, p) => el.getProps([p], true)[p]});\n\n      geometry = label.geometry();\n      center = coordinates(proxy, label.model(), geometry);\n      state._box.update(center, geometry, label.rotation());\n    }\n  }\n\n  // Auto hide overlapping labels\n  return collide(labels, function(s0, s1) {\n    var h0 = s0._hidable;\n    var h1 = s1._hidable;\n\n    if ((h0 && h1) || h1) {\n      s1._visible = false;\n    } else if (h0) {\n      s0._visible = false;\n    }\n  });\n}\n\nvar layout = {\n  prepare: function(datasets) {\n    var labels = [];\n    var i, j, ilen, jlen, label;\n\n    for (i = 0, ilen = datasets.length; i < ilen; ++i) {\n      for (j = 0, jlen = datasets[i].length; j < jlen; ++j) {\n        label = datasets[i][j];\n        labels.push(label);\n        label.$layout = {\n          _box: new HitBox(),\n          _hidable: false,\n          _visible: true,\n          _set: i,\n          _idx: label._index\n        };\n      }\n    }\n\n    // TODO New `z` option: labels with a higher z-index are drawn\n    // of top of the ones with a lower index. Lowest z-index labels\n    // are also discarded first when hiding overlapping labels.\n    labels.sort(function(a, b) {\n      var sa = a.$layout;\n      var sb = b.$layout;\n\n      return sa._idx === sb._idx\n        ? sb._set - sa._set\n        : sb._idx - sa._idx;\n    });\n\n    this.update(labels);\n\n    return labels;\n  },\n\n  update: function(labels) {\n    var dirty = false;\n    var i, ilen, label, model, state;\n\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      label = labels[i];\n      model = label.model();\n      state = label.$layout;\n      state._hidable = model && model.display === 'auto';\n      state._visible = label.visible();\n      dirty |= state._hidable;\n    }\n\n    if (dirty) {\n      compute(labels);\n    }\n  },\n\n  lookup: function(labels, point) {\n    var i, state;\n\n    // IMPORTANT Iterate in the reverse order since items at the end of\n    // the list have an higher z-index, thus should be picked first.\n\n    for (i = labels.length - 1; i >= 0; --i) {\n      state = labels[i].$layout;\n\n      if (state && state._visible && state._box.contains(point)) {\n        return labels[i];\n      }\n    }\n\n    return null;\n  },\n\n  draw: function(chart, labels) {\n    var i, ilen, label, state, geometry, center;\n\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      label = labels[i];\n      state = label.$layout;\n\n      if (state._visible) {\n        geometry = label.geometry();\n        center = coordinates(label._el, label.model(), geometry);\n        state._box.update(center, geometry, label.rotation());\n        label.draw(chart, center);\n      }\n    }\n  }\n};\n\nvar formatter = function(value) {\n  if (isNullOrUndef(value)) {\n    return null;\n  }\n\n  var label = value;\n  var keys, klen, k;\n  if (isObject(value)) {\n    if (!isNullOrUndef(value.label)) {\n      label = value.label;\n    } else if (!isNullOrUndef(value.r)) {\n      label = value.r;\n    } else {\n      label = '';\n      keys = Object.keys(value);\n      for (k = 0, klen = keys.length; k < klen; ++k) {\n        label += (k !== 0 ? ', ' : '') + keys[k] + ': ' + value[keys[k]];\n      }\n    }\n  }\n\n  return '' + label;\n};\n\n/**\n * IMPORTANT: make sure to also update tests and TypeScript definition\n * files (`/test/specs/defaults.spec.js` and `/types/options.d.ts`)\n */\n\nvar defaults = {\n  align: 'center',\n  anchor: 'center',\n  backgroundColor: null,\n  borderColor: null,\n  borderRadius: 0,\n  borderWidth: 0,\n  clamp: false,\n  clip: false,\n  color: undefined,\n  display: true,\n  font: {\n    family: undefined,\n    lineHeight: 1.2,\n    size: undefined,\n    style: undefined,\n    weight: null\n  },\n  formatter: formatter,\n  labels: undefined,\n  listeners: {},\n  offset: 4,\n  opacity: 1,\n  padding: {\n    top: 4,\n    right: 4,\n    bottom: 4,\n    left: 4\n  },\n  rotation: 0,\n  textAlign: 'start',\n  textStrokeColor: undefined,\n  textStrokeWidth: 0,\n  textShadowBlur: 0,\n  textShadowColor: undefined\n};\n\n/**\n * @see https://github.com/chartjs/Chart.js/issues/4176\n */\n\nvar EXPANDO_KEY = '$datalabels';\nvar DEFAULT_KEY = '$default';\n\nfunction configure(dataset, options) {\n  var override = dataset.datalabels;\n  var listeners = {};\n  var configs = [];\n  var labels, keys;\n\n  if (override === false) {\n    return null;\n  }\n  if (override === true) {\n    override = {};\n  }\n\n  options = merge({}, [options, override]);\n  labels = options.labels || {};\n  keys = Object.keys(labels);\n  delete options.labels;\n\n  if (keys.length) {\n    keys.forEach(function(key) {\n      if (labels[key]) {\n        configs.push(merge({}, [\n          options,\n          labels[key],\n          {_key: key}\n        ]));\n      }\n    });\n  } else {\n    // Default label if no \"named\" label defined.\n    configs.push(options);\n  }\n\n  // listeners: {<event-type>: {<label-key>: <fn>}}\n  listeners = configs.reduce(function(target, config) {\n    each(config.listeners || {}, function(fn, event) {\n      target[event] = target[event] || {};\n      target[event][config._key || DEFAULT_KEY] = fn;\n    });\n\n    delete config.listeners;\n    return target;\n  }, {});\n\n  return {\n    labels: configs,\n    listeners: listeners\n  };\n}\n\nfunction dispatchEvent(chart, listeners, label, event) {\n  if (!listeners) {\n    return;\n  }\n\n  var context = label.$context;\n  var groups = label.$groups;\n  var callback$1;\n\n  if (!listeners[groups._set]) {\n    return;\n  }\n\n  callback$1 = listeners[groups._set][groups._key];\n  if (!callback$1) {\n    return;\n  }\n\n  if (callback(callback$1, [context, event]) === true) {\n    // Users are allowed to tweak the given context by injecting values that can be\n    // used in scriptable options to display labels differently based on the current\n    // event (e.g. highlight an hovered label). That's why we update the label with\n    // the output context and schedule a new chart render by setting it dirty.\n    chart[EXPANDO_KEY]._dirty = true;\n    label.update(context);\n  }\n}\n\nfunction dispatchMoveEvents(chart, listeners, previous, label, event) {\n  var enter, leave;\n\n  if (!previous && !label) {\n    return;\n  }\n\n  if (!previous) {\n    enter = true;\n  } else if (!label) {\n    leave = true;\n  } else if (previous !== label) {\n    leave = enter = true;\n  }\n\n  if (leave) {\n    dispatchEvent(chart, listeners.leave, previous, event);\n  }\n  if (enter) {\n    dispatchEvent(chart, listeners.enter, label, event);\n  }\n}\n\nfunction handleMoveEvents(chart, event) {\n  var expando = chart[EXPANDO_KEY];\n  var listeners = expando._listeners;\n  var previous, label;\n\n  if (!listeners.enter && !listeners.leave) {\n    return;\n  }\n\n  if (event.type === 'mousemove') {\n    label = layout.lookup(expando._labels, event);\n  } else if (event.type !== 'mouseout') {\n    return;\n  }\n\n  previous = expando._hovered;\n  expando._hovered = label;\n  dispatchMoveEvents(chart, listeners, previous, label, event);\n}\n\nfunction handleClickEvents(chart, event) {\n  var expando = chart[EXPANDO_KEY];\n  var handlers = expando._listeners.click;\n  var label = handlers && layout.lookup(expando._labels, event);\n  if (label) {\n    dispatchEvent(chart, handlers, label, event);\n  }\n}\n\nvar plugin = {\n  id: 'datalabels',\n\n  defaults: defaults,\n\n  beforeInit: function(chart) {\n    chart[EXPANDO_KEY] = {\n      _actives: []\n    };\n  },\n\n  beforeUpdate: function(chart) {\n    var expando = chart[EXPANDO_KEY];\n    expando._listened = false;\n    expando._listeners = {};     // {<event-type>: {<dataset-index>: {<label-key>: <fn>}}}\n    expando._datasets = [];      // per dataset labels: [Label[]]\n    expando._labels = [];        // layouted labels: Label[]\n  },\n\n  afterDatasetUpdate: function(chart, args, options) {\n    var datasetIndex = args.index;\n    var expando = chart[EXPANDO_KEY];\n    var labels = expando._datasets[datasetIndex] = [];\n    var visible = chart.isDatasetVisible(datasetIndex);\n    var dataset = chart.data.datasets[datasetIndex];\n    var config = configure(dataset, options);\n    var elements = args.meta.data || [];\n    var ctx = chart.ctx;\n    var i, j, ilen, jlen, cfg, key, el, label;\n\n    ctx.save();\n\n    for (i = 0, ilen = elements.length; i < ilen; ++i) {\n      el = elements[i];\n      el[EXPANDO_KEY] = [];\n\n      if (visible && el && chart.getDataVisibility(i) && !el.skip) {\n        for (j = 0, jlen = config.labels.length; j < jlen; ++j) {\n          cfg = config.labels[j];\n          key = cfg._key;\n\n          label = new Label(cfg, ctx, el, i);\n          label.$groups = {\n            _set: datasetIndex,\n            _key: key || DEFAULT_KEY\n          };\n          label.$context = {\n            active: false,\n            chart: chart,\n            dataIndex: i,\n            dataset: dataset,\n            datasetIndex: datasetIndex\n          };\n\n          label.update(label.$context);\n          el[EXPANDO_KEY].push(label);\n          labels.push(label);\n        }\n      }\n    }\n\n    ctx.restore();\n\n    // Store listeners at the chart level and per event type to optimize\n    // cases where no listeners are registered for a specific event.\n    merge(expando._listeners, config.listeners, {\n      merger: function(event, target, source) {\n        target[event] = target[event] || {};\n        target[event][args.index] = source[event];\n        expando._listened = true;\n      }\n    });\n  },\n\n  afterUpdate: function(chart) {\n    chart[EXPANDO_KEY]._labels = layout.prepare(chart[EXPANDO_KEY]._datasets);\n  },\n\n  // Draw labels on top of all dataset elements\n  // https://github.com/chartjs/chartjs-plugin-datalabels/issues/29\n  // https://github.com/chartjs/chartjs-plugin-datalabels/issues/32\n  afterDatasetsDraw: function(chart) {\n    layout.draw(chart, chart[EXPANDO_KEY]._labels);\n  },\n\n  beforeEvent: function(chart, args) {\n    // If there is no listener registered for this chart, `listened` will be false,\n    // meaning we can immediately ignore the incoming event and avoid useless extra\n    // computation for users who don't implement label interactions.\n    if (chart[EXPANDO_KEY]._listened) {\n      var event = args.event;\n      switch (event.type) {\n      case 'mousemove':\n      case 'mouseout':\n        handleMoveEvents(chart, event);\n        break;\n      case 'click':\n        handleClickEvents(chart, event);\n        break;\n      }\n    }\n  },\n\n  afterEvent: function(chart) {\n    var expando = chart[EXPANDO_KEY];\n    var previous = expando._actives;\n    var actives = expando._actives = chart.getActiveElements();\n    var updates = utils.arrayDiff(previous, actives);\n    var i, ilen, j, jlen, update, label, labels;\n\n    for (i = 0, ilen = updates.length; i < ilen; ++i) {\n      update = updates[i];\n      if (update[1]) {\n        labels = update[0].element[EXPANDO_KEY] || [];\n        for (j = 0, jlen = labels.length; j < jlen; ++j) {\n          label = labels[j];\n          label.$context.active = (update[1] === 1);\n          label.update(label.$context);\n        }\n      }\n    }\n\n    if (expando._dirty || updates.length) {\n      layout.update(expando._labels);\n      chart.render();\n    }\n\n    delete expando._dirty;\n  }\n};\n\nexport { plugin as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}